-- Updated black hole script
-- Changes: removed Continuous Loop Check toggle; integrated workspace scanning into
-- the unanchored anchor/unanchor flow to pick up more parts while avoiding
-- double-processing (uses processedParts map). This reduces lag from repeated
-- global scans.

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer

local blackHoleActive = false
local toggleState = false
local targetPlayer = nil
local switchDelay = 0.13
-- processedParts now maps part -> attachmentIndex (number)
local processedParts = {}
local initiallyAnchoredParts = {}
local anchoredOnce = false
local unanchorTimerRunning = false
local unanchorCoroutine

local noclipConnection

-- single attachment fallback (keeps compatibility)
local Attachment1 = nil

-- NEW: attachments management
local attachmentsFolder = nil -- Folder in Workspace containing attachment Parts (invisible)
local attachments = {} -- list of {Part = Part, Attachment = Attachment, mode = "free"|"player", targetPlayer = Player}
local attachmentsMode = "single" -- "single", "multi", "paa" (player amount attachments)
local commandConnection = nil
local playerAttachIndex = {} -- map player -> attachment index (for PAA)

-- Setup initial Attachment similar to before
local function setupPlayer()
    local Folder = Instance.new("Folder", Workspace)
    local Part = Instance.new("Part", Folder)
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1
    local Attachment = Instance.new("Attachment", Part)
    return Attachment, Folder
end

Attachment1, attachmentsFolder = setupPlayer()

-- utility: cleanup attachment folder
local function clearAttachmentsFolder()
    if attachmentsFolder and attachmentsFolder.Parent then
        attachmentsFolder:Destroy()
    end
    attachmentsFolder = nil
    attachments = {}
    playerAttachIndex = {}
end

-- Detect if a character is an NPC (has Humanoid but not a player character)
local function isNPC(character)
    if not character or not character:IsA("Model") then return false end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and not Players:GetPlayerFromCharacter(character) then
        return true
    end
    return false
end

-- Enable or disable collisions on a character's parts
local function setCharacterCollision(character, canCollide)
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = canCollide
        end
    end
end

-- Enable noclip for local player but keep collisions with their own parts ON
local function enableLocalPlayerNoclip(enable)
    if enable then
        -- Disconnect previous connection if any
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end

        noclipConnection = RunService.Stepped:Connect(function()
            local character = localPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        if part.Name == "HumanoidRootPart" then
                            part.CanCollide = false
                        else
                            part.CanCollide = true
                        end
                    end
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        -- Reset collisions on local player parts
        local character = localPlayer.Character
        if character then
            setCharacterCollision(character, true)
        end
    end
end

-- Modified ForcePart: assign AlignPosition.Attachment1 depending on which attachment index the part is assigned to.
local function ForcePart(v)
    if not v or not v:IsA("BasePart") then return end
    if processedParts[v] then return end
    if v.Anchored then return end
    if v.Name == "Handle" then return end
    if v:IsDescendantOf(localPlayer.Character) then return end

    if not (
        (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
        or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
    ) then
        return
    end

    -- assign this part to an attachment index
    local assignIndex = 1
    if #attachments > 0 then
        -- choose nearest attachment by 3D distance as default assignment
        local bestDist, bestI = math.huge, 1
        for i, a in ipairs(attachments) do
            if a and a.Part and a.Attachment then
                local pos = a.Part.Position
                local d = (v.Position - pos).Magnitude
                if d < bestDist then
                    bestDist = d
                    bestI = i
                end
            end
        end
        assignIndex = bestI
    end

    processedParts[v] = assignIndex

    -- destroy existing physics objects if present
    for _, x in next, v:GetChildren() do
        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
            or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
            or x:IsA("RocketPropulsion") then
            x:Destroy()
        end
    end
    if v:FindFirstChild("Attachment") then v:FindFirstChild("Attachment"):Destroy() end
    if v:FindFirstChild("AlignPosition") then v:FindFirstChild("AlignPosition"):Destroy() end
    if v:FindFirstChild("Torque") then v:FindFirstChild("Torque"):Destroy() end

    v.CanCollide = false -- parts affected by ForcePart should not collide with anything

    local Torque = Instance.new("Torque", v)
    Torque.Torque = Vector3.new(1e6, 1e6, 1e6)
    local AlignPosition = Instance.new("AlignPosition", v)
    local Attachment2 = Instance.new("Attachment", v)
    Torque.Attachment0 = Attachment2
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.Responsiveness = 500
    AlignPosition.Attachment0 = Attachment2

    -- Attach to chosen attachment (fall back to Attachment1 if none)
    if attachments[assignIndex] and attachments[assignIndex].Attachment then
        AlignPosition.Attachment1 = attachments[assignIndex].Attachment
    else
        AlignPosition.Attachment1 = Attachment1
        processedParts[v] = 1 -- ensure mapping to 1
    end
end

-- clear processed parts (modified to consider attachments)
local function clearProcessedParts()
    for part, _ in pairs(processedParts) do
        if part and part.Parent then
            for _, x in next, part:GetChildren() do
                if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
                    or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
                    or x:IsA("RocketPropulsion") then
                    x:Destroy()
                end
            end
            if part:FindFirstChild("Attachment") then part:FindFirstChild("Attachment"):Destroy() end
            if part:FindFirstChild("AlignPosition") then part:FindFirstChild("AlignPosition"):Destroy() end
            if part:FindFirstChild("Torque") then part:FindFirstChild("Torque"):Destroy() end
            part.CanCollide = true
            if not initiallyAnchoredParts[part] then
                part.Anchored = false
            else
                part.Anchored = true
            end
        end
    end
    processedParts = {}
    initiallyAnchoredParts = {}
    anchoredOnce = false
end

local function disableCollisionsForCharacterButNotWorldCollision(character)
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

-- anchor candidate parts then unanchor and ForcePart them after timer
-- integrated workspace scanning added to pick up additional parts while avoiding double-processing
local function anchorAndDelayedUnanchorParts()
    if unanchorTimerRunning then return end
    unanchorTimerRunning = true

    local candidateParts = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart")
            and not v.Anchored
            and v.Name ~= "Handle"
            and not v:IsDescendantOf(localPlayer.Character)
            and (
                (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
            ) then
            table.insert(candidateParts, v)
        end
    end

    initiallyAnchoredParts = {}
    for _, part in ipairs(candidateParts) do
        initiallyAnchoredParts[part] = false
        -- anchor temporarily to avoid physics interference
        part.Anchored = true
        part.CanCollide = false
    end

    -- Enable collisions for NPC characters
    for _, npcCandidate in ipairs(Workspace:GetChildren()) do
        if isNPC(npcCandidate) then
            disableCollisionsForCharacterButNotWorldCollision(npcCandidate)
        end
    end

    -- Disable collisions for local player parts except keep CanCollide true for all parts of the local player
    local character = localPlayer.Character
    if character then
        setCharacterCollision(character, true)
    end

    -- Enable noclip for local player (so they don't collide with world)
    enableLocalPlayerNoclip(true)

    local startTime = tick()
    -- keep them anchored for up to 10 seconds while black hole activates (original behavior)
    while blackHoleActive and tick() - startTime < 10 do
        wait(0.1)
    end

    -- After the hold period, unanchor candidate parts and immediately attempt to ForcePart them
    for _, part in ipairs(candidateParts) do
        if part and part.Parent and initiallyAnchoredParts[part] == false then
            part.Anchored = false
            ForcePart(part)
        end
    end

    -- Integrated loop-scanner: for a short duration, scan the workspace for any remaining eligible parts
    -- and ForcePart them. We check processedParts to avoid double-processing which reduces lag.
    local scanDuration = 5 -- seconds to continue scanning after unanchor (tweakable)
    local scanStart = tick()
    while blackHoleActive and tick() - scanStart < scanDuration do
        for _, v in ipairs(Workspace:GetDescendants()) do
            if v:IsA("BasePart")
                and not v.Anchored
                and v.Name ~= "Handle"
                and not v:IsDescendantOf(localPlayer.Character)
                and not processedParts[v]
                and (
                    (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                    or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
                ) then
                ForcePart(v)
            end
        end
        wait(0.25)
    end

    unanchorTimerRunning = false
    anchoredOnce = true
end

local descendantAddedConn

local function processWorkspaceParts()
    if descendantAddedConn then
        descendantAddedConn:Disconnect()
        descendantAddedConn = nil
    end

    if blackHoleActive then
        if not unanchorTimerRunning and not anchoredOnce then
            unanchorCoroutine = coroutine.create(anchorAndDelayedUnanchorParts)
            coroutine.resume(unanchorCoroutine)
        end

        descendantAddedConn = Workspace.DescendantAdded:Connect(function(v)
            if blackHoleActive then
                if v:IsA("BasePart") and not v.Anchored then
                    ForcePart(v)
                end
            end
        end)
    end
end

local function getRandomPlayer()
    local players = Players:GetPlayers()
    local validPlayers = {}
    for _, player in pairs(players) do
        if player ~= localPlayer and (not player:FindFirstChild("Whitelisted") or not player.Whitelisted.Value) then
            table.insert(validPlayers, player)
        end
    end
    if #validPlayers > 0 then
        return validPlayers[math.random(1, #validPlayers)]
    end
    return nil
end

local function getSelectedPlayers()
    local players = Players:GetPlayers()
    local selectedPlayers = {}
    for _, player in pairs(players) do
        if player ~= localPlayer and player:FindFirstChild("Selected") and player.Selected.Value then
            table.insert(selectedPlayers, player)
        end
    end
    return selectedPlayers
end

-- --------------- NEW: attachments helpers ----------------

local function createAttachments(count)
    -- clear previous attachments folder + data
    clearAttachmentsFolder()
    attachmentsFolder = Instance.new("Folder", Workspace)
    attachmentsFolder.Name = "ÆS_Attachments_" .. tostring(tick())

    attachments = {}

    count = math.max(1, math.floor(count or 1))

    -- If only one, attach to localPlayer.HumanoidRootPart as before
    if count == 1 then
        local char = localPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local newAttachment = Instance.new("Attachment", char.HumanoidRootPart)
            if Attachment1 then Attachment1:Destroy() end
            Attachment1 = newAttachment
            attachmentsMode = "single"
            attachments[1] = { Part = nil, Attachment = Attachment1, mode = "single", targetPlayer = nil }
            return
        end
    end

    -- For multiple attachments, create anchored invisible parts to host attachments in workspace.
    for i = 1, count do
        local part = Instance.new("Part", attachmentsFolder)
        part.Anchored = true
        part.CanCollide = false
        part.Transparency = 1
        part.Size = Vector3.new(1,1,1)
        part.Name = "AttachmentPart_" .. i
        -- place at local player initially
        local pos = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and localPlayer.Character.HumanoidRootPart.Position or Vector3.new(0,10,0)
        part.CFrame = CFrame.new(pos + Vector3.new(0, i * 2, 0))

        local attach = Instance.new("Attachment", part)
        attachments[i] = { Part = part, Attachment = attach, mode = "free", targetPlayer = nil }
    end

    -- ensure we still have Attachment1 as a fallback attached to local player HRP
    if Attachment1 and Attachment1.Parent and Attachment1.Parent:IsDescendantOf(Workspace) then
        -- keep
    else
        local char = localPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            if Attachment1 then Attachment1:Destroy() end
            Attachment1 = Instance.new("Attachment", char.HumanoidRootPart)
        end
    end

    attachmentsMode = "multi"
end

local function deleteExtraAttachments()
    -- destroy attachments folder (which will remove parts/attachments created)
    clearAttachmentsFolder()
    -- create single fallback attachment on player HRP again
    local char = localPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        if Attachment1 then Attachment1:Destroy() end
        Attachment1 = Instance.new("Attachment", char.HumanoidRootPart)
    end
    attachmentsMode = "single"
    clearProcessedParts()
end

-- evenly divide candidateParts into current attachments (round-robin)
local function assignExistingCandidatePartsToAttachments()
    if #attachments <= 1 then return end

    local candidates = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart")
            and not v.Anchored
            and v.Name ~= "Handle"
            and not v:IsDescendantOf(localPlayer.Character)
            and (
                (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
            ) then
            table.insert(candidates, v)
        end
    end

    -- evenly distribute by round-robin
    local idx = 1
    for _, p in ipairs(candidates) do
        if not processedParts[p] then
            processedParts[p] = idx
            -- ensure ForcePart setup is applied
            ForcePart(p)
            idx = idx + 1
            if idx > #attachments then idx = 1 end
        end
    end
end

-- monitors processedParts and removes ones that are "knocked off balance"
local function monitorCollectedParts()
    -- if attachmentsMode is single then nothing special
    spawn(function()
        while blackHoleActive do
            -- check each processed part
            for part, attachIndex in pairs(processedParts) do
                if not part or not part.Parent then
                    processedParts[part] = nil
                else
                    -- if the assigned attachment no longer exists, remove assignment
                    if not attachments[attachIndex] or not attachments[attachIndex].Attachment then
                        processedParts[part] = nil
                    else
                        -- If the part is far away from its attachment for a moment, we treat that as "knocked off"
                        local attachmentPos = attachments[attachIndex] and attachments[attachIndex].Part and attachments[attachIndex].Part.Position or (Attachment1 and Attachment1.WorldPosition)
                        if attachmentPos then
                            local distance = (part.Position - attachmentPos).Magnitude
                            -- threshold interpreted: if > 100 studs considered knocked off; remove assignment
                            if distance > 100 then
                                -- cleanup physics and remove mapping
                                for _, x in next, part:GetChildren() do
                                    if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
                                        or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
                                        or x:IsA("RocketPropulsion") then
                                        x:Destroy()
                                    end
                                end
                                if part:FindFirstChild("Attachment") then part:FindFirstChild("Attachment"):Destroy() end
                                if part:FindFirstChild("AlignPosition") then part:FindFirstChild("AlignPosition"):Destroy() end
                                if part:FindFirstChild("Torque") then part:FindFirstChild("Torque"):Destroy() end
                                part.CanCollide = true
                                processedParts[part] = nil
                            end
                        end
                    end
                end
            end
            wait(0.5)
        end
    end)
end

-- PAA: create attachments equal to current player count (excluding local), map each to a player
local function enablePAA()
    local players = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= localPlayer then
            table.insert(players, p)
        end
    end
    local count = #players
    count = math.max(1, count) -- at least one

    createAttachments(count)
    attachmentsMode = "paa"

    -- assign each attachment to a player one-to-one
    for i, p in ipairs(players) do
        if attachments[i] then
            attachments[i].mode = "player"
            attachments[i].targetPlayer = p
            playerAttachIndex[p.UserId] = i
        end
    end

    -- if fewer attachments than players later, handle in playerAdded
end

-- live update PAA on join/leave
local function onPlayerAddedForPAA(player)
    if attachmentsMode ~= "paa" then return end
    -- create new attachment and assign to new player
    table.insert(attachments, nil) -- placeholder
    local idx = #attachments
    -- create part
    local part = Instance.new("Part", attachmentsFolder)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1,1,1)
    part.Name = "AttachmentPart_PAA_" .. idx
    local pos = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position or Vector3.new(0,10,0)
    part.CFrame = CFrame.new(pos)
    local attach = Instance.new("Attachment", part)
    attachments[idx] = { Part = part, Attachment = attach, mode = "player", targetPlayer = player }
    playerAttachIndex[player.UserId] = idx
end

local function onPlayerRemovingForPAA(player)
    if attachmentsMode ~= "paa" then return end
    local idx = playerAttachIndex[player.UserId]
    if idx and attachments[idx] then
        -- destroy that attachment
        if attachments[idx].Part and attachments[idx].Part.Parent then
            attachments[idx].Part:Destroy()
        end
        attachments[idx] = nil
        playerAttachIndex[player.UserId] = nil
        -- compact attachments table (optional)
        local newList = {}
        for _, v in ipairs(attachments) do
            if v then table.insert(newList, v) end
        end
        attachments = newList
        -- rebuild playerAttachIndex for remaining player attachments
        playerAttachIndex = {}
        for i, v in ipairs(attachments) do
            if v.mode == "player" and v.targetPlayer then
                playerAttachIndex[v.targetPlayer.UserId] = i
            end
        end
    end
end

-- call this every tick to update attachments positions based on mode
local function updateAttachmentsPositions()
    if attachmentsMode == "single" then
        -- keep Attachment1 tracked by whatever loop is already doing
        return
    elseif attachmentsMode == "multi" then
        -- choose unique targets per attachment (prefer different players)
        local players = Players:GetPlayers()
        local validPlayers = {}
        for _, p in ipairs(players) do
            if p ~= localPlayer and (not p:FindFirstChild("Whitelisted") or not p.Whitelisted.Value) then
                table.insert(validPlayers, p)
            end
        end

        if #validPlayers >= #attachments then
            -- assign distinct players to attachments (first n)
            for i = 1, #attachments do
                local p = validPlayers[((i - 1) % #validPlayers) + 1]
                if p and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                    attachments[i].Part.CFrame = CFrame.new(p.Character.HumanoidRootPart.Position)
                end
            end
        else
            -- fewer players than attachments: have attachments orbit around local player or hold position
            local basePos = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and localPlayer.Character.HumanoidRootPart.Position or Vector3.new(0,10,0)
            for i = 1, #attachments do
                local off = Vector3.new( (i * 3) % 7, 0, math.floor(i/2) )
                attachments[i].Part.CFrame = CFrame.new(basePos + off)
            end
        end
    elseif attachmentsMode == "paa" then
        -- attachments assigned to players
        for i, a in ipairs(attachments) do
            if a and a.mode == "player" and a.targetPlayer and a.targetPlayer.Character and a.targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                a.Part.CFrame = CFrame.new(a.targetPlayer.Character.HumanoidRootPart.Position)
            elseif a and a.mode == "player" and a.targetPlayer == nil then
                -- try to find a valid player for it
                -- nothing else to do
            end
        end
    end
end

-- --------------- END attachments helpers ----------------

-- toggleBlackHole modified to respect multiple attachments
local function toggleBlackHole()
    blackHoleActive = toggleState
    if blackHoleActive then
        -- if no attachments created (single fallback), create single on HRP
        local char = localPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local newAttachment = Instance.new("Attachment", char.HumanoidRootPart)
            if Attachment1 then Attachment1:Destroy() end
            Attachment1 = newAttachment
            if #attachments == 0 then
                attachments = { { Part = nil, Attachment = Attachment1, mode = "single", targetPlayer = nil } }
                attachmentsMode = "single"
            end
        end

        anchoredOnce = false
        processWorkspaceParts()
        -- start monitor and updater loops
        monitorCollectedParts()
        spawn(function()
            while blackHoleActive do
                -- if attachmentsMode is single, pick random target like before
                if attachmentsMode == "single" or #attachments == 0 then
                    targetPlayer = getRandomPlayer()
                    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        if Attachment1 then
                            Attachment1.WorldCFrame = CFrame.new(targetPlayer.Character.HumanoidRootPart.Position)
                        end
                    end
                else
                    -- update each attachment position depending on mode
                    updateAttachmentsPositions()
                end
                wait(switchDelay)
            end
        end)
    else
        blackHoleActive = false
        enableLocalPlayerNoclip(false) -- disable noclip
        if unanchorTimerRunning and unanchorCoroutine then
            unanchorTimerRunning = false
            for part, anchored in pairs(initiallyAnchoredParts) do
                if part and part.Parent and anchored == false then
                    part.Anchored = false
                    ForcePart(part)
                end
            end
        end
        clearProcessedParts()
    end
end

local function toggleTargetSelected()
    blackHoleActive = toggleState
    if blackHoleActive then
        local newAttachment = Instance.new("Attachment", localPlayer.Character.HumanoidRootPart)
        if Attachment1 then Attachment1:Destroy() end
        Attachment1 = newAttachment
        anchoredOnce = false
        processWorkspaceParts()
        monitorCollectedParts()
        spawn(function()
            while blackHoleActive do
                local selectedPlayers = getSelectedPlayers()
                if #selectedPlayers > 0 then
                    targetPlayer = selectedPlayers[math.random(1, #selectedPlayers)]
                else
                    targetPlayer = nil
                end
                if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    Attachment1.WorldCFrame = CFrame.new(targetPlayer.Character.HumanoidRootPart.Position)
                end
                wait(switchDelay)
            end
        end)
    else
        blackHoleActive = false
        enableLocalPlayerNoclip(false) -- disable noclip
        if unanchorTimerRunning and unanchorCoroutine then
            unanchorTimerRunning = false
            for part, anchored in pairs(initiallyAnchoredParts) do
                if part and part.Parent and anchored == false then
                    part.Anchored = false
                    ForcePart(part)
                end
            end
        end
        clearProcessedParts()
    end
end

local function onCharacterAdded(character)
    if blackHoleActive then
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        local newAttachment = Instance.new("Attachment", humanoidRootPart)
        if Attachment1 then Attachment1:Destroy() end
        Attachment1 = newAttachment
        processedParts = {}
        processWorkspaceParts()
    end
end

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/miroeramaa/TurtleLib/main/TurtleUiLib.lua"))()
local window = library:Window("made by ÆS productions")

window:Toggle("Unanchored Target All", false, function(Value)
    toggleState = Value
    blackHoleActive = Value
    toggleBlackHole()
end)

window:Toggle("Target Selected Players", false, function(Value)
    toggleState = Value
    blackHoleActive = Value
    toggleTargetSelected()
end)

window:Button("Load Player List Script", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/Udklol/refs/heads/main/Playerlistv6"))()
end)

window:Button("telekinesis/fix target", function()
    loadstring(game:HttpGet(('https://raw.githubusercontent.com/SAZXHUB/Control-update/main/README.md'), true))()
end)

-- Removed Continuous Loop Check toggle: scanning is now integrated into the
-- anchor/unanchor routine to avoid repeated global scans while active.

-- --------------- NEW: Enable commands toggle and command handling ----------------
local commandEnabled = false

local function handleCommand(msg)
    if not msg then return end
    -- attachments number
    local attNum = msg:match("^/e%s+attachments%s+(%d+)")
    if attNum then
        local n = tonumber(attNum)
        if n and n >= 1 then
            createAttachments(n)
            assignExistingCandidatePartsToAttachments()
            return
        end
    end

    -- deleteattachments
    if msg:match("^/e%s+deleteattachments") then
        deleteExtraAttachments()
        return
    end

    -- PAA
    if msg:match("^/e%s+PAA") then
        enablePAA()
        -- wire player added/removed hooks for PAA live updates
        Players.PlayerAdded:Connect(function(pl)
            onPlayerAddedForPAA(pl)
        end)
        Players.PlayerRemoving:Connect(function(pl)
            onPlayerRemovingForPAA(pl)
        end)
        return
    end
end

window:Toggle("Enable commands", false, function(Value)
    commandEnabled = Value
    if commandEnabled then
        -- connect local chat listening
        if commandConnection then commandConnection:Disconnect() end
        commandConnection = localPlayer.Chatted:Connect(function(msg)
            -- we only react to /e commands
            if msg:sub(1,3) == "/e " then
                handleCommand(msg)
            end
        end)
    else
        if commandConnection then
            commandConnection:Disconnect()
            commandConnection = nil
        end
    end
end)
-- --------------- END commands integration ----------------

local function onPlayerAddedNoop() end -- placeholders won't duplicate
Players.PlayerAdded:Connect(onPlayerAddedNoop)

local function onPlayerRemovingNoop() end
Players.PlayerRemoving:Connect(onPlayerRemovingNoop)

local function onCharacterAddedLocal(char)
    onCharacterAdded(char)
end
localPlayer.CharacterAdded:Connect(onCharacterAddedLocal)

-- heartbeat update for attachments positions (ensures attachments follow in real-time)
RunService.Heartbeat:Connect(function()
    if blackHoleActive then
        updateAttachmentsPositions()
    end
end)
