-- Full updated script (client) - Improved Goodbye & Nuclear Bomb
-- Changes vs prior:
--  1) Nuke restores Workspace.Gravity back to original value after 3s (guaranteed).
--  2) When detonating (nuke) or when Goodbye BHs "collide", BH parts are destroyed first and
--     part velocities are applied only after a 0.1s delay.
--  3) Pressing "nuclear bomb." now starts gathering IMMEDIATELY. The red "kim ung yong" button triggers explosion.
--  4) Mass-lag protections (caps & batching) added for both flows to avoid crashing the game.
--  5) Re-added skidding for target all/selected (kept original skid logic).
--  6) Kept all original toggles & behavior; added minimal UI and safe guards.

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local localPlayer = Players.LocalPlayer

-- Prevent automatic removal of fallen parts
pcall(function() Workspace.FallenPartsDestroyHeight = 0/0 end) -- NaN

-- ---------- UTILITY & CONFIG ----------
local function clamp(val, a, b)
    if val < a then return a end
    if val > b then return b end
    return val
end

-- Performance / safety caps (tweakable)
local MAX_GATHER_PARTS = 200       -- maximum number of parts to gather for nuke/goodbye to avoid mass lag
local BATCH_SIZE = 25              -- process parts in batches of this size, then yield
local SPLIT_IF_FEWER_THAN = 80     -- split each part into pieces only if total parts gathered less than this

-- ====== CONFIG / STATE ======
local targetAllActive = false
local targetSelectedActive = false
local primaryLoopRunning = false

local switchDelay = 0.13
local processedParts = {}              -- ephemeral processing set used throughout runtime
local processedPartsPersistent = {}    -- parts that must remain detected (persisted once picked up)
local persistentConns = {}             -- connections for persisted parts to reapply ForcePart
local initiallyAnchoredParts = {}
local initiallyMasslessParts = {} -- store original Massless state to restore later
local anchoredOnce = false
local unanchorTimerRunning = false
local unanchorCoroutine

local Attachment1 = nil

local extraBlackHoles = {}

-- PAA state
local PAAEnabled = false
local PAA_isUsingSelected = false
local paaConnections = {}

-- Rebalancer
local rebalancerRunning = false
local rebalancerFreq = 0.10
local alignResponsiveness_base = 1500

-- BH motion
local BH_SWAP_INTERVAL = 0.01
local BH_OSC_FREQUENCY = 1 / (BH_SWAP_INTERVAL * 2)
local BH_AMPLITUDE_FACTOR = 0.22
local BH_MIN_AMPLITUDE = 0.6
local BH_MAX_AMPLITUDE = 80
local TARGET_SMOOTHNESS = 6.0

local ROTATE_INTERVAL = 0.2

local LifeCycleMode = false
local cycleActive = false
local cyclePlayers = {}
local cycleDead = {}
local cycleConns = {}
local cycleRestartPending = false

-- USER-REQUESTED VALUES (extreme)
local fallenpartsdestroyheight = 0/0 -- NaN

local BASE_FLING_AXIS = 1e6
local BASE_PULL_FORCE = 1e8
local BASE_PULL_RESP  = 1e6

-- default (positive) multiplier; Negative fling toggle will flip sign at runtime
local FLING_MULTIPLIER = 9000000000000000      -- 9e15
local PULL_MULTIPLIER  = 1000000000000000000  -- 1e21

local FLING_TORQUE = Vector3.new(BASE_FLING_AXIS * FLING_MULTIPLIER,
                                BASE_FLING_AXIS * FLING_MULTIPLIER,
                                BASE_FLING_AXIS * FLING_MULTIPLIER) -- computed/updated at runtime

local function updateFlingTorque()
    FLING_TORQUE = Vector3.new(BASE_FLING_AXIS * FLING_MULTIPLIER,
                               BASE_FLING_AXIS * FLING_MULTIPLIER,
                               BASE_FLING_AXIS * FLING_MULTIPLIER)
end
updateFlingTorque()

local PULL_MAX_FORCE = BASE_PULL_FORCE * PULL_MULTIPLIER -- 1e20
local PULL_RESPONSIVENESS = BASE_PULL_RESP * PULL_MULTIPLIER -- 1e18

local MASSLESS_TORQUE_SCALE = 1.0
local MASSLESS_PULL_SCALE  = 1.0
local MASSLESS_RESP_SCALE  = 1.2

-- AGGRESSIVE SKID SETTINGS
local SKID_SMOOTHNESS = 40.0

-- Prediction helpers (velocity history)
local playerLastVel = {}
local playerLastVelTime = {}

-- New toggles' state
local InstaVoid = false
local NegativeFling = false

-- Setup folder & primary attachment
local function setupPlayer()
    local Folder = Workspace:FindFirstChild("ÆS_BlackHole_Folder")
    if not Folder then
        Folder = Instance.new("Folder", Workspace)
        Folder.Name = "ÆS_BlackHole_Folder"
    end
    local existing = Folder:FindFirstChild("BH_Center_Part")
    if existing and existing:IsA("BasePart") then
        local att = existing:FindFirstChildOfClass("Attachment")
        if att then return att end
        local newAtt = Instance.new("Attachment", existing)
        return newAtt
    end
    local Part = Instance.new("Part", Folder)
    Part.Name = "BH_Center_Part"
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1
    Part.Size = Vector3.new(1,1,1)
    local Attachment = Instance.new("Attachment", Part)
    return Attachment
end

Attachment1 = setupPlayer()

-- helpers
local function isNPC(character)
    if not character or not character:IsA("Model") then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and not Players:GetPlayerFromCharacter(character) then return true end
    return false
end

local function isPartPlayerCharacter(part)
    if not part then return false end
    for _, pl in ipairs(Players:GetPlayers()) do
        local char = pl.Character
        if char and part:IsDescendantOf(char) then
            return true
        end
    end
    return false
end

local function stripBodyForces(part)
    for _, x in next, part:GetChildren() do
        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
        or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
        or x:IsA("RocketPropulsion") then
            x:Destroy()
        end
    end
    if part:FindFirstChild("Attachment") then part:FindFirstChild("Attachment"):Destroy() end
    if part:FindFirstChild("AlignPosition") then part:FindFirstChild("AlignPosition"):Destroy() end
    if part:FindFirstChild("Torque") then part:FindFirstChild("Torque"):Destroy() end
end

local function shuffle(t)
    for i = #t, 2, -1 do
        local j = math.random(1, i)
        t[i], t[j] = t[j], t[i]
    end
end

local function smoothLerpCFrame(curCF, targetCF, dt)
    local alpha = 1 - math.exp(-TARGET_SMOOTHNESS * dt)
    if alpha < 0.001 then alpha = 0.001 end
    if alpha > 1 then alpha = 1 end
    return curCF:Lerp(targetCF, alpha)
end

local function isWhitelisted(player)
    if not player then return false end
    local v = player:FindFirstChild("Whitelisted")
    if v and typeof(v.Value) == "boolean" then
        return v.Value
    end
    return false
end

local function isPlayerAlive(player)
    if not player then return false end
    local char = player.Character
    if not char then return false end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    if humanoid.Health and humanoid.Health > 0 then return true end
    return false
end

local function getAllNonLocalPlayers()
    local res = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p and p ~= localPlayer and p.Parent and not isWhitelisted(p) then
            table.insert(res, p)
        end
    end
    return res
end

local function getSelectedPlayers(allowWhitelisted)
    local res = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player and player ~= localPlayer and player.Parent then
            local sel = player:FindFirstChild("Selected")
            if sel and typeof(sel.Value) == "boolean" and sel.Value == true then
                if allowWhitelisted then
                    table.insert(res, player)
                else
                    if not isWhitelisted(player) then table.insert(res, player) end
                end
            end
        end
    end
    return res
end

local function getBHsBySource(source)
    local out = {}
    for _, bh in ipairs(extraBlackHoles) do
        if bh.source == source then table.insert(out, bh) end
    end
    return out
end

local function getLeastLoadedBlackHole()
    if #extraBlackHoles == 0 then return nil end
    table.sort(extraBlackHoles, function(a,b) return (#a.AssignedParts) < (#b.AssignedParts) end)
    return extraBlackHoles[1]
end

-- Predict using velocity + acceleration estimate (deterministic)
local function predictTargetPosition(pl, pos, vel, now)
    local lastV = playerLastVel[pl]
    local lastT = playerLastVelTime[pl]
    local accel = Vector3.new(0,0,0)
    if lastV and lastT and now and now > lastT then
        accel = (vel - lastV) / (now - lastT)
    end
    playerLastVel[pl] = vel
    playerLastVelTime[pl] = now

    local speed = vel.Magnitude
    local leadFactor = clamp(0.25 + (speed * 0.06), 0.25, 1.8)
    local tlead = leadFactor
    local predicted = pos + vel * tlead + 0.5 * accel * (tlead * tlead)
    return predicted, leadFactor, accel
end

-- Persistent watch helper: ensure when a picked-up part is reparented/moved we keep it processed
local function ensurePersistentWatch(part)
    if not part or not part.Parent then return end
    if persistentConns[part] then return end
    local conn
    conn = part.AncestryChanged:Connect(function()
        -- if part exists and is not currently processed (maybe removed), reapply ForcePart
        if part and part.Parent then
            -- reapply massless + ForcePart if needed
            pcall(function() part.Massless = true end)
            ForcePart(part)
        end
    end)
    persistentConns[part] = conn
end

-- ForcePart (also massless handling)
function ForcePart(v)
    if not v or not v:IsA("BasePart") then return end
    if isPartPlayerCharacter(v) then return end
    if localPlayer.Character and v:IsDescendantOf(localPlayer.Character) then return end

    if v:IsA("BasePart")
        and not v.Anchored
        and v.Name ~= "Handle"
        and (
            (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
            or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
        ) then

        -- IMPORTANT: Only pick up parts that are closer to local player than any other player
        local okToPick = false
        local lpHRP = (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) and localPlayer.Character.HumanoidRootPart
        if lpHRP then
            local localDist = (v.Position - lpHRP.Position).Magnitude
            okToPick = true
            for _, other in ipairs(Players:GetPlayers()) do
                if other ~= localPlayer and other.Parent and not isWhitelisted(other) then
                    local othChar = other.Character
                    if othChar and othChar:FindFirstChild("HumanoidRootPart") then
                        local otherDist = (v.Position - othChar.HumanoidRootPart.Position).Magnitude
                        -- if any other player is strictly closer, skip this part
                        if otherDist < localDist then
                            okToPick = false
                            break
                        end
                    end
                end
            end
        else
            -- if local HRP not ready, avoid picking up
            okToPick = false
        end

        if not okToPick then return end

        if processedParts[v] then
            -- already processed; ensure persistent tracking
            processedPartsPersistent[v] = true
            ensurePersistentWatch(v)
            return
        end

        processedParts[v] = true
        processedPartsPersistent[v] = true
        ensurePersistentWatch(v)

        if initiallyMasslessParts[v] == nil then
            pcall(function() initiallyMasslessParts[v] = v.Massless end)
        end

        pcall(function() v.Massless = true end)

        stripBodyForces(v)
        v.CanCollide = false

        local torqueVal = FLING_TORQUE
        local ok, isMass = pcall(function() return v.Massless end)
        if ok and isMass == true then
            torqueVal = torqueVal * MASSLESS_TORQUE_SCALE
        end
        local Torque = Instance.new("Torque", v)
        Torque.Torque = torqueVal

        local AlignPosition = Instance.new("AlignPosition", v)
        local Attachment2 = Instance.new("Attachment", v)
        pcall(function() Attachment2.WorldCFrame = v.CFrame end)
        Torque.Attachment0 = Attachment2

        local maxF = PULL_MAX_FORCE
        local resp  = PULL_RESPONSIVENESS
        if ok and isMass == true then
            maxF = maxF * MASSLESS_PULL_SCALE
            resp  = resp * MASSLESS_RESP_SCALE
        end

        AlignPosition.MaxForce = maxF
        AlignPosition.MaxVelocity = math.huge
        AlignPosition.Responsiveness = resp
        AlignPosition.Attachment0 = Attachment2

        local bh = getLeastLoadedBlackHole()
        if bh and bh.Attachment and bh._active then
            AlignPosition.Attachment1 = bh.Attachment
            table.insert(bh.AssignedParts, v)
        else
            AlignPosition.Attachment1 = Attachment1
        end
    end
end

local function clearProcessedParts()
    -- Disconnect persistent connections
    for part, conn in pairs(persistentConns) do
        pcall(function() conn:Disconnect() end)
    end
    persistentConns = {}

    for part, _ in pairs(processedParts) do
        if part and part.Parent then
            stripBodyForces(part)
            part.CanCollide = true
            if initiallyAnchoredParts[part] == false then
                part.Anchored = false
            elseif initiallyAnchoredParts[part] == true then
                part.Anchored = true
            end

            if initiallyMasslessParts[part] ~= nil then
                local original = initiallyMasslessParts[part]
                pcall(function() part.Massless = original end)
            else
                pcall(function() part.Massless = false end)
            end
        end
    end
    processedParts = {}
    processedPartsPersistent = {}
    initiallyAnchoredParts = {}
    initiallyMasslessParts = {}
    anchoredOnce = false
end

local function anchorAndDelayedUnanchorParts()
    unanchorTimerRunning = true

    local candidateParts = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart")
            and not v.Anchored
            and v.Name ~= "Handle"
            and not isPartPlayerCharacter(v)
            and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character))
            and (
                (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
            ) then

            -- distance check: only pick if closer to local player than any other player
            local lpHRP = (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) and localPlayer.Character.HumanoidRootPart
            local okToConsider = false
            if lpHRP then
                local localDist = (v.Position - lpHRP.Position).Magnitude
                okToConsider = true
                for _, other in ipairs(Players:GetPlayers()) do
                    if other ~= localPlayer and other.Parent and not isWhitelisted(other) then
                        local othChar = other.Character
                        if othChar and othChar:FindFirstChild("HumanoidRootPart") then
                            local otherDist = (v.Position - othChar.HumanoidRootPart.Position).Magnitude
                            if otherDist < localDist then
                                okToConsider = false
                                break
                            end
                        end
                    end
                end
            end

            if okToConsider then
                table.insert(candidateParts, v)
            end
        end
    end

    initiallyAnchoredParts = {}
    for _, part in ipairs(candidateParts) do
        initiallyAnchoredParts[part] = false
        if initiallyMasslessParts[part] == nil then
            pcall(function() initiallyMasslessParts[part] = part.Massless end)
        end
        pcall(function() part.Massless = true end)

        part.Anchored = true
        part.CanCollide = false
    end

    for _, npcCandidate in ipairs(Workspace:GetChildren()) do
        if isNPC(npcCandidate) then
            for _, p in ipairs(npcCandidate:GetDescendants()) do
                if p:IsA("BasePart") then p.CanCollide = true end
            end
        end
    end

    local startTime = tick()
    while (targetAllActive or targetSelectedActive) and tick() - startTime < 1 do
        wait(0.05)
    end

    for _, part in ipairs(candidateParts) do
        if part and part.Parent and initiallyAnchoredParts[part] == false then
            part.Anchored = false
            pcall(function()
                if not isPartPlayerCharacter(part) and not (localPlayer.Character and part:IsDescendantOf(localPlayer.Character)) then
                    initiallyMasslessParts[part] = initiallyMasslessParts[part] or part.Massless
                    part.Massless = true
                end
            end)
            ForcePart(part)
        end
    end

    unanchorTimerRunning = false
    anchoredOnce = true
end

local descendantAddedConn
local function processWorkspaceParts()
    if descendantAddedConn then
        descendantAddedConn:Disconnect()
        descendantAddedConn = nil
    end

    if (targetAllActive or targetSelectedActive) then
        if not unanchorTimerRunning and not anchoredOnce then
            unanchorCoroutine = coroutine.create(anchorAndDelayedUnanchorParts)
            coroutine.resume(unanchorCoroutine)
        end

        descendantAddedConn = Workspace.DescendantAdded:Connect(function(v)
            if (targetAllActive or targetSelectedActive) then
                if v:IsA("BasePart")
                    and not v.Anchored
                    and not processedParts[v]
                    and not isPartPlayerCharacter(v)
                    and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then

                    -- distance check for newly added parts
                    local lpHRP = (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) and localPlayer.Character.HumanoidRootPart
                    local okToConsider = false
                    if lpHRP then
                        local localDist = (v.Position - lpHRP.Position).Magnitude
                        okToConsider = true
                        for _, other in ipairs(Players:GetPlayers()) do
                            if other ~= localPlayer and other.Parent and not isWhitelisted(other) then
                                local othChar = other.Character
                                if othChar and othChar:FindFirstChild("HumanoidRootPart") then
                                    local otherDist = (v.Position - othChar.HumanoidRootPart.Position).Magnitude
                                    if otherDist < localDist then
                                        okToConsider = false
                                        break
                                    end
                                end
                            end
                        end
                    end

                    if okToConsider then
                        if initiallyMasslessParts[v] == nil then
                            pcall(function() initiallyMasslessParts[v] = v.Massless end)
                        end
                        pcall(function() v.Massless = true end)
                        ForcePart(v)
                    end
                end
            end
        end)
    end
end

local function getRandomPlayer()
    local players = getAllNonLocalPlayers()
    if #players == 0 then return nil end
    return players[math.random(1, #players)]
end

-- set BH active/inactive
local function setBlackHoleActiveState(bh, active)
    if not bh then return end
    if bh._active == active then return end
    bh._active = active
    if not active then
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                p.CanCollide = true
                local ap = p:FindFirstChildOfClass("AlignPosition")
                if ap then
                    ap.Attachment1 = Attachment1
                    pcall(function()
                        local isMass = (pcall(function() return p.Massless end) and p.Massless)
                        ap.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                        ap.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                    end)
                end
            end
        end
    else
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                local ap = p:FindFirstChildOfClass("AlignPosition")
                if ap then ap.Attachment1 = bh.Attachment; p.CanCollide = false end
            end
        end
    end
end

-- create extra BH helper
local function createExtraBlackHole(initialTarget, source)
    if initialTarget == localPlayer then initialTarget = nil end
    if initialTarget and isWhitelisted(initialTarget) and source ~= "CMD_ALLOW_WHITELISTED" then
        initialTarget = nil
    end

    local folder = Workspace:FindFirstChild("ÆS_BlackHole_Folder") or Instance.new("Folder", Workspace)
    folder.Name = "ÆS_BlackHole_Folder"
    local part = Instance.new("Part", folder)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1,1,1)
    part.Name = "ExtraBH_Center"

    local att = Instance.new("Attachment", part)

    local bh = {
        Part = part,
        Attachment = att,
        AssignedParts = {},
        TargetPlayer = initialTarget,
        LastTarget = nil,
        _running = true,
        _active = true,
        source = source or "CMD",
        rotating = false,
        smoothedCF = part.CFrame
    }

    local function isPlayerDisabled(pl)
        if not pl then return false end
        if pl:FindFirstChild("Disabled") and typeof(pl.Disabled.Value) == "boolean" then
            return pl.Disabled.Value
        end
        return false
    end

    -- BH behavior thread (AGGRESSIVE straight-line skidding)
    bh._thread = spawn(function()
        local t = 0
        while bh._running do
            local dt = RunService.Heartbeat:Wait()
            t = t + dt

            if bh.TargetPlayer and bh.TargetPlayer ~= localPlayer and not isWhitelisted(bh.TargetPlayer) and isPlayerAlive(bh.TargetPlayer) then
                if isPlayerDisabled(bh.TargetPlayer) then
                    setBlackHoleActiveState(bh, false)
                else
                    setBlackHoleActiveState(bh, true)

                    local char = bh.TargetPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        local hrp = char.HumanoidRootPart
                        local pos = hrp.Position
                        local vel = hrp.Velocity or Vector3.new(0,0,0)
                        local now = tick()

                        -- precise deterministic prediction
                        local predictedPos, leadFactor, accel = predictTargetPosition(bh.TargetPlayer, pos, vel, now)
                        local speed = vel.Magnitude

                        -- Compute straight-line skid endpoints:
                        local dir
                        if speed > 0.001 then
                            dir = vel.Unit
                        else
                            dir = hrp.CFrame.LookVector
                        end

                        -- EXACT half-length = speed
                        local halfLen = speed
                        if halfLen < 0.5 then halfLen = 0.5 end

                        -- Frequency scale: faster players => higher frequency
                        local baseFreq = InstaVoid and 30.0 or 8.0
                        local freq = baseFreq + (speed * 3.0)
                        if freq < 6 then freq = 6 end

                        -- phase and oscillation: deterministic sinusoid along dir
                        local phase = t * (2 * math.pi * freq)
                        local s = math.sin(phase) -- in [-1,1]

                        -- offset along movement direction: range [-halfLen, +halfLen], total length = 2*halfLen (=2*speed)
                        local offset = dir * (s * halfLen)

                        -- If InstaVoid is enabled, place the skid centered 2 studs above HRP (rapid)
                        local desiredPos
                        if InstaVoid then
                            local above = hrp.Position + Vector3.new(0, 2, 0)
                            desiredPos = above + offset
                        else
                            desiredPos = predictedPos + offset
                        end

                        -- Build a CFrame that keeps BH oriented toward the player's future heading (keeps consistent)
                        local lookAt = (InstaVoid and (hrp.Position + dir) or (predictedPos + dir))
                        local targetCF = CFrame.new(desiredPos, lookAt)

                        -- AGGRESSIVE smoothing scaled by speed
                        local effectiveSmooth = SKID_SMOOTHNESS * (1 + speed * 0.8)
                        if effectiveSmooth < 1.0 then effectiveSmooth = 1.0 end

                        local skidAlpha = 1 - math.exp(-effectiveSmooth * dt)
                        if skidAlpha < 0.01 then skidAlpha = 0.01 end
                        if skidAlpha > 0.999 then skidAlpha = 0.999 end

                        local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                        local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame

                        -- Very aggressive lerp toward targetCF (straight line skid)
                        bh.smoothedCF = curCF:Lerp(targetCF, skidAlpha)

                        if bh.Attachment then
                            pcall(function() bh.Attachment.WorldCFrame = bh.smoothedCF end)
                        end
                    end
                end
            else
                -- No valid targets: idle deterministic behaviour near Attachment1
                local hasValidTargets = false
                for _, pl in ipairs(Players:GetPlayers()) do
                    if pl ~= localPlayer and pl.Parent and not isWhitelisted(pl) and isPlayerAlive(pl) then
                        hasValidTargets = true
                        break
                    end
                end

                if not hasValidTargets then
                    setBlackHoleActiveState(bh, false)
                    if Attachment1 and Attachment1.Parent and bh.Attachment then
                        local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                        local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame
                        local centerCF
                        pcall(function() centerCF = Attachment1.WorldCFrame end)
                        if centerCF then
                            local targetCF = centerCF -- deterministic idle (no randomness)
                            local idleAlpha = 1 - math.exp(- (SKID_SMOOTHNESS * 1.2) * dt)
                            if idleAlpha < 0.01 then idleAlpha = 0.01 end
                            if idleAlpha > 0.99 then idleAlpha = 0.99 end
                            bh.smoothedCF = curCF:Lerp(targetCF, idleAlpha)
                            pcall(function() bh.Attachment.WorldCFrame = bh.smoothedCF end)
                        end
                    end
                    wait(0.06)
                else
                    if bh.Attachment then
                        local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                        local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame
                        local idleAlpha = 1 - math.exp(- (SKID_SMOOTHNESS * 0.6) * dt)
                        if idleAlpha < 0.01 then idleAlpha = 0.01 end
                        if idleAlpha > 0.85 then idleAlpha = 0.85 end
                        bh.smoothedCF = curCF:Lerp(curCF, idleAlpha)
                        pcall(function() bh.Attachment.WorldCFrame = bh.smoothedCF end)
                    end
                end
            end
        end
    end)

    table.insert(extraBlackHoles, bh)
    return bh
end

local function destroyExtraBlackHole(bh)
    if not bh then return end
    bh._running = false
    if bh.Part and bh.Part.Parent then bh.Part:Destroy() end
    for _, p in ipairs(bh.AssignedParts) do
        if p and p.Parent then
            local ap = p:FindFirstChildOfClass("AlignPosition")
            if ap then ap.Attachment1 = Attachment1 end
            p.CanCollide = false
            if initiallyMasslessParts[p] ~= nil then
                pcall(function() p.Massless = initiallyMasslessParts[p] end)
            else
                pcall(function() p.Massless = false end)
            end
        end
    end
end

local function deleteBHsBySource(source)
    for i = #extraBlackHoles, 1, -1 do
        local bh = extraBlackHoles[i]
        if bh and bh.source == source then
            destroyExtraBlackHole(bh)
            table.remove(extraBlackHoles, i)
        end
    end
end

local function deleteAllExtraBlackHoles()
    for _, bh in ipairs(extraBlackHoles) do destroyExtraBlackHole(bh) end
    extraBlackHoles = {}
    if not Attachment1 or not Attachment1.Parent then Attachment1 = setupPlayer() end
    stopRebalancer()
end

-- rotating/distribution code unchanged (keeps deterministic assignment)
local rotatingCoroutine = nil
local rotatingActive = false
local function stopRotatingCoroutine()
    rotatingActive = false
    rotatingCoroutine = nil
end

local function distributeBHListEvenly(bhList, players)
    for _, bh in ipairs(bhList) do
        bh.rotating = false
        bh.TargetPlayer = nil
        bh.AssignedParts = {}
    end

    if #players == 0 then
        for _, bh in ipairs(bhList) do
            bh.TargetPlayer = nil
            setBlackHoleActiveState(bh, false)
        end
        stopRotatingCoroutine()
        return
    end

    local totalBH = #bhList
    local playerCount = #players
    local base = math.floor(totalBH / playerCount)
    local remainder = totalBH - (base * playerCount)

    local idx = 1
    for pi = 1, playerCount do
        local pl = players[pi]
        for k = 1, base do
            if bhList[idx] then
                bhList[idx].TargetPlayer = pl
                bhList[idx].rotating = false
                setBlackHoleActiveState(bhList[idx], true)
                if pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
                    pcall(function() bhList[idx].Attachment.WorldCFrame = pl.Character.HumanoidRootPart.CFrame end)
                end
                idx = idx + 1
            end
        end
    end

    local rotatingBHs = {}
    for r = 1, remainder do
        if bhList[idx] then
            bhList[idx].rotating = true
            bhList[idx].TargetPlayer = nil
            setBlackHoleActiveState(bhList[idx], true)
            table.insert(rotatingBHs, bhList[idx])
            idx = idx + 1
        end
    end

    stopRotatingCoroutine()
    if #rotatingBHs == 0 then return end

    rotatingActive = true
    rotatingCoroutine = spawn(function()
        local posIndex = 1
        while rotatingActive do
            local curPlayers = {}
            for _, pl in ipairs(players) do
                if pl and pl.Parent and isPlayerAlive(pl) and not isWhitelisted(pl) and pl ~= localPlayer then
                    table.insert(curPlayers, pl)
                end
            end
            if #curPlayers == 0 then
                for _, rb in ipairs(rotatingBHs) do
                    rb.TargetPlayer = nil
                    setBlackHoleActiveState(rb, false)
                end
                break
            end

            for _, rb in ipairs(rotatingBHs) do
                local pick = curPlayers[((posIndex - 1) % #curPlayers) + 1]
                if pick and not isWhitelisted(pick) and pick ~= localPlayer and isPlayerAlive(pick) then
                    rb.TargetPlayer = pick
                    setBlackHoleActiveState(rb, true)
                    if pick.Character and pick.Character:FindFirstChild("HumanoidRootPart") and rb.Attachment then
                        pcall(function() rb.Attachment.WorldCFrame = pick.Character.HumanoidRootPart.CFrame end)
                    end
                else
                    rb.TargetPlayer = nil
                    setBlackHoleActiveState(rb, false)
                end
                posIndex = posIndex + 1
            end

            wait(ROTATE_INTERVAL)
        end
    end)
end

-- PAA/CMD assignment wrappers unchanged
local function assignTargetsForPAA()
    local paaBHs = getBHsBySource("PAA")
    if #paaBHs == 0 then return end

    local players = {}
    if LifeCycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(players, pl)
            end
        end
    else
        if PAA_isUsingSelected then
            players = getSelectedPlayers(true)
        else
            players = getAllNonLocalPlayers()
        end
    end

    shuffle(paaBHs)
    distributeBHListEvenly(paaBHs, players)
end

local function assignTargetsForCMD()
    local cmdBHs = getBHsBySource("CMD")
    if #cmdBHs == 0 then return end

    local players = {}
    if LifeCycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(players, pl)
            end
        end
    else
        players = getAllNonLocalPlayers()
    end

    shuffle(cmdBHs)
    distributeBHListEvenly(cmdBHs, players)
end

local function createNCommandBlackHoles(n)
    if n <= 0 then return end
    for i = 1, n do createExtraBlackHole(nil, "CMD") end
    assignTargetsForCMD()
    if PAAEnabled then assignTargetsForPAA() end
    if #extraBlackHoles > 0 then startRebalancer() end
end

local function deleteCommandBlackHoles()
    deleteBHsBySource("CMD")
    stopRotatingCoroutine()
end

local function refreshPAA()
    deleteBHsBySource("PAA")
    local targets = {}
    if LifeCycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(targets, pl)
            end
        end
    else
        if PAA_isUsingSelected then
            targets = getSelectedPlayers(true)
        else
            targets = getAllNonLocalPlayers()
        end
    end

    for _, tgt in ipairs(targets) do
        if tgt and tgt ~= localPlayer and not isWhitelisted(tgt) then
            local bh = createExtraBlackHole(tgt, "PAA")
            bh.TargetPlayer = tgt
            bh.LastTarget = nil
            setBlackHoleActiveState(bh, true)
            if tgt.Character and tgt.Character:FindFirstChild("HumanoidRootPart") and bh.Attachment then
                pcall(function() bh.Attachment.WorldCFrame = tgt.Character.HumanoidRootPart.CFrame end)
            end
        end
    end

    assignTargetsForPAA()
    if #extraBlackHoles > 0 then startRebalancer() end
end

local function onPlayerAddedForPAA(pl)
    if PAAEnabled and not PAA_isUsingSelected and pl ~= localPlayer and not isWhitelisted(pl) then
        if LifeCycleMode and cycleActive then
            return
        end
        local bh = createExtraBlackHole(pl, "PAA")
        bh.TargetPlayer = pl
        bh.LastTarget = nil
        assignTargetsForPAA()
    end
end

local function onPlayerRemovingForPAA(pl)
    if PAAEnabled then
        for i = #extraBlackHoles, 1, -1 do
            local bh = extraBlackHoles[i]
            if bh and bh.source == "PAA" and bh.TargetPlayer == pl then
                destroyExtraBlackHole(bh)
                table.remove(extraBlackHoles, i)
                break
            end
        end
        assignTargetsForPAA()
    end
end

-- LifeCycle / rebalancer and other management functions (unchanged)
local function clearCycleConnections()
    for _, conn in ipairs(cycleConns) do
        if conn and conn.Disconnect then
            pcall(function() conn:Disconnect() end)
        end
    end
    cycleConns = {}
end

local function stopCycle()
    cycleActive = false
    cyclePlayers = {}
    cycleDead = {}
    clearCycleConnections()
    cycleRestartPending = false
end

local function checkCycleCompletionAndMaybeRestart()
    if not cycleActive then return end
    if #cyclePlayers == 0 then
        cycleRestartPending = true
        return
    end
    for _, pl in ipairs(cyclePlayers) do
        if not cycleDead[pl] then
            return
        end
    end
    cycleRestartPending = true
end

local function scheduleCycleRestart()
    if cycleRestartPending then
        cycleRestartPending = false
        spawn(function()
            wait(0.12)
            local newSnapshot = {}
            if targetSelectedActive then
                newSnapshot = getSelectedPlayers(false)
            else
                newSnapshot = getAllNonLocalPlayers()
            end
            cyclePlayers = {}
            cycleDead = {}
            for _, pl in ipairs(newSnapshot) do
                if pl and pl.Parent and pl ~= localPlayer then
                    cyclePlayers[#cyclePlayers+1] = pl
                    cycleDead[pl] = false
                end
            end
            clearCycleConnections()
            for _, pl in ipairs(cyclePlayers) do
                if pl and pl.Parent then
                    local function onHumanoidAdded(char)
                        local hum = char:FindFirstChildOfClass("Humanoid")
                        if hum then
                            local dconn = hum.Died:Connect(function()
                                cycleDead[pl] = true
                                assignTargetsForPAA()
                                assignTargetsForCMD()
                                checkCycleCompletionAndMaybeRestart()
                            end)
                            table.insert(cycleConns, dconn)
                        end
                    end
                    if pl.Character then
                        onHumanoidAdded(pl.Character)
                    end
                    local cconn = pl.CharacterAdded:Connect(onHumanoidAdded)
                    table.insert(cycleConns, cconn)
                    local rconn = pl.AncestryChanged:Connect(function()
                        if not pl.Parent then
                            for i = #cyclePlayers, 1, -1 do
                                if cyclePlayers[i] == pl then table.remove(cyclePlayers, i) end
                            end
                            cycleDead[pl] = true
                            assignTargetsForPAA()
                            assignTargetsForCMD()
                            checkCycleCompletionAndMaybeRestart()
                        end
                    end)
                    table.insert(cycleConns, rconn)
                end
            end

            assignTargetsForPAA()
            assignTargetsForCMD()
        end)
    end
end

local function startCycleSnapshot()
    stopCycle()
    cycleActive = true
    cyclePlayers = {}
    cycleDead = {}

    local snapshot = {}
    if targetSelectedActive then
        snapshot = getSelectedPlayers(false)
    else
        snapshot = getAllNonLocalPlayers()
    end

    for _, pl in ipairs(snapshot) do
        if pl and pl.Parent and pl ~= localPlayer then
            cyclePlayers[#cyclePlayers+1] = pl
            cycleDead[pl] = false
        end
    end

    clearCycleConnections()
    for _, pl in ipairs(cyclePlayers) do
        if pl and pl.Parent then
            local function attachHumanoidWatcher(char)
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    local dconn = hum.Died:Connect(function()
                        cycleDead[pl] = true
                        assignTargetsForPAA()
                        assignTargetsForCMD()
                        checkCycleCompletionAndMaybeRestart()
                        scheduleCycleRestart()
                    end)
                    table.insert(cycleConns, dconn)
                end
            end
            if pl.Character then attachHumanoidWatcher(pl.Character) end
            local cconn = pl.CharacterAdded:Connect(attachHumanoidWatcher)
            table.insert(cycleConns, cconn)
            local rconn = pl.AncestryChanged:Connect(function()
                if not pl.Parent then
                    for i = #cyclePlayers, 1, -1 do
                        if cyclePlayers[i] == pl then table.remove(cyclePlayers, i) end
                    end
                    cycleDead[pl] = true
                    assignTargetsForPAA()
                    assignTargetsForCMD()
                    checkCycleCompletionAndMaybeRestart()
                    scheduleCycleRestart()
                end
            end)
            table.insert(cycleConns, rconn)
        end
    end

    assignTargetsForPAA()
    assignTargetsForCMD()
end

function startRebalancer()
    if rebalancerRunning then return end
    rebalancerRunning = true
    spawn(function()
        while rebalancerRunning do
            local bhCount = #extraBlackHoles
            local parts = {}
            for p, _ in pairs(processedParts) do
                if p and p.Parent then
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then
                        pcall(function()
                            local isMass = (pcall(function() return p.Massless end) and p.Massless)
                            ap.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                            ap.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                        end)
                        table.insert(parts, p)
                    else
                        -- if AlignPosition missing, reapply ForcePart (this helps keep persisted parts detected)
                        ForcePart(p)
                        local ap2 = p:FindFirstChildOfClass("AlignPosition")
                        if ap2 then
                            pcall(function()
                                local isMass = (pcall(function() return p.Massless end) and p.Massless)
                                ap2.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                                ap2.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                            end)
                            table.insert(parts, p)
                        end
                    end
                else
                    -- If the part lost parent but is a persisted part, try to ForcePart when it reappears (handled by persistent watch)
                end
            end

            if bhCount > 0 and #parts > 0 then
                local total = #parts
                local base = math.floor(total / bhCount)
                local rem = total - (base * bhCount)
                local counts = {}
                for i = 1, bhCount do counts[i] = base + (i <= rem and 1 or 0) end

                local partIndex = 1
                for i = 1, bhCount do
                    local bh = extraBlackHoles[i]
                    local need = counts[i]
                    for c = 1, need do
                        local p = parts[partIndex]
                        if not p then break end
                        local ap = p:FindFirstChildOfClass("AlignPosition")
                        if ap then
                            if bh and bh.Attachment and bh._active then
                                ap.Attachment1 = bh.Attachment
                                p.CanCollide = false
                                table.insert(bh.AssignedParts, p)
                            else
                                ap.Attachment1 = Attachment1
                                p.CanCollide = false
                            end
                        end
                        partIndex = partIndex + 1
                    end
                end
            else
                for _, p in ipairs(parts) do
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then ap.Attachment1 = Attachment1; p.CanCollide = false end
                end
            end

            if PAAEnabled then assignTargetsForPAA() end
            assignTargetsForCMD()

            if cycleRestartPending then
                scheduleCycleRestart()
            end

            wait(rebalancerFreq)
        end
    end)
end

function stopRebalancer() rebalancerRunning = false end

-- Commands (chat)
local enableCommands = true
local function onLocalPlayerChatted(msg)
    if not enableCommands then return end
    if not msg then return end
    local raw = msg
    msg = msg:lower()

    local bhArg = string.match(msg, "^/e%s+blackholes%s+(%d+)")
    if bhArg then
        local n = tonumber(bhArg)
        if n and n > 0 then createNCommandBlackHoles(n) end
        return
    end

    if string.match(msg, "^/e%s+dbh") then
        deleteCommandBlackHoles()
        return
    end

    if string.match(msg, "^/e%s+paa") then
        PAAEnabled = true
        PAA_isUsingSelected = false
        refreshPAA()
        paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
        paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
        return
    end

    if string.match(msg, "^/e%s+unpaa") then
        PAAEnabled = false
        for _, c in ipairs(paaConnections) do pcall(function() c:Disconnect() end) end
        paaConnections = {}
        deleteBHsBySource("PAA")
        return
    end

    if string.match(msg, "^/e%s+psel") then
        PAAEnabled = true
        PAA_isUsingSelected = true
        refreshPAA()
        return
    end
end

localPlayer.Chatted:Connect(onLocalPlayerChatted)

-- Primary loop
local function startPrimaryLoop()
    if primaryLoopRunning then return end
    primaryLoopRunning = true
    if not Attachment1 or not Attachment1.Parent then Attachment1 = setupPlayer() end
    anchoredOnce = false
    processWorkspaceParts()

    spawn(function()
        local phaseT = 0
        local lastHeartbeat = tick()
        while targetAllActive or targetSelectedActive do
            local now = tick()
            local dt = now - lastHeartbeat
            lastHeartbeat = now
            phaseT = phaseT + dt

            if targetSelectedActive then
                local selectedPlayers = getSelectedPlayers(true)
                if #selectedPlayers > 0 then
                    targetPlayer = selectedPlayers[math.random(1, #selectedPlayers)]
                else
                    targetPlayer = nil
                end
            elseif targetAllActive then
                targetPlayer = getRandomPlayer()
            else
                targetPlayer = nil
            end

            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and isPlayerAlive(targetPlayer) then
                local hrp = targetPlayer.Character.HumanoidRootPart
                local vel = hrp.Velocity or Vector3.new(0,0,0)
                local speed = vel.Magnitude
                local dir = (speed > 0.5) and vel.Unit or hrp.CFrame.LookVector
                local amplitude = clamp(speed * BH_AMPLITUDE_FACTOR, BH_MIN_AMPLITUDE, BH_MAX_AMPLITUDE)
                local phase = phaseT * (2 * math.pi * BH_OSC_FREQUENCY)
                local primaryOffset = dir * (math.sin(phase) * amplitude)
                local lateral = hrp.CFrame.RightVector * (math.sin(phase * 1.27) * amplitude * 0.35)
                local vertical = hrp.CFrame.UpVector * (math.sin(phase * 1.0) * amplitude * 0.5)
                local targetCFrame = hrp.CFrame * CFrame.new(primaryOffset + lateral + vertical)
                if Attachment1 then
                    local success, cur = pcall(function() return Attachment1.WorldCFrame end)
                    local curCF = success and cur or Attachment1.WorldCFrame or hrp.CFrame
                    Attachment1.WorldCFrame = smoothLerpCFrame(curCF, targetCFrame, dt)
                end
            end

            wait(switchDelay)
        end

        primaryLoopRunning = false
        if unanchorTimerRunning and unanchorCoroutine then
            unanchorTimerRunning = false
            for part, anchored in pairs(initiallyAnchoredParts) do
                if part and part.Parent and anchored == false then
                    part.Anchored = false
                    ForcePart(part)
                end
            end
        end
        clearProcessedParts()

        if PAAEnabled then deleteBHsBySource("PAA") end
    end)
end

local function setTargetAll(value)
    targetAllActive = value
    if (targetAllActive or targetSelectedActive) then startPrimaryLoop() end

    if LifeCycleMode then
        if targetAllActive then
            tryStartCycleIfNeeded()
        else
            stopCycle()
        end
    end

    if PAAEnabled then
        if targetAllActive then
            PAA_isUsingSelected = false
            refreshPAA()
            if #paaConnections == 0 then
                paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
                paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
            end
        else
            deleteBHsBySource("PAA")
        end
    end
end

local function setTargetSelected(value)
    targetSelectedActive = value
    if (targetAllActive or targetSelectedActive) then startPrimaryLoop() end

    if LifeCycleMode then
        if targetSelectedActive then
            tryStartCycleIfNeeded()
        else
            stopCycle()
        end
    end

    if PAAEnabled then
        if targetSelectedActive then
            PAA_isUsingSelected = true
            refreshPAA()
            if #paaConnections == 0 then
                paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
                paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
            end
        else
            deleteBHsBySource("PAA")
        end
    end
end

local function onCharacterAdded(character)
    if (targetAllActive or targetSelectedActive) then
        processedParts = {}
        processWorkspaceParts()
    end
end

Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

-- ---------- NEW FEATURES: Goodbye & Nuclear bomb (improved) ----------

-- Helper: splitPartIntoPieces (limited & safe)
local function splitPartIntoPieces(part, pieces)
    pieces = pieces or 3
    local clones = {}
    if not part or not part.Parent then return clones end
    pcall(function()
        -- compute smaller size but ensure minimum extents
        local baseSize = part.Size / math.max(1, pieces^(1/3))
        for i = 1, pieces do
            local c = part:Clone()
            c.Name = part.Name .. "_split_" .. tostring(i)
            c.Size = Vector3.new(math.max(0.2, baseSize.X), math.max(0.2, baseSize.Y), math.max(0.2, baseSize.Z))
            c.CFrame = part.CFrame * CFrame.new((i - 2) * 0.5, math.random(-1,1)*0.3, math.random(-1,1)*0.3)
            c.Parent = part.Parent
            c.Anchored = false
            stripBodyForces(c)
            table.insert(clones, c)
        end
        -- destroy original to simulate splitting
        pcall(function() part:Destroy() end)
    end)
    return clones
end

-- Golden spiral / uniform sphere directions for perfect sphere distribution
local function goldenSphereDirections(n)
    local out = {}
    if n <= 0 then return out end
    if n == 1 then return { Vector3.new(0,1,0) } end
    local phi = math.pi * (3 - math.sqrt(5))
    for i = 0, n-1 do
        local y = 1 - (i / (n - 1)) * 2
        local radius = math.sqrt(math.max(0, 1 - y*y))
        local theta = phi * i
        local x = math.cos(theta) * radius
        local z = math.sin(theta) * radius
        local v = Vector3.new(x, y, z)
        if v.Magnitude > 0 then v = v.Unit end
        table.insert(out, v)
    end
    return out
end

-- Collect unanchored non-character parts (with cap and optional distance filter)
local function collectUnanchoredParts(filterFn)
    local res = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart")
            and not v.Anchored
            and v.Name ~= "Handle"
            and not isPartPlayerCharacter(v)
            and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
            if not filterFn or filterFn(v) then
                table.insert(res, v)
                if #res >= MAX_GATHER_PARTS then break end
            end
        end
    end
    return res
end

-- Safe function to detach parts and apply velocity after BH destroyed
local function detachAndVelocityAfterDelay(partsList, velocityFn, delay)
    delay = delay or 0.1
    -- destroy the BH that was holding them (caller should destroy BH prior to calling this)
    spawn(function()
        wait(delay)
        for _, p in ipairs(partsList) do
            if p and p.Parent then
                pcall(function()
                    -- remove aligners & torque
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then ap:Destroy() end
                    local torque = p:FindFirstChildOfClass("Torque")
                    if torque then torque:Destroy() end
                    p.CanCollide = true
                    -- set massless back off if we had a stored original
                    if initiallyMasslessParts[p] ~= nil then
                        p.Massless = initiallyMasslessParts[p]
                    else
                        p.Massless = false
                    end
                    -- determine velocity
                    local vel = Vector3.new(0,0,0)
                    local ok, v = pcall(function() return velocityFn(p) end)
                    if ok and v then vel = v end
                    p.Velocity = vel
                end)
            end
        end
    end)
end

-- GOODBYE implementation (improved & batch-processed)
local function spawnGoodbyeForPlayer(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = targetPlayer.Character.HumanoidRootPart
    local centerPos = hrp.Position

    local folder = Workspace:FindFirstChild("ÆS_Goodbye_Folder") or Instance.new("Folder", Workspace)
    folder.Name = "ÆS_Goodbye_Folder"

    local BHs = {}

    -- create 5 pentagon orbiters + up + down
    local pentagonRadius = 30
    local pentagonCount = 5
    for i = 1, pentagonCount do
        local angle = (2 * math.pi * (i-1)) / pentagonCount
        local x = math.cos(angle) * pentagonRadius
        local z = math.sin(angle) * pentagonRadius
        local p = Instance.new("Part", folder)
        p.Anchored = true
        p.CanCollide = false
        p.Size = Vector3.new(1,1,1)
        p.Transparency = 1
        p.Position = centerPos + Vector3.new(x, 0, z)
        local att = Instance.new("Attachment", p)
        local bh = {
            Part = p,
            Attachment = att,
            AssignedParts = {},
            TargetPlayer = targetPlayer,
            _running = true,
            _active = true,
            spinSpeed = 2,
            source = "GOODBYE"
        }
        table.insert(BHs, bh)
    end

    -- above
    local pUp = Instance.new("Part", folder)
    pUp.Anchored = true
    pUp.CanCollide = false
    pUp.Size = Vector3.new(1,1,1)
    pUp.Transparency = 1
    pUp.Position = centerPos + Vector3.new(0, 40, 0)
    local attUp = Instance.new("Attachment", pUp)
    local bhUp = { Part = pUp, Attachment = attUp, AssignedParts = {}, TargetPlayer = targetPlayer, _running = true, _active = true, source = "GOODBYE" }
    table.insert(BHs, bhUp)

    -- below
    local pDown = Instance.new("Part", folder)
    pDown.Anchored = true
    pDown.CanCollide = false
    pDown.Size = Vector3.new(1,1,1)
    pDown.Transparency = 1
    pDown.Position = centerPos + Vector3.new(0, -40, 0)
    local attDown = Instance.new("Attachment", pDown)
    local bhDown = { Part = pDown, Attachment = attDown, AssignedParts = {}, TargetPlayer = targetPlayer, _running = true, _active = true, source = "GOODBYE" }
    table.insert(BHs, bhDown)

    -- add to global list
    for _, bh in ipairs(BHs) do table.insert(extraBlackHoles, bh) end

    -- spawn coroutines for BH motion & collision triggers
    for idx, bh in ipairs(BHs) do
        spawn(function()
            local t = 0
            local isPentagon = idx <= pentagonCount
            while bh._running do
                local dt = RunService.Heartbeat:Wait()
                t = t + dt
                if not (bh.TargetPlayer and bh.TargetPlayer.Character and bh.TargetPlayer.Character:FindFirstChild("HumanoidRootPart")) then
                    bh._running = false
                    break
                end
                local targetHRP = bh.TargetPlayer.Character.HumanoidRootPart
                local targetPos = targetHRP.Position

                if isPentagon then
                    bh.spinSpeed = bh.spinSpeed + (dt * 0.8) -- accelerate
                    local curPos = bh.Part.Position
                    local distToHRP = (curPos - targetPos).Magnitude
                    -- if close enough, trigger collision routine:
                    if distToHRP <= 1.6 then
                        bh._running = false
                        -- remove bh object from global list and destroy BH part first
                        local assigned = {}

                        -- copy assigned parts then clear BH.assign to avoid double processing
                        for i = 1, #bh.AssignedParts do table.insert(assigned, bh.AssignedParts[i]) end
                        bh.AssignedParts = {}

                        -- destroy BH now
                        pcall(function()
                            for i = #extraBlackHoles, 1, -1 do
                                if extraBlackHoles[i] == bh then table.remove(extraBlackHoles, i); break end
                            end
                        end)
                        if bh.Part and bh.Part.Parent then bh.Part:Destroy() end

                        -- after 0.1s apply velocities (random-ish outward 300)
                        detachAndVelocityAfterDelay(assigned, function(part)
                            -- random-ish outward direction away from player HRP center
                            local dir = (part.Position - targetPos).Unit
                            if dir.Magnitude == 0 then dir = Vector3.new(1,0,0) end
                            return dir * 300
                        end, 0.1)
                        break
                    else
                        -- orbit
                        local angleOff = (2 * math.pi * (idx-1) / pentagonCount) + (t * bh.spinSpeed)
                        local x = math.cos(angleOff) * pentagonRadius
                        local z = math.sin(angleOff) * pentagonRadius
                        local desiredPos = targetPos + Vector3.new(x, 0, z)
                        pcall(function()
                            bh.Part.CFrame = CFrame.new(desiredPos)
                            if bh.Attachment then bh.Attachment.WorldCFrame = bh.Part.CFrame end
                        end)
                    end
                else
                    -- above / below closing slowly
                    local curPos = bh.Part.Position
                    local dir = (targetPos - curPos)
                    local dist = dir.Magnitude
                    if dist > 1 then
                        local step = 6 * dt
                        local newPos = curPos + dir.Unit * math.min(step, dist)
                        pcall(function()
                            bh.Part.CFrame = CFrame.new(newPos)
                            if bh.Attachment then bh.Attachment.WorldCFrame = bh.Part.CFrame end
                        end)
                    else
                        bh._running = false
                        local assigned = {}
                        for i = 1, #bh.AssignedParts do table.insert(assigned, bh.AssignedParts[i]) end
                        bh.AssignedParts = {}

                        -- destroy BH and then apply velocities after 0.1s
                        pcall(function()
                            for i = #extraBlackHoles, 1, -1 do
                                if extraBlackHoles[i] == bh then table.remove(extraBlackHoles, i); break end
                            end
                        end)
                        if bh.Part and bh.Part.Parent then bh.Part:Destroy() end

                        detachAndVelocityAfterDelay(assigned, function(part)
                            local dir = (part.Position - targetPos).Unit
                            if dir.Magnitude == 0 then dir = Vector3.new(1,0,0) end
                            return dir * 300
                        end, 0.1)
                        break
                    end
                end
            end
            -- cleanup BH part if still exists
            pcall(function()
                if bh.Part and bh.Part.Parent then bh.Part:Destroy() end
            end)
        end)
    end

    -- Attach nearby unanchored parts to these BHs, but LIMIT total processed and batch to avoid mass lag
    spawn(function()
        local parts = collectUnanchoredParts()
        -- If too many parts, reduce by sampling nearest (to player)
        if #parts > MAX_GATHER_PARTS then
            table.sort(parts, function(a,b)
                local da = (a.Position - centerPos).Magnitude
                local db = (b.Position - centerPos).Magnitude
                return da < db
            end)
            while #parts > MAX_GATHER_PARTS do table.remove(parts) end
        end

        -- decide splitting policy
        local doSplit = (#parts <= SPLIT_IF_FEWER_THAN)

        local batch = {}
        local count = 0
        for _, part in ipairs(parts) do
            if not part or not part.Parent then continue end
            table.insert(batch, part)
            count = count + 1
            if #batch >= BATCH_SIZE then
                -- process batch
                for _, p in ipairs(batch) do
                    if p and p.Parent then
                        pcall(function()
                            if doSplit then
                                local clones = splitPartIntoPieces(p, 3)
                                -- attach each clone to nearest BH
                                for _, c in ipairs(clones) do
                                    if c and c.Parent then
                                        -- find nearest BH
                                        local nearestBH, nd = nil, math.huge
                                        for _, bh in ipairs(BHs) do
                                            if bh and bh.Part then
                                                local d = (c.Position - bh.Part.Position).Magnitude
                                                if d < nd then nd = d; nearestBH = bh end
                                            end
                                        end
                                        if nearestBH then
                                            pcall(function()
                                                c.Anchored = false
                                                stripBodyForces(c)
                                                pcall(function() c.Massless = true end)
                                                local Torque = Instance.new("Torque", c)
                                                Torque.Torque = FLING_TORQUE
                                                local AlignPosition = Instance.new("AlignPosition", c)
                                                local Attachment2 = Instance.new("Attachment", c)
                                                Attachment2.WorldCFrame = c.CFrame
                                                Torque.Attachment0 = Attachment2
                                                AlignPosition.MaxForce = PULL_MAX_FORCE
                                                AlignPosition.MaxVelocity = math.huge
                                                AlignPosition.Responsiveness = PULL_RESPONSIVENESS
                                                AlignPosition.Attachment0 = Attachment2
                                                AlignPosition.Attachment1 = nearestBH.Attachment
                                                c.CanCollide = false
                                                table.insert(nearestBH.AssignedParts, c)
                                            end)
                                        end
                                    end
                                end
                            else
                                -- attach original part to nearest BH without splitting
                                local nearestBH, nd = nil, math.huge
                                for _, bh in ipairs(BHs) do
                                    if bh and bh.Part then
                                        local d = (p.Position - bh.Part.Position).Magnitude
                                        if d < nd then nd = d; nearestBH = bh end
                                    end
                                end
                                if nearestBH then
                                    p.Anchored = false
                                    stripBodyForces(p)
                                    pcall(function() p.Massless = true end)
                                    local Torque = Instance.new("Torque", p)
                                    Torque.Torque = FLING_TORQUE
                                    local AlignPosition = Instance.new("AlignPosition", p)
                                    local Attachment2 = Instance.new("Attachment", p)
                                    Attachment2.WorldCFrame = p.CFrame
                                    Torque.Attachment0 = Attachment2
                                    AlignPosition.MaxForce = PULL_MAX_FORCE
                                    AlignPosition.MaxVelocity = math.huge
                                    AlignPosition.Responsiveness = PULL_RESPONSIVENESS
                                    AlignPosition.Attachment0 = Attachment2
                                    AlignPosition.Attachment1 = nearestBH.Attachment
                                    p.CanCollide = false
                                    table.insert(nearestBH.AssignedParts, p)
                                end
                            end
                        end)
                    end
                end
                batch = {}
                wait(0.08) -- yield to avoid frame spike
            end
        end

        -- final leftover batch
        for _, p in ipairs(batch) do
            if p and p.Parent then
                pcall(function()
                    if doSplit then
                        local clones = splitPartIntoPieces(p, 3)
                        for _, c in ipairs(clones) do
                            if c and c.Parent then
                                local nearestBH, nd = nil, math.huge
                                for _, bh in ipairs(BHs) do
                                    if bh and bh.Part then
                                        local d = (c.Position - bh.Part.Position).Magnitude
                                        if d < nd then nd = d; nearestBH = bh end
                                    end
                                end
                                if nearestBH then
                                    pcall(function()
                                        c.Anchored = false
                                        stripBodyForces(c)
                                        pcall(function() c.Massless = true end)
                                        local Torque = Instance.new("Torque", c)
                                        Torque.Torque = FLING_TORQUE
                                        local AlignPosition = Instance.new("AlignPosition", c)
                                        local Attachment2 = Instance.new("Attachment", c)
                                        Attachment2.WorldCFrame = c.CFrame
                                        Torque.Attachment0 = Attachment2
                                        AlignPosition.MaxForce = PULL_MAX_FORCE
                                        AlignPosition.MaxVelocity = math.huge
                                        AlignPosition.Responsiveness = PULL_RESPONSIVENESS
                                        AlignPosition.Attachment0 = Attachment2
                                        AlignPosition.Attachment1 = nearestBH.Attachment
                                        c.CanCollide = false
                                        table.insert(nearestBH.AssignedParts, c)
                                    end)
                                end
                            end
                        end
                    else
                        local nearestBH, nd = nil, math.huge
                        for _, bh in ipairs(BHs) do
                            if bh and bh.Part then
                                local d = (p.Position - bh.Part.Position).Magnitude
                                if d < nd then nd = d; nearestBH = bh end
                            end
                        end
                        if nearestBH then
                            p.Anchored = false
                            stripBodyForces(p)
                            pcall(function() p.Massless = true end)
                            local Torque = Instance.new("Torque", p)
                            Torque.Torque = FLING_TORQUE
                            local AlignPosition = Instance.new("AlignPosition", p)
                            local Attachment2 = Instance.new("Attachment", p)
                            Attachment2.WorldCFrame = p.CFrame
                            Torque.Attachment0 = Attachment2
                            AlignPosition.MaxForce = PULL_MAX_FORCE
                            AlignPosition.MaxVelocity = math.huge
                            AlignPosition.Responsiveness = PULL_RESPONSIVENESS
                            AlignPosition.Attachment0 = Attachment2
                            AlignPosition.Attachment1 = nearestBH.Attachment
                            p.CanCollide = false
                            table.insert(nearestBH.AssignedParts, p)
                        end
                    end
                end)
            end
        end
    end)
end

-- Top-level Goodbye trigger: spawn clusters for players in radius (and local player)
local function triggerGoodbye()
    local blastRadius = 3500
    local playersToTarget = {}
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            local basePos = (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and localPlayer.Character.HumanoidRootPart.Position) or Vector3.new(0,0,0)
            local d = (pl.Character.HumanoidRootPart.Position - basePos).Magnitude
            if d <= blastRadius then
                table.insert(playersToTarget, pl)
            end
        end
    end
    -- Always include local player
    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        table.insert(playersToTarget, localPlayer)
    end

    for _, pl in ipairs(playersToTarget) do
        spawnGoodbyeForPlayer(pl)
    end
end

-- NUCLEAR BOMB implementation (gather on button press; explosion on red button)
local nukeState = {
    collecting = false,
    collectedParts = {},
    folder = nil,
    centerPart = nil,
    centerAttachment = nil,
    ownerPos = nil
}

local function createCentralNukeHolder()
    local folder = Workspace:FindFirstChild("ÆS_Nuke_Folder") or Instance.new("Folder", Workspace)
    folder.Name = "ÆS_Nuke_Folder"
    local center = Instance.new("Part", folder)
    center.Name = "Nuke_Center"
    center.Anchored = true
    center.CanCollide = false
    center.Transparency = 1
    center.Size = Vector3.new(1,1,1)
    return folder, center
end

-- Start gathering immediately when the "nuclear bomb." button is pressed
local function startNukeGather()
    if nukeState.collecting then return end
    nukeState.collecting = true
    nukeState.collectedParts = {}
    nukeState.folder, nukeState.centerPart = createCentralNukeHolder()
    nukeState.centerPart.CFrame = (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and localPlayer.Character.HumanoidRootPart.CFrame) or CFrame.new(0,0,0)
    nukeState.centerAttachment = Instance.new("Attachment", nukeState.centerPart)
    nukeState.ownerPos = nukeState.centerPart.Position

    spawn(function()
        local parts = collectUnanchoredParts()
        -- If too many parts, pick the nearest MAX_GATHER_PARTS to the center
        if #parts > MAX_GATHER_PARTS then
            table.sort(parts, function(a,b)
                local da = (a.Position - nukeState.ownerPos).Magnitude
                local db = (b.Position - nukeState.ownerPos).Magnitude
                return da < db
            end)
            while #parts > MAX_GATHER_PARTS do table.remove(parts) end
        end

        local doSplit = (#parts <= SPLIT_IF_FEWER_THAN)
        local batch = {}
        for _, part in ipairs(parts) do
            table.insert(batch, part)
            if #batch >= BATCH_SIZE then
                for _, p in ipairs(batch) do
                    if p and p.Parent then
                        pcall(function()
                            if isPartPlayerCharacter(p) then return end
                            -- attach or clone
                            if doSplit then
                                local clones = splitPartIntoPieces(p, 3)
                                for _, c in ipairs(clones) do
                                    if c and c.Parent then
                                        stripBodyForces(c)
                                        pcall(function() c.Massless = true end)
                                        c.CanCollide = false
                                        local Torque = Instance.new("Torque", c)
                                        Torque.Torque = FLING_TORQUE
                                        local AlignPosition = Instance.new("AlignPosition", c)
                                        local Attachment2 = Instance.new("Attachment", c)
                                        Attachment2.WorldCFrame = c.CFrame
                                        Torque.Attachment0 = Attachment2
                                        AlignPosition.MaxForce = PULL_MAX_FORCE
                                        AlignPosition.MaxVelocity = math.huge
                                        AlignPosition.Responsiveness = PULL_RESPONSIVENESS
                                        AlignPosition.Attachment0 = Attachment2
                                        AlignPosition.Attachment1 = nukeState.centerAttachment
                                        table.insert(nukeState.collectedParts, c)
                                    end
                                end
                            else
                                stripBodyForces(p)
                                pcall(function() initiallyMasslessParts[p] = p.Massless end)
                                p.Massless = true
                                p.CanCollide = false
                                local Torque = Instance.new("Torque", p)
                                Torque.Torque = FLING_TORQUE
                                local AlignPosition = Instance.new("AlignPosition", p)
                                local Attachment2 = Instance.new("Attachment", p)
                                Attachment2.WorldCFrame = p.CFrame
                                Torque.Attachment0 = Attachment2
                                AlignPosition.MaxForce = PULL_MAX_FORCE
                                AlignPosition.MaxVelocity = math.huge
                                AlignPosition.Responsiveness = PULL_RESPONSIVENESS
                                AlignPosition.Attachment0 = Attachment2
                                AlignPosition.Attachment1 = nukeState.centerAttachment
                                table.insert(nukeState.collectedParts, p)
                            end
                        end)
                    end
                end
                batch = {}
                wait(0.08)
            end
        end

        -- leftover
        for _, p in ipairs(batch) do
            if p and p.Parent then
                pcall(function()
                    if isPartPlayerCharacter(p) then return end
                    if (#nukeState.collectedParts <= SPLIT_IF_FEWER_THAN) then
                        local clones = splitPartIntoPieces(p, 3)
                        for _, c in ipairs(clones) do
                            if c and c.Parent then
                                stripBodyForces(c)
                                pcall(function() c.Massless = true end)
                                c.CanCollide = false
                                local Torque = Instance.new("Torque", c)
                                Torque.Torque = FLING_TORQUE
                                local AlignPosition = Instance.new("AlignPosition", c)
                                local Attachment2 = Instance.new("Attachment", c)
                                Attachment2.WorldCFrame = c.CFrame
                                Torque.Attachment0 = Attachment2
                                AlignPosition.MaxForce = PULL_MAX_FORCE
                                AlignPosition.MaxVelocity = math.huge
                                AlignPosition.Responsiveness = PULL_RESPONSIVENESS
                                AlignPosition.Attachment0 = Attachment2
                                AlignPosition.Attachment1 = nukeState.centerAttachment
                                table.insert(nukeState.collectedParts, c)
                            end
                        end
                    else
                        stripBodyForces(p)
                        pcall(function() initiallyMasslessParts[p] = p.Massless end)
                        p.Massless = true
                        p.CanCollide = false
                        local Torque = Instance.new("Torque", p)
                        Torque.Torque = FLING_TORQUE
                        local AlignPosition = Instance.new("AlignPosition", p)
                        local Attachment2 = Instance.new("Attachment", p)
                        Attachment2.WorldCFrame = p.CFrame
                        Torque.Attachment0 = Attachment2
                        AlignPosition.MaxForce = PULL_MAX_FORCE
                        AlignPosition.MaxVelocity = math.huge
                        AlignPosition.Responsiveness = PULL_RESPONSIVENESS
                        AlignPosition.Attachment0 = Attachment2
                        AlignPosition.Attachment1 = nukeState.centerAttachment
                        table.insert(nukeState.collectedParts, p)
                    end
                end)
            end
        end

        -- done gathering; leaving nukeState.collecting true until detonation
    end)
end

-- Explosion handler (triggered by pressing the red button)
local function triggerNukeExplosion()
    if not nukeState.collecting then return end
    nukeState.collecting = false

    -- remove central BH attachments/part immediately and then apply velocities after 0.1s
    local parts = {}
    for _, p in ipairs(nukeState.collectedParts) do
        if p and p.Parent then table.insert(parts, p) end
    end

    -- Destroy central BH/attachment first
    pcall(function()
        if nukeState.centerAttachment and nukeState.centerAttachment.Parent then nukeState.centerAttachment:Destroy() end
        if nukeState.centerPart and nukeState.centerPart.Parent then nukeState.centerPart:Destroy() end
    end)

    -- set gravity to 0, but save original and guarantee restore after 3 seconds
    local origGravity = Workspace.Gravity
    pcall(function() Workspace.Gravity = 0 end)

    -- apply velocities after 0.1s and then restore gravity after 3 seconds
    spawn(function()
        wait(0.1)
        local n = #parts
        if n > 0 then
            local dirs = goldenSphereDirections(n)
            for i, part in ipairs(parts) do
                if part and part.Parent then
                    pcall(function()
                        local ap = part:FindFirstChildOfClass("AlignPosition")
                        if ap then ap:Destroy() end
                        local att = part:FindFirstChildOfClass("Attachment")
                        if att then att:Destroy() end
                        part.CanCollide = true
                        -- restore massless state if stored
                        if initiallyMasslessParts[part] ~= nil then
                            pcall(function() part.Massless = initiallyMasslessParts[part] end)
                        else
                            pcall(function() part.Massless = false end)
                        end
                        local dir = dirs[((i-1) % #dirs) + 1]
                        part.Velocity = dir * 1500
                    end)
                end
            end
        end
    end)

    -- restore gravity after 3 seconds (guaranteed)
    spawn(function()
        wait(3)
        pcall(function() Workspace.Gravity = origGravity end)
    end)

    -- cleanup nuke folder state
    nukeState.collectedParts = {}
    nukeState.folder = nil
    nukeState.centerPart = nil
    nukeState.centerAttachment = nil
    nukeState.ownerPos = nil
end

-- Nuke UI overlay creation (right side); redBtn triggers triggerNukeExplosion; clicking "nuclear bomb." starts gather
local function spawnNukeOverlay()
    -- Remove old overlay if it exists
    pcall(function()
        local old = localPlayer.PlayerGui:FindFirstChild("ÆS_NukeGui")
        if old then old:Destroy() end
    end)

    local gui = Instance.new("ScreenGui")
    gui.Name = "ÆS_NukeGui"
    gui.ResetOnSpawn = false
    gui.Parent = localPlayer:WaitForChild("PlayerGui")

    local frame = Instance.new("Frame")
    frame.Name = "NukeFrame"
    frame.AnchorPoint = Vector2.new(1, 0.5)
    frame.Position = UDim2.new(1, -12, 0.5, 0)
    frame.Size = UDim2.new(0, 240, 0, 160)
    frame.BackgroundColor3 = Color3.new(1, 1, 0)
    frame.BorderSizePixel = 0
    frame.Parent = gui

    local topText = Instance.new("TextLabel", frame)
    topText.Size = UDim2.new(1, -16, 0, 20)
    topText.Position = UDim2.new(0, 8, 0, 8)
    topText.BackgroundTransparency = 1
    topText.Font = Enum.Font.SourceSansBold
    topText.Text = "Ordered from Temu shipping."
    topText.TextColor3 = Color3.new(1,1,1)
    topText.TextScaled = true

    local redBtn = Instance.new("TextButton", frame)
    redBtn.Size = UDim2.new(0, 80, 0, 80)
    redBtn.Position = UDim2.new(0.5, -40, 0.5, -20)
    redBtn.AnchorPoint = Vector2.new(0.5, 0.5)
    redBtn.Text = ""
    redBtn.AutoButtonColor = true
    redBtn.BackgroundColor3 = Color3.new(1,0,0)
    redBtn.BorderSizePixel = 0
    redBtn.ZIndex = 5
    redBtn.TextScaled = false
    redBtn.Parent = frame
    -- RobloxRoundButton style not always accessible; keep simple

    local label = Instance.new("TextLabel", frame)
    label.Size = UDim2.new(1, -16, 0, 24)
    label.Position = UDim2.new(0, 8, 1, -32)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.SourceSansBold
    label.Text = "kim ung yong nuke launcher 3000"
    label.TextScaled = true
    label.TextColor3 = Color3.new(0,0,0)

    -- red button triggers explosion
    redBtn.MouseButton1Click:Connect(function()
        -- small press animation
        spawn(function()
            for i=1,2 do
                redBtn.Size = redBtn.Size + UDim2.new(0, 6, 0, 6)
                wait(0.04)
                redBtn.Size = redBtn.Size - UDim2.new(0, 6, 0, 6)
                wait(0.04)
            end
        end)
        -- trigger explosion (if gathering occurred)
        pcall(function() triggerNukeExplosion() end)
    end)
end

-- ---------- GUI (TurtleLib) - recreate UI with modifications ----------
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/miroeramaa/TurtleLib/main/TurtleUiLib.lua"))()
local window = library:Window("Fix it you panis negor🗣🔥")

window:Toggle("Unanchored Target All", false, function(Value) setTargetAll(Value) end)
window:Toggle("Target Selected Players", false, function(Value) setTargetSelected(Value) end)

window:Toggle("Life Cycle Mode", false, function(Value)
    LifeCycleMode = Value
    if LifeCycleMode then
        tryStartCycleIfNeeded()
    else
        endCycleMode()
    end
end)

window:Button("Reset Cycle", function()
    resetCycleNow()
end)

-- Goodbye button
window:Button("Goodbye.", function()
    spawn(function()
        pcall(function() triggerGoodbye() end)
    end)
end)

-- nuclear bomb. button now STARTS GATHERING and opens overlay (detonation separate)
window:Button("nuclear bomb.", function()
    spawn(function()
        pcall(function()
            -- start gathering immediately
            startNukeGather()
            -- spawn overlay with the red detonation button
            spawnNukeOverlay()
        end)
    end)
end)

local loopCheckActive = false
window:Toggle("Continuous Loop Check", false, function(Value)
    loopCheckActive = Value
    if loopCheckActive then
        spawn(function()
            while loopCheckActive do
                if targetAllActive or targetSelectedActive then
                    for _, v in ipairs(Workspace:GetDescendants()) do
                        if v:IsA("BasePart") and not v.Anchored and not processedParts[v] and not isPartPlayerCharacter(v) and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
                            if initiallyMasslessParts[v] == nil then pcall(function() initiallyMasslessParts[v] = v.Massless end) end
                            pcall(function() v.Massless = true end)
                            ForcePart(v)
                        end
                    end
                end
                wait(0.5)
            end
        end)
    end
end)

window:Toggle("PAA/unPAA (player amount BHs)", false, function(Value)
    PAAEnabled = Value
    if PAAEnabled then
        PAA_isUsingSelected = false
        refreshPAA()
        paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
        paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
    else
        for _, c in ipairs(paaConnections) do pcall(function() c:Disconnect() end) end
        paaConnections = {}
        deleteBHsBySource("PAA")
    end
end)

-- NEW: Insta Void toggle — makes BH skid 2 studs above HRP (rapid)
window:Toggle("Insta Void", false, function(Value)
    InstaVoid = Value
end)

-- NEW: Negative fling toggle — switches fling multiplier to negative value
window:Toggle("Negative fling", false, function(Value)
    NegativeFling = Value
    if NegativeFling then
        FLING_MULTIPLIER = -math.abs(9000000000000000)
    else
        FLING_MULTIPLIER = math.abs(9000000000000000)
    end
    updateFlingTorque()
end)

-- Auto-refresh loops (kept)
spawn(function()
    while true do
        if PAAEnabled then
            if PAA_isUsingSelected then
                if targetSelectedActive then refreshPAA() end
            else
                if targetAllActive then refreshPAA() end
            end
        end
        wait(2)
    end
end)

spawn(function()
    while true do
        if #extraBlackHoles > 0 and not rebalancerRunning then startRebalancer()
        elseif #extraBlackHoles == 0 and rebalancerRunning then stopRebalancer() end
        if cycleRestartPending then scheduleCycleRestart() end
        wait(0.5)
    end
end)

-- HUD (kept)
do
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ÆS_BHCountGui"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = localPlayer:WaitForChild("PlayerGui")

    local txt = Instance.new("TextLabel")
    txt.Name = "BlackHoleCount"
    txt.AnchorPoint = Vector2.new(0.5, 0)
    txt.Position = UDim2.new(0.5, 0, 0, 6)
    txt.Size = UDim2.new(0, 220, 0, 24)
    txt.BackgroundTransparency = 1
    txt.TextTransparency = 0
    txt.Text = "BlackHoles: 0"
    txt.TextScaled = false
    txt.TextSize = 18
    txt.Font = Enum.Font.SourceSansSemibold
    txt.TextColor3 = Color3.new(1,1,1)
    txt.Parent = screenGui

    local function countBlackHolePartsInFolders()
        local count = 0
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if obj:IsA("Folder") then
                local lname = obj.Name:lower()
                if string.find(lname, "blackhole") or string.find(lname, "bh") or string.find(lname, "aes_blackhole") or string.find(lname, "æs_blackhole") then
                    for _, child in ipairs(obj:GetDescendants()) do
                        if child:IsA("BasePart") then
                            local cname = child.Name:lower()
                            if string.find(cname, "extrabh_center") or string.find(cname, "bh_center") or string.find(cname, "bh_center_part") or string.find(cname, "extra") then
                                count = count + 1
                            end
                        end
                    end
                end
            end
        end
        return count
    end

    spawn(function()
        while true do
            local count = 0
            pcall(function() count = countBlackHolePartsInFolders() end)
            txt.Text = "BlackHoles: "..tostring(count)
            wait(0.5)
        end
    end)
end

-- ---------- AUTO-RUN: telekinesis fix & playerlist loadstrings (kept auto-run) ----------
spawn(function()
    pcall(function()
        local s = game:HttpGet(('https://raw.githubusercontent.com/SAZXHUB/Control-update/main/README.md'), true)
        if s and #s > 10 then
            local fn = loadstring(s)
            if fn then pcall(fn) end
        end
    end)
    pcall(function()
        local s2 = game:HttpGet("https://raw.githubusercontent.com/Jlchris1/Udklol/refs/heads/main/Playerlistv6")
        if s2 and #s2 > 10 then
            local fn2 = loadstring(s2)
            if fn2 then pcall(fn2) end
        end
    end)
end)

-- End of script
