-- Full updated script: fling mult 0.7, fling cooldown 0.7s, loop check every 3s,
-- PAA blackholes limited to players, player snapshot every 0.3s, ping-friendly measures.
-- Paste into client.

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer

local function clamp(val, a, b)
    if val < a then return a end
    if val > b then return b end
    return val
end

-- ====== CONFIG / STATE ======
local targetAllActive = false
local targetSelectedActive = false
local primaryLoopRunning = false

local switchDelay = 0.13
local processedParts = {}
local initiallyAnchoredParts = {}
local initiallyMasslessParts = {} -- store original Massless state to restore later
local anchoredOnce = false
local unanchorTimerRunning = false
local unanchorCoroutine

local Attachment1 = nil

local extraBlackHoles = {}

-- per-part AncestryChanged connections to auto-clean when parts are removed/destroyed
local partConns = {}

-- per-part fling cooldowns
local flingCooldowns = {}
local FLING_COOLDOWN = 0.7 -- seconds

-- PAA state
local PAAEnabled = false
local PAA_isUsingSelected = false
local paaConnections = {}

-- Rebalancer
local rebalancerRunning = false
local rebalancerFreq = 0.25 -- slightly larger to be ping-friendly

-- BH motion
local TARGET_SMOOTHNESS = 6.0
local ROTATE_INTERVAL = 0.2

local LifeCycleMode = false
local cycleActive = false
local cyclePlayers = {}
local cycleDead = {}
local cycleConns = {}
local cycleRestartPending = false

-- USER-REQUESTED VALUES
local fallenpartsdestroyheight = 0/0 -- NaN requested (keeps fallen parts from being auto-destroyed)

local BASE_FLING_AXIS = 1e6
local BASE_PULL_FORCE = 1e8
local BASE_PULL_RESP  = 1e6

-- Apply fling multiplier 0.7 as requested
local FLING_MULTIPLIER = 0.7
local PULL_MULTIPLIER  = math.huge  -- keep PULL heavy as originally (you can change)

local FLING_TORQUE = Vector3.new(BASE_FLING_AXIS * FLING_MULTIPLIER,
                                 BASE_FLING_AXIS * FLING_MULTIPLIER,
                                 BASE_FLING_AXIS * FLING_MULTIPLIER)
-- ONE_FRAME_FLING multiplier set to 0.7
local ONE_FRAME_FLING_MULT = 0.7

local PULL_MAX_FORCE = BASE_PULL_FORCE * PULL_MULTIPLIER
local PULL_RESPONSIVENESS = BASE_PULL_RESP * PULL_MULTIPLIER

local MASSLESS_TORQUE_SCALE = 1.0
local MASSLESS_PULL_SCALE  = 1.0
local MASSLESS_RESP_SCALE  = 1.2

-- AGGRESSIVE SKID SETTINGS
local SKID_SMOOTHNESS = 40.0

-- Prediction helpers (velocity history)
local playerLastVel = {}
local playerLastVelTime = {}

-- Attach last target tracking for instant snaps
local lastAttachment1Target = nil

-- Lightweight player snapshot (updated at 0.3s intervals)
local playerSnapshot = {}
local PLAYER_SNAPSHOT_INTERVAL = 0.3
spawn(function()
    while true do
        for _, pl in pairs(Players:GetPlayers()) do
            if pl and pl ~= localPlayer and pl.Parent then
                local char = pl.Character
                if char and char:FindFirstChild("HumanoidRootPart") then
                    local hrp = char.HumanoidRootPart
                    pcall(function()
                        playerSnapshot[pl] = {
                            pos = hrp.Position,
                            vel = hrp.Velocity,
                            t = tick()
                        }
                    end)
                end
            end
        end
        wait(PLAYER_SNAPSHOT_INTERVAL)
    end
end)

-- Setup folder & primary attachment
local function setupPlayer()
    local Folder = Workspace:FindFirstChild("ÆS_BlackHole_Folder")
    if not Folder then
        Folder = Instance.new("Folder", Workspace)
        Folder.Name = "ÆS_BlackHole_Folder"
    end
    local existing = Folder:FindFirstChild("BH_Center_Part")
    if existing and existing:IsA("BasePart") then
        local att = existing:FindFirstChildOfClass("Attachment")
        if att then return att end
        local newAtt = Instance.new("Attachment", existing)
        return newAtt
    end
    local Part = Instance.new("Part", Folder)
    Part.Name = "BH_Center_Part"
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1
    Part.Size = Vector3.new(1,1,1)
    local Attachment = Instance.new("Attachment", Part)
    return Attachment
end

Attachment1 = setupPlayer()

-- helpers
local function isNPC(character)
    if not character or not character:IsA("Model") then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and not Players:GetPlayerFromCharacter(character) then return true end
    return false
end

local function isPartPlayerCharacter(part)
    if not part then return false end
    for _, pl in ipairs(Players:GetPlayers()) do
        local char = pl.Character
        if char and part:IsDescendantOf(char) then
            return true
        end
    end
    return false
end

local function stripBodyForces(part)
    for _, x in next, part:GetChildren() do
        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
        or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
        or x:IsA("RocketPropulsion") then
            x:Destroy()
        end
    end
    if part:FindFirstChild("Attachment") then part:FindFirstChild("Attachment"):Destroy() end
    if part:FindFirstChild("AlignPosition") then part:FindFirstChild("AlignPosition"):Destroy() end
    if part:FindFirstChild("Torque") then part:FindFirstChild("Torque"):Destroy() end
end

-- robust velocity getter + setter (AssemblyLinearVelocity preferred)
local function getPartVelocity(part)
    if not part or not part:IsA("BasePart") then return Vector3.new(0,0,0) end
    local ok, v = pcall(function() return part.AssemblyLinearVelocity end)
    if ok and typeof(v) == "Vector3" then
        return v
    end
    local ok2, v2 = pcall(function() return part.Velocity end)
    if ok2 and typeof(v2) == "Vector3" then
        return v2
    end
    return Vector3.new(0,0,0)
end

local function setPartVelocity(part, vec)
    if not part or not part.Parent then return end
    pcall(function() part.AssemblyLinearVelocity = vec end)
    pcall(function() part.Velocity = vec end)
end

local function isFiniteNumber(n)
    return type(n) == "number" and n == n and n ~= math.huge and n ~= -math.huge
end

local function signOfNumber(n)
    if type(n) ~= "number" then return 1 end
    if n > 0 then return 1 elseif n < 0 then return -1 else return 1 end
end

-- -----------------------
-- PING ESTIMATOR (anti-ping measures)
-- -----------------------
local estimatedPing = 0.06 -- seconds fallback
do
    spawn(function()
        local samples = {}
        local maxSamples = 8
        while true do
            local gotPing, ping = pcall(function()
                if localPlayer and localPlayer.GetNetworkPing then
                    return localPlayer:GetNetworkPing()
                end
                return nil
            end)
            if gotPing and type(ping) == "number" and ping > 0 then
                table.insert(samples, ping)
                if #samples > maxSamples then table.remove(samples, 1) end
                local sum = 0
                for _, v in ipairs(samples) do sum = sum + v end
                estimatedPing = sum / #samples
            else
                -- fallback heartbeat-based approx (small sample to be ping-friendly)
                local hbSamples = {}
                for i = 1, 4 do
                    local t0 = tick()
                    RunService.Heartbeat:Wait()
                    local t1 = tick()
                    table.insert(hbSamples, math.max(0, t1 - t0))
                end
                local sumh = 0
                for _, v in ipairs(hbSamples) do sumh = sumh + v end
                local avg = (sumh / #hbSamples) * 1.5
                if avg and avg > 0 then estimatedPing = avg end
            end
            wait(1.0)
        end
    end)
end

-- -----------------------
-- FallenPartsDestroyHeight = NaN enforcement
-- -----------------------
do
    spawn(function()
        local nan = 0/0
        while true do
            pcall(function()
                Workspace.FallenPartsDestroyHeight = nan
            end)
            wait(1)
        end
    end)
end

-- ONE-FRAME FLING helper (robust with finite multiplier)
local function doOneFrameFling(part, flingVec, multiplier)
    if not part or not part.Parent then return end
    local ok, _ = pcall(function() return part:IsDescendantOf(game) end)
    if not ok then return end

    -- Try to take network ownership so physics changes are applied from local client
    pcall(function()
        if typeof(part.SetNetworkOwner) == "function" then
            pcall(function() part:SetNetworkOwner(localPlayer) end)
        else
            pcall(function() part:SetNetworkOwner(localPlayer) end)
        end
    end)

    local orig = getPartVelocity(part)
    local mult = multiplier or ONE_FRAME_FLING_MULT

    -- sanitize multiplier (if user later sets INF, clamp)
    if mult == math.huge or mult == -math.huge or not isFiniteNumber(mult) then
        mult = 1.0
    end

    -- Compose applied vector; use flingVec (may be zero) + orig * mult
    flingVec = flingVec or Vector3.new(0,0,0)
    local applied = Vector3.new(
        (flingVec.X or 0) + (orig.X or 0) * mult,
        (flingVec.Y or 0) + (orig.Y or 0) * mult,
        (flingVec.Z or 0) + (orig.Z or 0) * mult
    )

    -- Sanitize components (prevent Inf / NaN)
    local function sanitizeComponent(comp, fallbackComp)
        if isFiniteNumber(comp) then
            -- clamp to reasonably large magnitude to avoid runtime issues
            if comp > 1e308 then return 1e308 end
            if comp < -1e308 then return -1e308 end
            return comp
        end
        -- fallback to sign of flingVec or orig
        local s = signOfNumber(fallbackComp)
        return 1e50 * s
    end

    applied = Vector3.new(
        sanitizeComponent(applied.X, (flingVec.X ~= 0 and flingVec.X) or orig.X),
        sanitizeComponent(applied.Y, (flingVec.Y ~= 0 and flingVec.Y) or orig.Y),
        sanitizeComponent(applied.Z, (flingVec.Z ~= 0 and flingVec.Z) or orig.Z)
    )

    -- Apply the extreme velocity, but avoid excessive repeated restores (ping-friendly)
    pcall(function() setPartVelocity(part, applied) end)

    -- Immediate frame restore
    RunService.RenderStepped:Wait()
    pcall(function() setPartVelocity(part, orig) end)

    -- Extra restore on Stepped
    RunService.Stepped:Wait()
    pcall(function() setPartVelocity(part, orig) end)

    -- Anti-ping repeated restores: short, bounded duration
    local duration = math.max(0.04, estimatedPing * 2.0) -- prefer shorter
    local endTime = tick() + duration
    while tick() < endTime do
        RunService.RenderStepped:Wait()
        pcall(function() setPartVelocity(part, orig) end)
    end

    -- final small retries
    for i = 1, 2 do
        wait(0.02 * i)
        pcall(function() setPartVelocity(part, orig) end)
    end

    -- tiny vertical pulse to keep physics active
    pcall(function() setPartVelocity(part, orig + Vector3.new(0, 0.03, 0)) end)
end

local function shuffle(t)
    for i = #t, 2, -1 do
        local j = math.random(1, i)
        t[i], t[j] = t[j], t[i]
    end
end

local function smoothLerpCFrame(curCF, targetCF, dt)
    local alpha = 1 - math.exp(-TARGET_SMOOTHNESS * dt)
    if alpha < 0.001 then alpha = 0.001 end
    if alpha > 1 then alpha = 1 end
    return curCF:Lerp(targetCF, alpha)
end

-- WHITELIST: same behavior as original — returns BoolValue on player named "Whitelisted"
local function isWhitelisted(player)
    if not player then return false end
    local v = player:FindFirstChild("Whitelisted")
    if v and typeof(v.Value) == "boolean" then
        return v.Value
    end
    return false
end

local function isPlayerAlive(player)
    if not player then return false end
    local char = player.Character
    if not char then return false end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    if humanoid.Health and humanoid.Health > 0 then return true end
    return false
end

local function getAllNonLocalPlayers()
    local res = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p and p ~= localPlayer and p.Parent and not isWhitelisted(p) then
            table.insert(res, p)
        end
    end
    return res
end

local function getSelectedPlayers(allowWhitelisted)
    local res = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player and player ~= localPlayer and player.Parent then
            local sel = player:FindFirstChild("Selected")
            if sel and typeof(sel.Value) == "boolean" and sel.Value == true then
                if allowWhitelisted then
                    table.insert(res, player)
                else
                    if not isWhitelisted(player) then table.insert(res, player) end
                end
            end
        end
    end
    return res
end

local function getBHsBySource(source)
    local out = {}
    for _, bh in ipairs(extraBlackHoles) do
        if bh.source == source then table.insert(out, bh) end
    end
    return out
end

local function getLeastLoadedBlackHole()
    if #extraBlackHoles == 0 then return nil end
    table.sort(extraBlackHoles, function(a,b) return (#a.AssignedParts) < (#b.AssignedParts) end)
    return extraBlackHoles[1]
end

-- Predict using velocity + acceleration estimate (deterministic)
local function predictTargetPosition(pl, pos, vel, now)
    local lastV = playerLastVel[pl]
    local lastT = playerLastVelTime[pl]
    local accel = Vector3.new(0,0,0)
    if lastV and lastT and now and now > lastT then
        accel = (vel - lastV) / (now - lastT)
    else
        -- fallback to snapshot (0.3s based)
        local snap = playerSnapshot[pl]
        if snap and snap.t and now and now > snap.t then
            accel = (vel - (snap.vel or Vector3.new())) / math.max(0.0001, (now - snap.t))
        end
    end
    playerLastVel[pl] = vel
    playerLastVelTime[pl] = now

    local speed = vel.Magnitude
    local leadFactor = clamp(0.25 + (speed * 0.06), 0.25, 1.8)
    local tlead = leadFactor
    local predicted = pos + vel * tlead + 0.5 * accel * (tlead * tlead)
    return predicted, leadFactor, accel
end

-- ForcePart (also massless handling) with per-part AncestryChanged cleanup + fling cooldown
local function ForcePart(v)
    if not v or not v:IsA("BasePart") then return end
    if isPartPlayerCharacter(v) then return end
    if localPlayer.Character and v:IsDescendantOf(localPlayer.Character) then return end

    if v:IsA("BasePart")
        and not v.Anchored
        and v.Name ~= "Handle"
        and (
            (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
            or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
        ) then

        if processedParts[v] then return end
        processedParts[v] = true

        -- add an AncestryChanged listener so if the part is removed/destroyed we stop touching it
        if not partConns[v] then
            local conn
            conn = v.AncestryChanged:Connect(function()
                if not v or not v.Parent or not v:IsDescendantOf(game) then
                    processedParts[v] = nil
                    initiallyAnchoredParts[v] = nil
                    initiallyMasslessParts[v] = nil
                    if partConns[v] then
                        pcall(function() partConns[v]:Disconnect() end)
                        partConns[v] = nil
                    end
                    flingCooldowns[v] = nil
                end
            end)
            partConns[v] = conn
        end

        if initiallyMasslessParts[v] == nil then
            pcall(function() initiallyMasslessParts[v] = v.Massless end)
        end

        pcall(function() v.Massless = true end)

        stripBodyForces(v)
        v.CanCollide = false

        -- FIRST: create AlignPosition + Attachment to "grab/pull" the part
        local Attachment2 = Instance.new("Attachment")
        Attachment2.Parent = v
        pcall(function() Attachment2.WorldCFrame = v.CFrame end)

        local AlignPosition = Instance.new("AlignPosition")
        AlignPosition.Parent = v
        AlignPosition.Attachment0 = Attachment2
        AlignPosition.MaxVelocity = math.huge

        local ok, isMass = pcall(function() return v.Massless end)

        local maxF = PULL_MAX_FORCE
        local resp  = PULL_RESPONSIVENESS
        if ok and isMass == true then
            maxF = maxF * MASSLESS_PULL_SCALE
            resp  = resp * MASSLESS_RESP_SCALE
        end
        AlignPosition.MaxForce = maxF
        AlignPosition.Responsiveness = resp

        -- choose BH attachment (or center Attachment1) immediately so pull is active
        local bh = getLeastLoadedBlackHole()
        if bh and bh.Attachment and bh._active then
            AlignPosition.Attachment1 = bh.Attachment
            table.insert(bh.AssignedParts, v)
        else
            AlignPosition.Attachment1 = Attachment1
        end

        -- SECOND: create torque / fling-like effects (after pull is established)
        local torqueVal = FLING_TORQUE
        if ok and isMass == true then
            torqueVal = torqueVal * MASSLESS_TORQUE_SCALE
        end
        local Torque = Instance.new("Torque")
        Torque.Parent = v
        Torque.Attachment0 = Attachment2
        Torque.Torque = torqueVal

        -- ONE-FRAME fling to transfer impulse (local restore) but respect cooldown
        spawn(function()
            local nowt = tick()
            local last = flingCooldowns[v] or 0
            if nowt - last >= FLING_COOLDOWN then
                flingCooldowns[v] = nowt
                pcall(function()
                    doOneFrameFling(v, Vector3.new(0,0,0), ONE_FRAME_FLING_MULT)
                end)
            end
        end)
    end
end

local function clearProcessedParts()
    for part, _ in pairs(processedParts) do
        if part and part.Parent then
            stripBodyForces(part)
            part.CanCollide = true
            if initiallyAnchoredParts[part] == false then
                part.Anchored = false
            elseif initiallyAnchoredParts[part] == true then
                part.Anchored = true
            end

            if initiallyMasslessParts[part] ~= nil then
                local original = initiallyMasslessParts[part]
                pcall(function() part.Massless = original end)
            else
                pcall(function() part.Massless = false end)
            end
        end
        -- disconnect per-part conn
        if partConns[part] then
            pcall(function() partConns[part]:Disconnect() end)
            partConns[part] = nil
        end
        flingCooldowns[part] = nil
    end
    processedParts = {}
    initiallyAnchoredParts = {}
    initiallyMasslessParts = {}
    anchoredOnce = false
end

local function anchorAndDelayedUnanchorParts()
    unanchorTimerRunning = true

    local candidateParts = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart")
            and not v.Anchored
            and v.Name ~= "Handle"
            and not isPartPlayerCharacter(v)
            and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character))
            and (
                (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
            ) then
            table.insert(candidateParts, v)
        end
    end

    initiallyAnchoredParts = {}
    for _, part in ipairs(candidateParts) do
        initiallyAnchoredParts[part] = false
        if initiallyMasslessParts[part] == nil then
            pcall(function() initiallyMasslessParts[part] = part.Massless end)
        end
        pcall(function() part.Massless = true end)

        part.Anchored = true
        part.CanCollide = false
    end

    for _, npcCandidate in ipairs(Workspace:GetChildren()) do
        if isNPC(npcCandidate) then
            for _, p in ipairs(npcCandidate:GetDescendants()) do
                if p:IsA("BasePart") then p.CanCollide = true end
            end
        end
    end

    local startTime = tick()
    while (targetAllActive or targetSelectedActive) and tick() - startTime < 1 do
        wait(0.05)
    end

    for _, part in ipairs(candidateParts) do
        if part and part.Parent and initiallyAnchoredParts[part] == false then
            part.Anchored = false
            pcall(function()
                if not isPartPlayerCharacter(part) and not (localPlayer.Character and part:IsDescendantOf(localPlayer.Character)) then
                    initiallyMasslessParts[part] = initiallyMasslessParts[part] or part.Massless
                    part.Massless = true
                end
            end)
            ForcePart(part)
        end
    end

    unanchorTimerRunning = false
    anchoredOnce = true
end

local descendantAddedConn
local function processWorkspaceParts()
    if descendantAddedConn then
        pcall(function() descendantAddedConn:Disconnect() end)
        descendantAddedConn = nil
    end

    if (targetAllActive or targetSelectedActive) then
        if not unanchorTimerRunning and not anchoredOnce then
            unanchorCoroutine = coroutine.create(anchorAndDelayedUnanchorParts)
            coroutine.resume(unanchorCoroutine)
        end

        descendantAddedConn = Workspace.DescendantAdded:Connect(function(v)
            -- protect against parts that are removed very fast
            if not v or not v.Parent then return end
            if (targetAllActive or targetSelectedActive) then
                if v:IsA("BasePart")
                    and not v.Anchored
                    and not processedParts[v]
                    and not isPartPlayerCharacter(v)
                    and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
                    if initiallyMasslessParts[v] == nil then
                        pcall(function() initiallyMasslessParts[v] = v.Massless end)
                    end
                    pcall(function() v.Massless = true end)
                    ForcePart(v)
                end
            end
        end)
    end
end

local function getRandomPlayer()
    local players = getAllNonLocalPlayers()
    if #players == 0 then return nil end
    return players[math.random(1, #players)]
end

-- set BH active/inactive
local function setBlackHoleActiveState(bh, active)
    if not bh then return end
    if bh._active == active then return end
    bh._active = active
    if not active then
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                p.CanCollide = true
                local ap = p:FindFirstChildOfClass("AlignPosition")
                if ap then
                    ap.Attachment1 = Attachment1
                    pcall(function()
                        local isMass = (pcall(function() return p.Massless end) and p.Massless)
                        ap.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                        ap.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                    end)
                end
            end
        end
    else
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                local ap = p:FindFirstChildOfClass("AlignPosition")
                if ap then ap.Attachment1 = bh.Attachment; p.CanCollide = false end
            end
        end
    end
end

-- create extra BH helper (with pending target logic and fixed forward/back skidding)
-- MODIFICATION: if initialTarget provided and valid, adopt it immediately (like original)
local function createExtraBlackHole(initialTarget, source)
    if initialTarget == localPlayer then initialTarget = nil end
    if initialTarget and isWhitelisted(initialTarget) and source ~= "CMD_ALLOW_WHITELISTED" then
        -- if whitelisted and source doesn't allow, ignore initial target
        initialTarget = nil
    end

    local folder = Workspace:FindFirstChild("ÆS_BlackHole_Folder") or Instance.new("Folder", Workspace)
    folder.Name = "ÆS_BlackHole_Folder"
    local part = Instance.new("Part", folder)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1,1,1)
    part.Name = "ExtraBH_Center"

    local att = Instance.new("Attachment", part)

    local bh = {
        Part = part,
        Attachment = att,
        AssignedParts = {},
        TargetPlayer = nil,        -- active adopted target
        PendingTarget = nil,       -- requested target to adopt after finishing cycles
        LastTarget = nil,
        _running = true,
        _active = true,
        source = source or "PAA",
        rotating = false,
        smoothedCF = part.CFrame,
        _cyclesRemaining = 0 -- cycles left before allowing adoption of a new pending target
    }

    -- If an initialTarget was supplied (like original script), adopt immediately (unless ignored above)
    if initialTarget and initialTarget.Parent and initialTarget ~= localPlayer and not isWhitelisted(initialTarget) then
        bh.TargetPlayer = initialTarget
        bh.PendingTarget = nil
        bh._cyclesRemaining = 3 -- preserve 3-cycle lock even for immediate adoption
        bh.LastTarget = nil
        -- instant snap on creation
        pcall(function()
            local c = bh.TargetPlayer.Character
            if c and c:FindFirstChild("HumanoidRootPart") and bh.Attachment then
                bh.Attachment.WorldCFrame = c.HumanoidRootPart.CFrame
                bh.smoothedCF = bh.Attachment.WorldCFrame
            elseif c and c:FindFirstChild("Head") and bh.Attachment then
                bh.Attachment.WorldCFrame = c.Head.CFrame
                bh.smoothedCF = bh.Attachment.WorldCFrame
            end
        end)
    else
        -- if initial target not adopted, mark as pending if we allowed whitelisted initialTarget via special source
        if initialTarget and source == "CMD_ALLOW_WHITELISTED" then
            bh.PendingTarget = initialTarget
        else
            bh.PendingTarget = nil
        end
    end

    local function isPlayerDisabled(pl)
        if not pl then return false end
        if pl:FindFirstChild("Disabled") and typeof(pl.Disabled.Value) == "boolean" then
            return pl.Disabled.Value
        end
        return false
    end

    -- BH behavior thread (deterministic forward/back skidding with 3-cycle lock)
    bh._thread = spawn(function()
        local angle = 0
        while bh._running do
            local dt = RunService.Heartbeat:Wait()

            -- If a pending target exists and we currently have no target, adopt it immediately and set cycle lock
            if bh.PendingTarget and (not bh.TargetPlayer) and bh.PendingTarget ~= localPlayer and not isWhitelisted(bh.PendingTarget) and isPlayerAlive(bh.PendingTarget) then
                -- adopt pending target now
                bh.TargetPlayer = bh.PendingTarget
                bh.PendingTarget = nil
                bh._cyclesRemaining = 3 -- require 3 full cycles before switching again
                bh.LastTarget = nil
                -- instant snap to reduce startup lag
                pcall(function()
                    local c = bh.TargetPlayer.Character
                    if c and c:FindFirstChild("HumanoidRootPart") and bh.Attachment then
                        bh.Attachment.WorldCFrame = c.HumanoidRootPart.CFrame
                        bh.smoothedCF = bh.Attachment.WorldCFrame
                    elseif c and c:FindFirstChild("Head") and bh.Attachment then
                        bh.Attachment.WorldCFrame = c.Head.CFrame
                        bh.smoothedCF = bh.Attachment.WorldCFrame
                    end
                end)
            end

            if bh.TargetPlayer and bh.TargetPlayer ~= localPlayer and not isWhitelisted(bh.TargetPlayer) and isPlayerAlive(bh.TargetPlayer) then
                if isPlayerDisabled(bh.TargetPlayer) then
                    setBlackHoleActiveState(bh, false)
                else
                    setBlackHoleActiveState(bh, true)

                    local char = bh.TargetPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        local hrp = char.HumanoidRootPart
                        local pos = hrp.Position
                        local vel = hrp.Velocity or Vector3.new(0,0,0)
                        local now = tick()

                        -- prediction uses cached snapshots (0.3s) when necessary
                        local predictedPos, leadFactor, accel = predictTargetPosition(bh.TargetPlayer, pos, vel, now)

                        local speed = vel.Magnitude

                        -- movement direction or facing
                        local dir
                        local humanoid = char:FindFirstChildOfClass("Humanoid")
                        if humanoid and typeof(humanoid.MoveDirection) == "Vector3" and humanoid.MoveDirection.Magnitude > 0.01 then
                            local md = humanoid.MoveDirection
                            dir = Vector3.new(md.X, 0, md.Z)
                            if dir.Magnitude > 0.001 then dir = dir.Unit else dir = hrp.CFrame.LookVector end
                        else
                            local lv = hrp.CFrame.LookVector
                            dir = Vector3.new(lv.X, 0, lv.Z)
                            if dir.Magnitude > 0.001 then dir = dir.Unit else dir = Vector3.new(0,0,1) end
                        end

                        -- EXACT half-length = speed (so total skid = 2*speed). enforce small minimum.
                        local halfLen = speed
                        if halfLen < 0.5 then halfLen = 0.5 end

                        -- predicted center (small lead to counter ping)
                        local baseLead = 0.08 + (speed * 0.02)
                        local pingLead = estimatedPing * 0.9
                        local leadTime = clamp(baseLead + pingLead, 0.05, 1.2)
                        local centerPos = pos + vel * leadTime + 0.5 * accel * (leadTime * leadTime)

                        -- forward / back endpoints
                        local forwardPoint = centerPos + dir * halfLen
                        local backPoint    = centerPos - dir * halfLen

                        -- small rotating perpendicular component (gives 360 coverage over cycles)
                        local perpRadius = halfLen * 0.25
                        local perp = (hrp.CFrame.RightVector * math.cos(angle) + hrp.CFrame.UpVector * math.sin(angle)) * perpRadius

                        -- if player is jumping upward, add upward bias to increase hit chance
                        if hrp.Velocity.Y > 1 then
                            perp = perp + Vector3.new(0, halfLen * 0.5, 0)
                        end

                        forwardPoint = forwardPoint + perp
                        backPoint    = backPoint  - perp

                        local lookForward = centerPos + dir
                        local lookBack    = centerPos - dir

                        -- perform forward then back (one full skid cycle = forward+back)
                        if bh.Attachment then
                            bh.Attachment.WorldCFrame = CFrame.new(forwardPoint, lookForward)
                        else
                            bh.Part.CFrame = CFrame.new(forwardPoint, lookForward)
                        end

                        wait(0.1)

                        if bh.Attachment then
                            bh.Attachment.WorldCFrame = CFrame.new(backPoint, lookBack)
                        else
                            bh.Part.CFrame = CFrame.new(backPoint, lookBack)
                        end

                        wait(0.1)

                        -- completed one full skid cycle; decrement cyclesRemaining if >0
                        if bh._cyclesRemaining and bh._cyclesRemaining > 0 then
                            bh._cyclesRemaining = bh._cyclesRemaining - 1
                        end

                        -- if cyclesRemaining reached zero and there is a pending different target, adopt it now
                        if (not bh._cyclesRemaining or bh._cyclesRemaining <= 0) and bh.PendingTarget and bh.PendingTarget ~= bh.TargetPlayer then
                            -- adopt pending
                            local newT = bh.PendingTarget
                            bh.PendingTarget = nil
                            bh.TargetPlayer = newT
                            bh._cyclesRemaining = 3
                            bh.LastTarget = nil
                            pcall(function()
                                local c = newT and newT.Character
                                if c and c:FindFirstChild("HumanoidRootPart") and bh.Attachment then
                                    bh.Attachment.WorldCFrame = c.HumanoidRootPart.CFrame
                                    bh.smoothedCF = bh.Attachment.WorldCFrame
                                elseif c and c:FindFirstChild("Head") and bh.Attachment then
                                    bh.Attachment.WorldCFrame = c.Head.CFrame
                                    bh.smoothedCF = bh.Attachment.WorldCFrame
                                end
                            end)
                        end

                        -- advance angle a bit (progress the 360 sweep across cycles)
                        angle = angle + (math.pi / 6)
                    end
                end
            else
                -- idle behavior near Attachment1 (also adopt pending target immediately when idle)
                setBlackHoleActiveState(bh, false)

                -- adopt pending immediately if we are idle and pending is valid
                if bh.PendingTarget and not bh.TargetPlayer and bh.PendingTarget ~= localPlayer and not isWhitelisted(bh.PendingTarget) and isPlayerAlive(bh.PendingTarget) then
                    bh.TargetPlayer = bh.PendingTarget
                    bh.PendingTarget = nil
                    bh._cyclesRemaining = 3
                    bh.LastTarget = nil
                    pcall(function()
                        local c = bh.TargetPlayer.Character
                        if c and c:FindFirstChild("HumanoidRootPart") and bh.Attachment then
                            bh.Attachment.WorldCFrame = c.HumanoidRootPart.CFrame
                            bh.smoothedCF = bh.Attachment.WorldCFrame
                        elseif c and c:FindFirstChild("Head") and bh.Attachment then
                            bh.Attachment.WorldCFrame = c.Head.CFrame
                            bh.smoothedCF = bh.Attachment.WorldCFrame
                        end
                    end)
                else
                    if Attachment1 and Attachment1.Parent and bh.Attachment then
                        local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                        local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame
                        local centerCF
                        pcall(function() centerCF = Attachment1.WorldCFrame end)
                        if centerCF then
                            bh.smoothedCF = curCF:Lerp(centerCF, 1 - math.exp(- (SKID_SMOOTHNESS * 1.2) * dt))
                            bh.Attachment.WorldCFrame = bh.smoothedCF
                        end
                    end
                    wait(0.06)
                end
            end
        end
    end)

    table.insert(extraBlackHoles, bh)
    return bh
end

local function destroyExtraBlackHole(bh)
    if not bh then return end
    bh._running = false
    if bh.Part and bh.Part.Parent then bh.Part:Destroy() end
    for _, p in ipairs(bh.AssignedParts) do
        if p and p.Parent then
            local ap = p:FindFirstChildOfClass("AlignPosition")
            if ap then ap.Attachment1 = Attachment1 end
            p.CanCollide = false
            if initiallyMasslessParts[p] ~= nil then
                pcall(function() p.Massless = initiallyMasslessParts[p] end)
            else
                pcall(function() p.Massless = false end)
            end
        end
    end
end

local function deleteBHsBySource(source)
    for i = #extraBlackHoles, 1, -1 do
        local bh = extraBlackHoles[i]
        if bh and bh.source == source then
            destroyExtraBlackHole(bh)
            table.remove(extraBlackHoles, i)
        end
    end
end

local function deleteAllExtraBlackHoles()
    for _, bh in ipairs(extraBlackHoles) do destroyExtraBlackHole(bh) end
    extraBlackHoles = {}
    if not Attachment1 or not Attachment1.Parent then Attachment1 = setupPlayer() end
    stopRebalancer()
end

-- rotating/distribution code: use PendingTarget instead of setting TargetPlayer immediately
local rotatingCoroutine = nil
local rotatingActive = false
local function stopRotatingCoroutine()
    rotatingActive = false
    rotatingCoroutine = nil
end

local function distributeBHListEvenly(bhList, players)
    for _, bh in ipairs(bhList) do
        bh.rotating = false
        bh.TargetPlayer = bh.TargetPlayer -- keep current until cycles finish
        bh.PendingTarget = bh.PendingTarget
        bh.AssignedParts = {}
    end

    if #players == 0 then
        for _, bh in ipairs(bhList) do
            bh.PendingTarget = nil
            bh.TargetPlayer = nil
            setBlackHoleActiveState(bh, false)
        end
        stopRotatingCoroutine()
        return
    end

    local totalBH = #bhList
    local playerCount = #players
    -- If there are more BHs than players, mark extras as rotating/idle to avoid replicating target creation
    -- (we won't create more PAA BHs than players in refreshPAA)
    local base = math.floor(totalBH / playerCount)
    local remainder = totalBH - (base * playerCount)

    -- assign base distribution: set PendingTarget for each BH slot
    local idx = 1
    for pi = 1, playerCount do
        local pl = players[pi]
        for k = 1, base do
            if bhList[idx] then
                bhList[idx].PendingTarget = pl
                setBlackHoleActiveState(bhList[idx], true)
                if pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") and bhList[idx].Attachment and (not bhList[idx].TargetPlayer) then
                    pcall(function() bhList[idx].Attachment.WorldCFrame = pl.Character.HumanoidRootPart.CFrame end)
                end
                idx = idx + 1
            end
        end
    end

    -- remaining BHs rotate among players
    local rotatingBHs = {}
    for r = 1, remainder do
        if bhList[idx] then
            bhList[idx].rotating = true
            bhList[idx].PendingTarget = nil
            bhList[idx].TargetPlayer = nil
            setBlackHoleActiveState(bhList[idx], true)
            table.insert(rotatingBHs, bhList[idx])
            idx = idx + 1
        end
    end

    stopRotatingCoroutine()
    if #rotatingBHs == 0 then return end

    rotatingActive = true
    rotatingCoroutine = spawn(function()
        local posIndex = 1
        while rotatingActive do
            -- pick alive non-whitelisted players
            local curPlayers = {}
            for _, pl in ipairs(players) do
                if pl and pl.Parent and isPlayerAlive(pl) and not isWhitelisted(pl) and pl ~= localPlayer then
                    table.insert(curPlayers, pl)
                end
            end
            if #curPlayers == 0 then
                for _, rb in ipairs(rotatingBHs) do
                    rb.PendingTarget = nil
                    rb.TargetPlayer = nil
                    setBlackHoleActiveState(rb, false)
                end
                break
            end

            for _, rb in ipairs(rotatingBHs) do
                local pick = curPlayers[((posIndex - 1) % #curPlayers) + 1]
                if pick and not isWhitelisted(pick) and pick ~= localPlayer and isPlayerAlive(pick) then
                    rb.PendingTarget = pick
                    setBlackHoleActiveState(rb, true)
                else
                    rb.PendingTarget = nil
                    rb.TargetPlayer = nil
                    setBlackHoleActiveState(rb, false)
                end
                posIndex = posIndex + 1
            end

            wait(ROTATE_INTERVAL)
        end
    end)
end

-- PAA assignment: create at most one PAA BH per target player (prevents replication)
local function refreshPAA()
    -- Identify targets
    local targets = {}
    if LifeCycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(targets, pl)
            end
        end
    else
        if PAA_isUsingSelected then
            targets = getSelectedPlayers(true)
        else
            targets = getAllNonLocalPlayers()
        end
    end

    -- Remove existing PAA BHs that no longer correspond to a valid target
    local existingPAA = getBHsBySource("PAA")
    -- build map of player -> count existing
    local existsFor = {}
    for _, bh in ipairs(existingPAA) do
        if bh.TargetPlayer and bh.TargetPlayer.Parent then
            existsFor[bh.TargetPlayer] = (existsFor[bh.TargetPlayer] or 0) + 1
        elseif bh.PendingTarget and bh.PendingTarget.Parent then
            existsFor[bh.PendingTarget] = (existsFor[bh.PendingTarget] or 0) + 1
        end
    end

    -- Create or remove BHs so that at most one PAA BH per target exists
    -- First, ensure we have no duplicates for the same target
    for i = #existingPAA, 1, -1 do
        local bh = existingPAA[i]
        local inTargets = false
        for _, t in ipairs(targets) do
            if (bh.TargetPlayer == t) or (bh.PendingTarget == t) then inTargets = true; break end
        end
        if not inTargets then
            destroyExtraBlackHole(bh)
            for j = 1, #extraBlackHoles do
                if extraBlackHoles[j] == bh then table.remove(extraBlackHoles, j); break end
            end
        end
    end

    -- Re-scan existing PAA BHs after pruning
    existingPAA = getBHsBySource("PAA")
    local assignedMap = {}
    for _, bh in ipairs(existingPAA) do
        if bh.TargetPlayer and bh.TargetPlayer.Parent then assignedMap[bh.TargetPlayer] = true end
        if bh.PendingTarget and bh.PendingTarget.Parent then assignedMap[bh.PendingTarget] = true end
    end

    -- Create BHs only for targets that do not already have one
    for _, tgt in ipairs(targets) do
        if tgt and tgt ~= localPlayer and not isWhitelisted(tgt) then
            if not assignedMap[tgt] then
                -- create one BH for this player
                local newBH = createExtraBlackHole(tgt, "PAA") -- createExtraBlackHole will adopt immediately if valid
                assignedMap[tgt] = true
            end
        end
    end

    -- After ensuring one-per-player, distribute
    local refreshedList = getBHsBySource("PAA")
    assignTargetsForPAA() -- distribution will use PendingTarget when necessary
    if #extraBlackHoles > 0 then startRebalancer() end
end

local function onPlayerAddedForPAA(pl)
    if PAAEnabled and not PAA_isUsingSelected and pl ~= localPlayer and not isWhitelisted(pl) then
        if LifeCycleMode and cycleActive then
            return
        end
        -- create one PAA BH for this player only if not already present
        local paaBHs = getBHsBySource("PAA")
        local exists = false
        for _, bh in ipairs(paaBHs) do
            if bh.TargetPlayer == pl or bh.PendingTarget == pl then exists = true; break end
        end
        if not exists then
            local bh = createExtraBlackHole(pl, "PAA")
            bh.PendingTarget = nil -- initialTarget adopted in createExtraBlackHole
            bh.LastTarget = nil
            assignTargetsForPAA()
        end
    end
end

local function onPlayerRemovingForPAA(pl)
    if PAAEnabled then
        for i = #extraBlackHoles, 1, -1 do
            local bh = extraBlackHoles[i]
            if bh and bh.source == "PAA" and (bh.TargetPlayer == pl or bh.PendingTarget == pl) then
                destroyExtraBlackHole(bh)
                table.remove(extraBlackHoles, i)
                break
            end
        end
        assignTargetsForPAA()
    end
end

-- LifeCycle / rebalancer and other management functions (unchanged logic, but rebalancer does less work when idle)
local function clearCycleConnections()
    for _, conn in ipairs(cycleConns) do
        if conn and conn.Disconnect then
            pcall(function() conn:Disconnect() end)
        end
    end
    cycleConns = {}
end

local function stopCycle()
    cycleActive = false
    cyclePlayers = {}
    cycleDead = {}
    clearCycleConnections()
    cycleRestartPending = false
end

local function checkCycleCompletionAndMaybeRestart()
    if not cycleActive then return end
    if #cyclePlayers == 0 then
        cycleRestartPending = true
        return
    end
    for _, pl in ipairs(cyclePlayers) do
        if not cycleDead[pl] then
            return
        end
    end
    cycleRestartPending = true
end

local function scheduleCycleRestart()
    if cycleRestartPending then
        cycleRestartPending = false
        spawn(function()
            wait(0.12)
            local newSnapshot = {}
            if targetSelectedActive then
                newSnapshot = getSelectedPlayers(false)
            else
                newSnapshot = getAllNonLocalPlayers()
            end
            cyclePlayers = {}
            cycleDead = {}
            for _, pl in ipairs(newSnapshot) do
                if pl and pl.Parent and pl ~= localPlayer then
                    cyclePlayers[#cyclePlayers+1] = pl
                    cycleDead[pl] = false
                end
            end
            clearCycleConnections()
            for _, pl in ipairs(cyclePlayers) do
                if pl and pl.Parent then
                    local function onHumanoidAdded(char)
                        local hum = char:FindFirstChildOfClass("Humanoid")
                        if hum then
                            local dconn = hum.Died:Connect(function()
                                cycleDead[pl] = true
                                assignTargetsForPAA()
                                assignTargetsForCMD()
                                checkCycleCompletionAndMaybeRestart()
                            end)
                            table.insert(cycleConns, dconn)
                        end
                    end
                    if pl.Character then
                        onHumanoidAdded(pl.Character)
                    end
                    local cconn = pl.CharacterAdded:Connect(onHumanoidAdded)
                    table.insert(cycleConns, cconn)
                    local rconn = pl.AncestryChanged:Connect(function()
                        if not pl.Parent then
                            for i = #cyclePlayers, 1, -1 do
                                if cyclePlayers[i] == pl then table.remove(cyclePlayers, i) end
                            end
                            cycleDead[pl] = true
                            assignTargetsForPAA()
                            assignTargetsForCMD()
                            checkCycleCompletionAndMaybeRestart()
                        end
                    end)
                    table.insert(cycleConns, rconn)
                end
            end
            assignTargetsForPAA()
            assignTargetsForCMD()
        end)
    end
end

local function startCycleSnapshot()
    stopCycle()
    cycleActive = true
    cyclePlayers = {}
    cycleDead = {}

    local snapshot = {}
    if targetSelectedActive then
        snapshot = getSelectedPlayers(false)
    else
        snapshot = getAllNonLocalPlayers()
    end

    for _, pl in ipairs(snapshot) do
        if pl and pl.Parent and pl ~= localPlayer then
            cyclePlayers[#cyclePlayers+1] = pl
            cycleDead[pl] = false
        end
    end

    clearCycleConnections()
    for _, pl in ipairs(cyclePlayers) do
        if pl and pl.Parent then
            local function attachHumanoidWatcher(char)
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    local dconn = hum.Died:Connect(function()
                        cycleDead[pl] = true
                        assignTargetsForPAA()
                        assignTargetsForCMD()
                        checkCycleCompletionAndMaybeRestart()
                        scheduleCycleRestart()
                    end)
                    table.insert(cycleConns, dconn)
                end
            end
            if pl.Character then attachHumanoidWatcher(pl.Character) end
            local cconn = pl.CharacterAdded:Connect(attachHumanoidWatcher)
            table.insert(cycleConns, cconn)
            local rconn = pl.AncestryChanged:Connect(function()
                if not pl.Parent then
                    for i = #cyclePlayers, 1, -1 do
                        if cyclePlayers[i] == pl then table.remove(cyclePlayers, i) end
                    end
                    cycleDead[pl] = true
                    assignTargetsForPAA()
                    assignTargetsForCMD()
                    checkCycleCompletionAndMaybeRestart()
                    scheduleCycleRestart()
                end
            end)
            table.insert(cycleConns, rconn)
        end
    end

    assignTargetsForPAA()
    assignTargetsForCMD()
end

function startRebalancer()
    if rebalancerRunning then return end
    rebalancerRunning = true
    spawn(function()
        while rebalancerRunning do
            -- light guard: only do heavier rebalancing if we actually have BHs or processedParts
            if #extraBlackHoles == 0 then
                rebalancerRunning = false
                break
            end

            local bhCount = #extraBlackHoles
            local parts = {}
            for p, _ in pairs(processedParts) do
                if p and p.Parent then
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then
                        pcall(function()
                            local isMass = (pcall(function() return p.Massless end) and p.Massless)
                            ap.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                            ap.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                        end)
                        table.insert(parts, p)
                    else
                        ForcePart(p)
                        local ap2 = p:FindFirstChildOfClass("AlignPosition")
                        if ap2 then
                            pcall(function()
                                local isMass = (pcall(function() return p.Massless end) and p.Massless)
                                ap2.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                                ap2.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                            end)
                            table.insert(parts, p)
                        end
                    end
                else
                    -- purge stale entries
                    processedParts[p] = nil
                    initiallyMasslessParts[p] = nil
                    initiallyAnchoredParts[p] = nil
                    if partConns[p] then
                        pcall(function() partConns[p]:Disconnect() end)
                        partConns[p] = nil
                    end
                    flingCooldowns[p] = nil
                end
            end

            if bhCount > 0 and #parts > 0 then
                local total = #parts
                local base = math.floor(total / bhCount)
                local rem = total - (base * bhCount)
                local counts = {}
                for i = 1, bhCount do counts[i] = base + (i <= rem and 1 or 0) end

                local partIndex = 1
                for i = 1, bhCount do
                    local bh = extraBlackHoles[i]
                    local need = counts[i]
                    for c = 1, need do
                        local p = parts[partIndex]
                        if not p then break end
                        local ap = p:FindFirstChildOfClass("AlignPosition")
                        if ap then
                            if bh and bh.Attachment and bh._active then
                                ap.Attachment1 = bh.Attachment
                                p.CanCollide = false
                                table.insert(bh.AssignedParts, p)
                            else
                                ap.Attachment1 = Attachment1
                                p.CanCollide = false
                            end
                        end
                        partIndex = partIndex + 1
                    end
                end
            else
                for _, p in ipairs(parts) do
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then ap.Attachment1 = Attachment1; p.CanCollide = false end
                end
            end

            if PAAEnabled then assignTargetsForPAA() end
            assignTargetsForCMD()

            if cycleRestartPending then
                scheduleCycleRestart()
            end

            wait(rebalancerFreq)
        end
    end)
end

function stopRebalancer() rebalancerRunning = false end

-- RESPawn safety: when local player is removed/added, clear processed parts & stop descendant updates
localPlayer.CharacterRemoving:Connect(function()
    -- Stop unanchor timer and descendant listener to avoid touching parts during respawn
    unanchorTimerRunning = false
    if descendantAddedConn then
        pcall(function() descendantAddedConn:Disconnect() end)
        descendantAddedConn = nil
    end
    -- Clear processed parts and disconnect per-part listeners
    clearProcessedParts()
    lastAttachment1Target = nil
end)

local function onCharacterAdded(character)
    -- Ensure we start fresh after respawn
    processedParts = {}
    initiallyAnchoredParts = {}
    initiallyMasslessParts = {}
    -- Disconnect per-part conns safe-guard (clearProcessedParts already did but double safe)
    for p, conn in pairs(partConns) do
        pcall(function() conn:Disconnect() end)
        partConns[p] = nil
    end
    -- Recreate Attachment1 if needed
    if not Attachment1 or not Attachment1.Parent then Attachment1 = setupPlayer() end

    -- Re-enable processing
    processWorkspaceParts()
end
Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

-- Primary loop (Attachment1 follows target; instant snap when target changes + fixed skid)
local function startPrimaryLoop()
    if primaryLoopRunning then return end
    primaryLoopRunning = true
    if not Attachment1 or not Attachment1.Parent then Attachment1 = setupPlayer() end
    anchoredOnce = false
    processWorkspaceParts()

    spawn(function()
        local phaseT = 0
        local lastHeartbeat = tick()
        while targetAllActive or targetSelectedActive do
            local now = tick()
            local dt = now - lastHeartbeat
            lastHeartbeat = now
            phaseT = phaseT + dt

            local targetPlayer = nil
            if targetSelectedActive then
                local selectedPlayers = getSelectedPlayers(true)
                if #selectedPlayers > 0 then
                    targetPlayer = selectedPlayers[math.random(1, #selectedPlayers)]
                else
                    targetPlayer = nil
                end
            elseif targetAllActive then
                targetPlayer = getRandomPlayer()
            else
                targetPlayer = nil
            end

            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and isPlayerAlive(targetPlayer) then
                local hrp = targetPlayer.Character.HumanoidRootPart
                local pos = hrp.Position
                local vel = hrp.Velocity or Vector3.new(0,0,0)
                local nowt = tick()

                -- If attachment1 target changed, instantly teleport Attachment1 to HRP to avoid startup lag
                if lastAttachment1Target ~= targetPlayer then
                    lastAttachment1Target = targetPlayer
                    pcall(function()
                        if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            Attachment1.WorldCFrame = targetPlayer.Character.HumanoidRootPart.CFrame
                        elseif targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
                            Attachment1.WorldCFrame = targetPlayer.Character.Head.CFrame
                        end
                    end)
                end

                -- improved prediction for central Attachment1 movement
                local predictedPos, _, accel = predictTargetPosition(targetPlayer, pos, vel, nowt)

                local speed = vel.Magnitude
                local baseLead = 0.08 + (speed * 0.02)
                local leadTime = clamp(baseLead + estimatedPing * 0.9, 0.05, 1.2)
                predictedPos = pos + vel * leadTime + 0.5 * accel * (leadTime * leadTime)

                -- if jump/fall, bias vertical toward head (reduces ping vertical jitter)
                local head = targetPlayer.Character:FindFirstChild("Head")
                if head and math.abs(vel.Y) > 3 then
                    predictedPos = Vector3.new(predictedPos.X, head.Position.Y, predictedPos.Z)
                end

                -- Prefer humanoid.MoveDirection when available (turn detection)
                local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                local moveDir = Vector3.new(0,0,0)
                if humanoid and typeof(humanoid.MoveDirection) == "Vector3" and humanoid.MoveDirection.Magnitude > 0.01 then
                    moveDir = humanoid.MoveDirection
                else
                    moveDir = Vector3.new(vel.X, 0, vel.Z)
                end

                local horiz = Vector3.new(moveDir.X, 0, moveDir.Z)
                if horiz.Magnitude < 0.5 then
                    local look = hrp.CFrame.LookVector
                    horiz = Vector3.new(look.X, 0, look.Z)
                end
                local dir = (horiz.Magnitude > 0.001) and horiz.Unit or Vector3.new(0,0,1)

                local skidAmplitude = math.max(0.5, speed * 0.5)
                if estimatedPing > 0.15 then skidAmplitude = skidAmplitude * (1 + (estimatedPing - 0.15)) end

                local baseFreq = 6.5
                local freq = baseFreq + (speed * 2.2) - (estimatedPing * 1.5)
                if freq < 3 then freq = 3 end

                local phase = phaseT * (2 * math.pi * freq)
                local s = math.sin(phase)
                local signS = (s >= 0) and 1 or -1
                local bias = signS * (1 - math.pow((1 - math.abs(s)), 0.85))

                local offset = dir * (bias * skidAmplitude)
                local verticalAmp = clamp(skidAmplitude * 0.35, 0.2, 6)
                local verticalOffset = Vector3.new(0, math.sin(phase * 0.9) * verticalAmp * 0.35, 0)

                local desiredPos = predictedPos + offset + verticalOffset
                local lookAhead = predictedPos + dir * math.max(1, speed * 0.6) + Vector3.new(0, 0.1, 0)
                local targetCFrame = CFrame.new(desiredPos, lookAhead)

                if Attachment1 then
                    local success, cur = pcall(function() return Attachment1.WorldCFrame end)
                    local curCF = success and cur or Attachment1.WorldCFrame or hrp.CFrame

                    local effectiveSmooth = SKID_SMOOTHNESS * (1 + speed * 0.85)
                    if effectiveSmooth < 3.0 then effectiveSmooth = 3.0 end
                    local skidAlpha = 1 - math.exp(-effectiveSmooth * dt)
                    if skidAlpha < 0.02 then skidAlpha = 0.02 end
                    if skidAlpha > 0.999 then skidAlpha = 0.999 end

                    Attachment1.WorldCFrame = smoothLerpCFrame(curCF, targetCFrame, dt)
                end
            else
                -- if no valid target, reset lastAttachment1Target so next assignment snaps
                lastAttachment1Target = nil
            end

            wait(switchDelay)
        end

        primaryLoopRunning = false
        if unanchorTimerRunning and unanchorCoroutine then
            unanchorTimerRunning = false
            for part, anchored in pairs(initiallyAnchoredParts) do
                if part and part.Parent and anchored == false then
                    part.Anchored = false
                    ForcePart(part)
                end
            end
        end
        clearProcessedParts()

        if PAAEnabled then deleteBHsBySource("PAA") end
    end)
end

local function setTargetAll(value)
    targetAllActive = value
    if (targetAllActive or targetSelectedActive) then startPrimaryLoop() end

    if LifeCycleMode then
        if targetAllActive then
            tryStartCycleIfNeeded()
        else
            stopCycle()
        end
    end

    if PAAEnabled then
        if targetAllActive then
            PAA_isUsingSelected = false
            refreshPAA()
            if #paaConnections == 0 then
                paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
                paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
            end
        else
            deleteBHsBySource("PAA")
        end
    end
end

local function setTargetSelected(value)
    targetSelectedActive = value
    if (targetAllActive or targetSelectedActive) then startPrimaryLoop() end

    if LifeCycleMode then
        if targetSelectedActive then
            tryStartCycleIfNeeded()
        else
            stopCycle()
        end
    end

    if PAAEnabled then
        if targetSelectedActive then
            PAA_isUsingSelected = true
            refreshPAA()
            if #paaConnections == 0 then
                paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
                paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
            end
        else
            deleteBHsBySource("PAA")
        end
    end
end

-- GUI (TurtleLib) - toggles/buttons only; loop check timing updated to 3s
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/miroeramaa/TurtleLib/main/TurtleUiLib.lua"))()
local window = library:Window("Fix it you panis negor🗣🔥")

window:Toggle("Unanchored Target All", false, function(Value) setTargetAll(Value) end)
window:Toggle("Target Selected Players", false, function(Value) setTargetSelected(Value) end)

window:Button("Load Player List Script", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/Udklol/refs/heads/main/Playerlistv6"))()
end)
window:Button("telekinesis/fix target", function()
    loadstring(game:HttpGet(('https://raw.githubusercontent.com/SAZXHUB/Control-update/main/README.md'), true))()
end)

local loopCheckActive = false
window:Toggle("Continuous Loop Check", false, function(Value)
    loopCheckActive = Value
    if loopCheckActive then
        spawn(function()
            while loopCheckActive do
                if targetAllActive or targetSelectedActive then
                    for _, v in ipairs(Workspace:GetDescendants()) do
                        if v:IsA("BasePart") and not v.Anchored and not processedParts[v] and not isPartPlayerCharacter(v) and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
                            if initiallyMasslessParts[v] == nil then pcall(function() initiallyMasslessParts[v] = v.Massless end) end
                            pcall(function() v.Massless = true end)
                            ForcePart(v)
                        end
                    end
                end
                wait(3) -- user requested every 3 seconds
            end
        end)
    end
end)

window:Toggle("PAA/unPAA (player amount BHs)", false, function(Value)
    PAAEnabled = Value
    if PAAEnabled then
        PAA_isUsingSelected = false
        refreshPAA()
        paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
        paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
    else
        for _, c in ipairs(paaConnections) do pcall(function() c:Disconnect() end) end
        paaConnections = {}
        deleteBHsBySource("PAA")
    end
end)

-- periodic refresh for PAA (less frequent; ping-friendly)
spawn(function()
    while true do
        if PAAEnabled then
            if PAA_isUsingSelected then
                if targetSelectedActive then refreshPAA() end
            else
                if targetAllActive then refreshPAA() end
            end
        end
        wait(3) -- keep this relatively low-frequency (user asked 3s for checks)
    end
end)

-- rebalancer watchdog (light)
spawn(function()
    while true do
        if #extraBlackHoles > 0 and not rebalancerRunning then startRebalancer()
        elseif #extraBlackHoles == 0 and rebalancerRunning then stopRebalancer() end
        if cycleRestartPending then scheduleCycleRestart() end
        wait(0.5)
    end
end)

-- HUD removed per request

-- End of script
