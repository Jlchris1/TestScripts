-- Blackhole script — updated: attachments follow targets (PAA / Target All / Target Selected)
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer

-- state
local blackHoleActive = false
local toggleState = false
local targetPlayer = nil
local switchDelay = 0.13

-- processedParts: maps part -> attachmentIndex (number)
local processedParts = {}
local initiallyAnchoredParts = {}
local anchoredOnce = false
local unanchorTimerRunning = false
local unanchorCoroutine

local noclipConnection

-- single attachment fallback
local Attachment1 = nil

-- attachments management
local attachmentsFolder = nil
local attachments = {} -- { {Part=part, Attachment=attach, mode="free"|"player"|"single", targetPlayer=player}, ... }
local attachmentsMode = "single" -- "single", "multi", "paa"
local commandConnection = nil
local playerAttachIndex = {} -- player.UserId -> index (for PAA and player-targeted multi)
local targetMode = "random" -- "random" | "all" | "selected" | "paa"

-- scanner control
local selectiveScannerRunning = false
local selectiveScanInterval = 0.25

-- tuning
local anchorHoldDuration = 1 -- seconds (changed per request)
local knockOffDistance = 100 -- studs threshold

-- Setup initial Attachment similar to before
local function setupPlayer()
    local Folder = Instance.new("Folder", Workspace)
    local Part = Instance.new("Part", Folder)
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1
    local Attachment = Instance.new("Attachment", Part)
    return Attachment, Folder
end

Attachment1, attachmentsFolder = setupPlayer()

-- utility
local function clearAttachmentsFolder()
    if attachmentsFolder and attachmentsFolder.Parent then
        attachmentsFolder:Destroy()
    end
    attachmentsFolder = nil
    attachments = {}
    playerAttachIndex = {}
end

local function isNPC(character)
    if not character or not character:IsA("Model") then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and not Players:GetPlayerFromCharacter(character) then
        return true
    end
    return false
end

local function setCharacterCollision(character, canCollide)
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = canCollide
        end
    end
end

local function enableLocalPlayerNoclip(enable)
    if enable then
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        noclipConnection = RunService.Stepped:Connect(function()
            local character = localPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        if part.Name == "HumanoidRootPart" then
                            part.CanCollide = false
                        else
                            part.CanCollide = true
                        end
                    end
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        local character = localPlayer.Character
        if character then
            setCharacterCollision(character, true)
        end
    end
end

-- Helper: count processed parts assigned to a specific attachment index
local function getAttachmentLoad(index)
    local c = 0
    for _, v in pairs(processedParts) do
        if v == index then c = c + 1 end
    end
    return c
end

-- Helper: choose the least-loaded attachment index (optionally restrict to mode == "player")
local function getLeastLoadedAttachmentIndex(restrictPlayerMode)
    if #attachments == 0 then
        return 1
    end
    local bestI, bestLoad = 1, math.huge
    for i, a in ipairs(attachments) do
        if a and a.Attachment then
            if restrictPlayerMode then
                if a.mode ~= "player" then
                    -- skip
                else
                    local load = getAttachmentLoad(i)
                    if load < bestLoad then
                        bestLoad = load
                        bestI = i
                    end
                end
            else
                local load = getAttachmentLoad(i)
                if load < bestLoad then
                    bestLoad = load
                    bestI = i
                end
            end
        end
    end
    return bestI
end

-- Modified ForcePart: assign AlignPosition.Attachment1 depending on attachments mode and least load
local function ForcePart(v)
    if not v or not v:IsA("BasePart") then return end
    if processedParts[v] then return end
    if v.Anchored then return end
    if v.Name == "Handle" then return end
    if v:IsDescendantOf(localPlayer.Character) then return end

    if not (
        (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
        or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
    ) then
        return
    end

    -- choose assignment strategy
    local assignIndex = 1
    if attachmentsMode == "paa" then
        assignIndex = getLeastLoadedAttachmentIndex(true)
    elseif attachmentsMode == "multi" then
        -- prefer attachments that have player targets (so parts follow players)
        assignIndex = getLeastLoadedAttachmentIndex(true)
        -- if none have player mode, fallback to least loaded overall
        if not attachments[assignIndex] or attachments[assignIndex].mode ~= "player" then
            assignIndex = getLeastLoadedAttachmentIndex(false)
        end
    elseif #attachments > 0 then
        assignIndex = getLeastLoadedAttachmentIndex(false)
    end

    -- fallback if chosen attachment missing
    if not attachments[assignIndex] or not attachments[assignIndex].Attachment then
        if Attachment1 then
            processedParts[v] = 1
        else
            -- ensure fallback is present
            local char = localPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                if Attachment1 then Attachment1:Destroy() end
                Attachment1 = Instance.new("Attachment", char.HumanoidRootPart)
            end
            processedParts[v] = 1
        end
    else
        processedParts[v] = assignIndex
    end

    -- cleanup existing physics instances
    for _, x in next, v:GetChildren() do
        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
            or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
            or x:IsA("RocketPropulsion") then
            x:Destroy()
        end
    end
    if v:FindFirstChild("Attachment") then v:FindFirstChild("Attachment"):Destroy() end
    if v:FindFirstChild("AlignPosition") then v:FindFirstChild("AlignPosition"):Destroy() end
    if v:FindFirstChild("Torque") then v:FindFirstChild("Torque"):Destroy() end

    v.CanCollide = false

    local Torque = Instance.new("Torque", v)
    Torque.Torque = Vector3.new(1e6, 1e6, 1e6)
    local AlignPosition = Instance.new("AlignPosition", v)
    local Attachment2 = Instance.new("Attachment", v)
    Torque.Attachment0 = Attachment2
    AlignPosition.MaxForce = math.huge
    AlignPosition.MaxVelocity = math.huge
    AlignPosition.Responsiveness = 500
    AlignPosition.Attachment0 = Attachment2

    if attachments[processedParts[v]] and attachments[processedParts[v]].Attachment then
        AlignPosition.Attachment1 = attachments[processedParts[v]].Attachment
    else
        AlignPosition.Attachment1 = Attachment1
        processedParts[v] = 1
    end
end

local function clearProcessedParts()
    for part, _ in pairs(processedParts) do
        if part and part.Parent then
            for _, x in next, part:GetChildren() do
                if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
                    or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
                    or x:IsA("RocketPropulsion") then
                    x:Destroy()
                end
            end
            if part:FindFirstChild("Attachment") then part:FindFirstChild("Attachment"):Destroy() end
            if part:FindFirstChild("AlignPosition") then part:FindFirstChild("AlignPosition"):Destroy() end
            if part:FindFirstChild("Torque") then part:FindFirstChild("Torque"):Destroy() end
            part.CanCollide = true
            if not initiallyAnchoredParts[part] then
                part.Anchored = false
            else
                part.Anchored = true
            end
        end
    end
    processedParts = {}
    initiallyAnchoredParts = {}
    anchoredOnce = false
end

local function disableCollisionsForCharacterButNotWorldCollision(character)
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

-- anchor + short hold then unanchor + ForcePart
local function anchorAndDelayedUnanchorParts()
    if unanchorTimerRunning then return end
    unanchorTimerRunning = true

    local candidateParts = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart")
            and not v.Anchored
            and v.Name ~= "Handle"
            and not v:IsDescendantOf(localPlayer.Character)
            and (
                (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
            ) then
            table.insert(candidateParts, v)
        end
    end

    initiallyAnchoredParts = {}
    for _, part in ipairs(candidateParts) do
        initiallyAnchoredParts[part] = false
        part.Anchored = true
        part.CanCollide = false
    end

    -- collisions for NPCs
    for _, npcCandidate in ipairs(Workspace:GetChildren()) do
        if isNPC(npcCandidate) then
            disableCollisionsForCharacterButNotWorldCollision(npcCandidate)
        end
    end

    local character = localPlayer.Character
    if character then
        setCharacterCollision(character, true)
    end

    enableLocalPlayerNoclip(true)

    local startTime = tick()
    while blackHoleActive and tick() - startTime < anchorHoldDuration do
        wait(0.05)
    end

    for _, part in ipairs(candidateParts) do
        if part and part.Parent and initiallyAnchoredParts[part] == false then
            part.Anchored = false
            ForcePart(part)
        end
    end

    -- after initial unanchor, keep scanner running to pick more parts (selective scanner handles it)
    unanchorTimerRunning = false
    anchoredOnce = true
end

local descendantAddedConn

local function processWorkspaceParts()
    if descendantAddedConn then
        descendantAddedConn:Disconnect()
        descendantAddedConn = nil
    end

    if blackHoleActive then
        if not unanchorTimerRunning and not anchoredOnce then
            unanchorCoroutine = coroutine.create(anchorAndDelayedUnanchorParts)
            coroutine.resume(unanchorCoroutine)
        end

        descendantAddedConn = Workspace.DescendantAdded:Connect(function(v)
            if blackHoleActive then
                if v:IsA("BasePart") and not v.Anchored and not processedParts[v] then
                    spawn(function()
                        wait(0.02)
                        if blackHoleActive and v and v.Parent and not processedParts[v] then
                            ForcePart(v)
                        end
                    end)
                end
            end
        end)
    end
end

local function getRandomPlayer()
    local players = Players:GetPlayers()
    local validPlayers = {}
    for _, player in pairs(players) do
        if player ~= localPlayer and (not player:FindFirstChild("Whitelisted") or not player.Whitelisted.Value) then
            table.insert(validPlayers, player)
        end
    end
    if #validPlayers > 0 then
        return validPlayers[math.random(1, #validPlayers)]
    end
    return nil
end

local function getSelectedPlayers()
    local players = Players:GetPlayers()
    local selectedPlayers = {}
    for _, player in pairs(players) do
        if player ~= localPlayer and player:FindFirstChild("Selected") and player.Selected.Value then
            table.insert(selectedPlayers, player)
        end
    end
    return selectedPlayers
end

-- rebalance processedParts across attachments
local function rebalanceProcessedParts()
    if #attachments <= 1 then return end
    local list = {}
    for part, _ in pairs(processedParts) do
        if part and part.Parent then table.insert(list, part) end
    end
    local idx = 1
    for _, p in ipairs(list) do
        if p and p.Parent and p:FindFirstChild("AlignPosition") then
            local align = p:FindFirstChild("AlignPosition")
            if attachments[idx] and attachments[idx].Attachment then
                align.Attachment1 = attachments[idx].Attachment
                processedParts[p] = idx
            end
            idx = idx + 1
            if idx > #attachments then idx = 1 end
        end
    end
end

local function createAttachments(count)
    clearAttachmentsFolder()
    attachmentsFolder = Instance.new("Folder", Workspace)
    attachmentsFolder.Name = "ÆS_Attachments_" .. tostring(tick())

    attachments = {}
    count = math.max(1, math.floor(count or 1))

    if count == 1 then
        local char = localPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local newAttachment = Instance.new("Attachment", char.HumanoidRootPart)
            if Attachment1 then Attachment1:Destroy() end
            Attachment1 = newAttachment
            attachmentsMode = "single"
            attachments[1] = { Part = nil, Attachment = Attachment1, mode = "single", targetPlayer = nil }
            return
        end
    end

    for i = 1, count do
        local part = Instance.new("Part", attachmentsFolder)
        part.Anchored = true
        part.CanCollide = false
        part.Transparency = 1
        part.Size = Vector3.new(1,1,1)
        part.Name = "AttachmentPart_" .. i
        local pos = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and localPlayer.Character.HumanoidRootPart.Position or Vector3.new(0,10,0)
        part.CFrame = CFrame.new(pos + Vector3.new(0, i * 2, 0))
        local attach = Instance.new("Attachment", part)
        attachments[i] = { Part = part, Attachment = attach, mode = "free", targetPlayer = nil }
    end

    if Attachment1 and Attachment1.Parent and Attachment1.Parent:IsDescendantOf(Workspace) then
        -- keep
    else
        local char = localPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            if Attachment1 then Attachment1:Destroy() end
            Attachment1 = Instance.new("Attachment", char.HumanoidRootPart)
        end
    end

    attachmentsMode = "multi"

    spawn(function()
        wait(0.05)
        rebalanceProcessedParts()
    end)
end

local function deleteExtraAttachments()
    clearAttachmentsFolder()
    local char = localPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        if Attachment1 then Attachment1:Destroy() end
        Attachment1 = Instance.new("Attachment", char.HumanoidRootPart)
    end
    attachmentsMode = "single"
    clearProcessedParts()
end

local function assignExistingCandidatePartsToAttachments()
    if #attachments <= 1 then return end
    local candidates = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart")
            and not v.Anchored
            and v.Name ~= "Handle"
            and not v:IsDescendantOf(localPlayer.Character)
            and (
                (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
            ) then
            table.insert(candidates, v)
        end
    end

    for _, p in ipairs(candidates) do
        if not processedParts[p] then
            local idx = getLeastLoadedAttachmentIndex(false)
            processedParts[p] = idx
            ForcePart(p)
        end
    end
end

local function monitorCollectedParts()
    spawn(function()
        while blackHoleActive do
            for part, attachIndex in pairs(processedParts) do
                if not part or not part.Parent then
                    processedParts[part] = nil
                else
                    if not attachments[attachIndex] or not attachments[attachIndex].Attachment then
                        processedParts[part] = nil
                    else
                        local attachmentPos = nil
                        if attachments[attachIndex] and attachments[attachIndex].Part and attachments[attachIndex].Part.Parent then
                            attachmentPos = attachments[attachIndex].Part.Position
                        elseif Attachment1 then
                            attachmentPos = Attachment1.WorldPosition
                        end
                        if attachmentPos then
                            local distance = (part.Position - attachmentPos).Magnitude
                            if distance > knockOffDistance then
                                for _, x in next, part:GetChildren() do
                                    if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
                                        or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
                                        or x:IsA("RocketPropulsion") then
                                        x:Destroy()
                                    end
                                end
                                if part:FindFirstChild("Attachment") then part:FindFirstChild("Attachment"):Destroy() end
                                if part:FindFirstChild("AlignPosition") then part:FindFirstChild("AlignPosition"):Destroy() end
                                if part:FindFirstChild("Torque") then part:FindFirstChild("Torque"):Destroy() end
                                part.CanCollide = true
                                processedParts[part] = nil
                            end
                        end
                    end
                end
            end
            wait(0.5)
        end
    end)
end

-- New helper: assign attachments to a list of players (used for Target All and Target Selected)
local function assignAttachmentsToPlayers(playerList)
    -- playerList is an array of Player
    local count = math.max(1, #playerList)
    if count == 1 then
        -- single target: attach to local player's HRP so we can move Attachment1 to the target position
        createAttachments(1)
        attachmentsMode = "single"
        attachments[1].mode = "single"
        attachments[1].targetPlayer = playerList[1]
        playerAttachIndex = {}
        playerAttachIndex[playerList[1].UserId] = 1
        -- move attachment to target immediately if possible
        if playerList[1].Character and playerList[1].Character:FindFirstChild("HumanoidRootPart") then
            Attachment1.WorldCFrame = CFrame.new(playerList[1].Character.HumanoidRootPart.Position)
        end
    else
        createAttachments(count)
        attachmentsMode = "multi"
        playerAttachIndex = {}
        for i, p in ipairs(playerList) do
            if attachments[i] then
                attachments[i].mode = "player"
                attachments[i].targetPlayer = p
                playerAttachIndex[p.UserId] = i
                -- position parts at player's current HRP if available
                if p.Character and p.Character:FindFirstChild("HumanoidRootPart") and attachments[i].Part then
                    attachments[i].Part.CFrame = CFrame.new(p.Character.HumanoidRootPart.Position)
                end
            end
        end
        -- if extra attachments exist (shouldn't) they remain free
    end

    -- assign any already-existing candidate parts to attachments for quick pick-up
    spawn(function()
        wait(0.03)
        assignExistingCandidatePartsToAttachments()
    end)
end

-- PAA helpers
local function enablePAA()
    targetMode = "paa"
    -- create one attachment per other player
    local players = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= localPlayer then table.insert(players, p) end
    end
    local count = math.max(1, #players)
    createAttachments(count)
    attachmentsMode = "paa"

    for i, p in ipairs(players) do
        if attachments[i] then
            attachments[i].mode = "player"
            attachments[i].targetPlayer = p
            playerAttachIndex[p.UserId] = i
        end
    end

    -- ensure player join/leave handled by existing connections (below)
    spawn(function() wait(0.05) rebalanceProcessedParts() end)
    assignExistingCandidatePartsToAttachments()
end

local function onPlayerAddedForPAA(player)
    if attachmentsMode ~= "paa" then return end
    -- add new attachment for new player
    local idx = #attachments + 1
    local part = Instance.new("Part", attachmentsFolder)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1,1,1)
    part.Name = "AttachmentPart_PAA_" .. idx
    local pos = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position or Vector3.new(0,10,0)
    part.CFrame = CFrame.new(pos)
    local attach = Instance.new("Attachment", part)
    attachments[idx] = { Part = part, Attachment = attach, mode = "player", targetPlayer = player }
    playerAttachIndex[player.UserId] = idx

    spawn(function()
        wait(0.05)
        rebalanceProcessedParts()
    end)
end

local function onPlayerRemovingForPAA(player)
    if attachmentsMode ~= "paa" then return end
    local idx = playerAttachIndex[player.UserId]
    if idx and attachments[idx] then
        if attachments[idx].Part and attachments[idx].Part.Parent then
            attachments[idx].Part:Destroy()
        end
        attachments[idx] = nil
        playerAttachIndex[player.UserId] = nil

        -- compact and re-map attachments
        local newList = {}
        for _, v in ipairs(attachments) do
            if v then table.insert(newList, v) end
        end
        attachments = newList
        playerAttachIndex = {}
        for i, v in ipairs(attachments) do
            if v.mode == "player" and v.targetPlayer then
                playerAttachIndex[v.targetPlayer.UserId] = i
            end
        end

        spawn(function()
            wait(0.05)
            rebalanceProcessedParts()
        end)
    end
end

-- update attachments positions
local function updateAttachmentsPositions()
    if attachmentsMode == "single" then
        -- if single mode is used but has targetPlayer set, move Attachment1 to target
        if attachments and attachments[1] and attachments[1].targetPlayer then
            local tp = attachments[1].targetPlayer
            if tp and tp.Character and tp.Character:FindFirstChild("HumanoidRootPart") and Attachment1 then
                Attachment1.WorldCFrame = CFrame.new(tp.Character.HumanoidRootPart.Position)
            end
        end
        return
    elseif attachmentsMode == "multi" or attachmentsMode == "paa" then
        -- primary: follow attachments' assigned targetPlayer if present
        for i, a in ipairs(attachments) do
            if a and a.Attachment and a.Part then
                if a.mode == "player" and a.targetPlayer and a.targetPlayer.Character and a.targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    a.Part.CFrame = CFrame.new(a.targetPlayer.Character.HumanoidRootPart.Position)
                else
                    -- fallback logic: if we are in "all" targetMode and attachments don't have explicit targets, map them to players
                    if targetMode == "all" and (not a.targetPlayer) then
                        local players = Players:GetPlayers()
                        local validPlayers = {}
                        for _, p in ipairs(players) do
                            if p ~= localPlayer and (not p:FindFirstChild("Whitelisted") or not p.Whitelisted.Value) then
                                table.insert(validPlayers, p)
                            end
                        end
                        if #validPlayers > 0 then
                            local p = validPlayers[((i - 1) % #validPlayers) + 1]
                            if p and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                                a.Part.CFrame = CFrame.new(p.Character.HumanoidRootPart.Position)
                            end
                        end
                    else
                        -- place around local player if no explicit targets
                        local basePos = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and localPlayer.Character.HumanoidRootPart.Position or Vector3.new(0,10,0)
                        local off = Vector3.new( (i * 3) % 7, 0, math.floor(i/2) )
                        a.Part.CFrame = CFrame.new(basePos + off)
                    end
                end
            end
        end
    end
end

-- selective scanner
local function startSelectiveScanner()
    if selectiveScannerRunning then return end
    selectiveScannerRunning = true
    spawn(function()
        while blackHoleActive and selectiveScannerRunning do
            for _, v in ipairs(Workspace:GetDescendants()) do
                if not blackHoleActive then break end
                if v:IsA("BasePart")
                    and not v.Anchored
                    and v.Name ~= "Handle"
                    and not v:IsDescendantOf(localPlayer.Character)
                    and not processedParts[v]
                    and (
                        (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                        or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
                    ) then
                    spawn(function()
                        wait(0.01)
                        if blackHoleActive and v and v.Parent and not processedParts[v] then
                            ForcePart(v)
                        end
                    end)
                end
            end
            wait(selectiveScanInterval)
        end
        selectiveScannerRunning = false
    end)
end

local function stopSelectiveScanner()
    selectiveScannerRunning = false
end

-- When players respawn/character added, update attachments mapping/positions
local function onPlayerCharacterAdded(player, character)
    if attachmentsMode == "paa" and playerAttachIndex[player.UserId] then
        local idx = playerAttachIndex[player.UserId]
        if attachments[idx] then
            attachments[idx].targetPlayer = player
            if character and character:FindFirstChild("HumanoidRootPart") and attachments[idx].Part then
                attachments[idx].Part.CFrame = CFrame.new(character.HumanoidRootPart.Position)
            end
            spawn(function()
                wait(0.03)
                rebalanceProcessedParts()
            end)
        end
    elseif attachmentsMode == "multi" then
        -- if this player is in playerAttachIndex (targeted by all/selected), update its part
        local idx = playerAttachIndex[player.UserId]
        if idx and attachments[idx] and attachments[idx].Part and character and character:FindFirstChild("HumanoidRootPart") then
            attachments[idx].Part.CFrame = CFrame.new(character.HumanoidRootPart.Position)
            attachments[idx].targetPlayer = player
            spawn(function()
                wait(0.03)
                rebalanceProcessedParts()
            end)
        end
    elseif attachmentsMode == "single" then
        -- if single attachment has a target and the target respawned, move the single attachment to them
        if attachments and attachments[1] and attachments[1].targetPlayer and attachments[1].targetPlayer == player then
            if character and character:FindFirstChild("HumanoidRootPart") and Attachment1 then
                Attachment1.WorldCFrame = CFrame.new(character.HumanoidRootPart.Position)
            end
        end
    end
end

-- connect players and their character events for detection
local function bindPlayerCharacterEvents(player)
    player.CharacterAdded:Connect(function(char)
        onPlayerCharacterAdded(player, char)
    end)
    if player.Character and player.Character.Parent then
        onPlayerCharacterAdded(player, player.Character)
    end
end

-- initial binding for existing players
for _, p in ipairs(Players:GetPlayers()) do
    bindPlayerCharacterEvents(p)
end
-- bind for future players
Players.PlayerAdded:Connect(function(pl)
    bindPlayerCharacterEvents(pl)
    -- if we are in PAA / all / selected modes, ensure new player is wired
    if attachmentsMode == "paa" then
        onPlayerAddedForPAA(pl)
    elseif targetMode == "all" then
        -- add to attachments (target all should create attachments for everyone)
        -- rebuild assignment to include new player
        local players = {}
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= localPlayer then table.insert(players, player) end
        end
        assignAttachmentsToPlayers(players)
    elseif targetMode == "selected" then
        -- if selected state exists on players, reassign attachments per current selection
        local selected = getSelectedPlayers()
        if #selected > 0 then
            assignAttachmentsToPlayers(selected)
        end
    end
end)

Players.PlayerRemoving:Connect(function(pl)
    -- if PAA mode, remove its attachment
    if attachmentsMode == "paa" then
        onPlayerRemovingForPAA(pl)
    else
        -- if multi/all/selected, remove mapping and rebuild
        if targetMode == "all" or targetMode == "selected" then
            local players = {}
            if targetMode == "all" then
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= localPlayer then table.insert(players, player) end
                end
            else
                players = getSelectedPlayers()
            end
            if #players == 0 then
                -- fallback to single
                deleteExtraAttachments()
            else
                assignAttachmentsToPlayers(players)
            end
        end
    end
end)

-- assign existing parts to attachments if attachments were created
local function assignExistingCandidatePartsToAttachmentsIfNeeded()
    spawn(function()
        wait(0.03)
        assignExistingCandidatePartsToAttachments()
    end)
end

local function monitorSelectedPlayersChanges()
    -- watches selected flag (best-effort): if selected players change while blackhole active & targetMode == "selected", reassign attachments
    spawn(function()
        while blackHoleActive and targetMode == "selected" do
            local selected = getSelectedPlayers()
            if #selected > 0 then
                assignAttachmentsToPlayers(selected)
            else
                -- no selected players -> fallback to single random
                if #attachments > 1 then
                    deleteExtraAttachments()
                end
            end
            wait(1.0)
        end
    end)
end

-- toggle blackhole (Target All)
local function toggleBlackHole()
    blackHoleActive = toggleState
    if blackHoleActive then
        targetMode = "all"
        -- create attachments and map to all players (except local)
        local players = {}
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= localPlayer then table.insert(players, p) end
        end
        if #players == 0 then
            -- no other players -> single attachment fallback
            createAttachments(1)
            attachments[1].mode = "single"
            attachments[1].targetPlayer = nil
            attachmentsMode = "single"
        else
            assignAttachmentsToPlayers(players)
        end

        anchoredOnce = false
        processWorkspaceParts()
        monitorCollectedParts()
        startSelectiveScanner()

        spawn(function()
            while blackHoleActive do
                if attachmentsMode == "single" or #attachments == 0 then
                    targetPlayer = getRandomPlayer()
                    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        if Attachment1 then
                            Attachment1.WorldCFrame = CFrame.new(targetPlayer.Character.HumanoidRootPart.Position)
                        end
                    end
                else
                    updateAttachmentsPositions()
                end
                wait(switchDelay)
            end
        end)
    else
        -- turning off
        blackHoleActive = false
        targetMode = "random"
        enableLocalPlayerNoclip(false)
        stopSelectiveScanner()
        if unanchorTimerRunning and unanchorCoroutine then
            unanchorTimerRunning = false
            for part, anchored in pairs(initiallyAnchoredParts) do
                if part and part.Parent and anchored == false then
                    part.Anchored = false
                    ForcePart(part)
                end
            end
        end
        clearProcessedParts()
    end
end

local function toggleTargetSelected()
    blackHoleActive = toggleState
    if blackHoleActive then
        targetMode = "selected"
        local selectedPlayers = getSelectedPlayers()
        if #selectedPlayers == 0 then
            -- fallback: single random target until selection exists
            createAttachments(1)
            attachments[1].mode = "single"
            attachments[1].targetPlayer = nil
            attachmentsMode = "single"
        else
            assignAttachmentsToPlayers(selectedPlayers)
        end

        anchoredOnce = false
        processWorkspaceParts()
        monitorCollectedParts()
        startSelectiveScanner()
        monitorSelectedPlayersChanges()

        spawn(function()
            while blackHoleActive do
                if attachmentsMode == "single" or #attachments == 0 then
                    -- if single with selection, pick one selected if exists
                    local selected = getSelectedPlayers()
                    if #selected > 0 then
                        targetPlayer = selected[math.random(1, #selected)]
                    else
                        targetPlayer = nil
                    end
                    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        Attachment1.WorldCFrame = CFrame.new(targetPlayer.Character.HumanoidRootPart.Position)
                    end
                else
                    updateAttachmentsPositions()
                end
                wait(switchDelay)
            end
        end)
    else
        blackHoleActive = false
        targetMode = "random"
        enableLocalPlayerNoclip(false)
        stopSelectiveScanner()
        if unanchorTimerRunning and unanchorCoroutine then
            unanchorTimerRunning = false
            for part, anchored in pairs(initiallyAnchoredParts) do
                if part and part.Parent and anchored == false then
                    part.Anchored = false
                    ForcePart(part)
                end
            end
        end
        clearProcessedParts()
    end
end

-- handle when a player's character spawns (ensures attachments map and PAA mapping remain valid)
local function onPlayerCharacterAdded(player, character)
    -- ensure PAA mapping if in PAA mode
    if attachmentsMode == "paa" and playerAttachIndex[player.UserId] then
        local idx = playerAttachIndex[player.UserId]
        if attachments[idx] then
            attachments[idx].targetPlayer = player
            if character and character:FindFirstChild("HumanoidRootPart") and attachments[idx].Part then
                attachments[idx].Part.CFrame = CFrame.new(character.HumanoidRootPart.Position)
            end
            spawn(function()
                wait(0.03)
                rebalanceProcessedParts()
            end)
        end
    else
        -- general handler for multi/single mapping
        if attachmentsMode == "multi" then
            local idx = playerAttachIndex[player.UserId]
            if idx and attachments[idx] and attachments[idx].Part and character and character:FindFirstChild("HumanoidRootPart") then
                attachments[idx].Part.CFrame = CFrame.new(character.HumanoidRootPart.Position)
            end
        elseif attachmentsMode == "single" then
            if attachments and attachments[1] and attachments[1].targetPlayer and attachments[1].targetPlayer == player and character and character:FindFirstChild("HumanoidRootPart") then
                Attachment1.WorldCFrame = CFrame.new(character.HumanoidRootPart.Position)
            end
        end
    end
end

-- connect players and their character events for detection
local function bindPlayerCharacterEvents(player)
    -- safe-connect CharacterAdded
    player.CharacterAdded:Connect(function(char)
        onPlayerCharacterAdded(player, char)
    end)
    -- if character already exists (e.g., joining mid-game) call handler
    if player.Character and player.Character.Parent then
        onPlayerCharacterAdded(player, player.Character)
    end
end

-- initial binding for existing players (again)
for _, p in ipairs(Players:GetPlayers()) do
    bindPlayerCharacterEvents(p)
end

-- PAA player join/leave live updates
Players.PlayerAdded:Connect(function(pl)
    bindPlayerCharacterEvents(pl)
    if attachmentsMode == "paa" then
        onPlayerAddedForPAA(pl)
    end
end)
Players.PlayerRemoving:Connect(function(pl)
    if attachmentsMode == "paa" then
        onPlayerRemovingForPAA(pl)
    end
end)

-- UI library and toggles (keeps your interface, adapted)
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/miroeramaa/TurtleLib/main/TurtleUiLib.lua"))()
local window = library:Window("made by ÆS productions")

window:Toggle("Unanchored Target All", false, function(Value)
    toggleState = Value
    blackHoleActive = Value
    toggleBlackHole()
end)

window:Toggle("Target Selected Players", false, function(Value)
    toggleState = Value
    blackHoleActive = Value
    toggleTargetSelected()
end)

window:Button("Load Player List Script", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/Udklol/refs/heads/main/Playerlistv6"))()
end)

window:Button("telekinesis/fix target", function()
    loadstring(game:HttpGet(('https://raw.githubusercontent.com/SAZXHUB/Control-update/main/README.md'), true))()
end)

-- command integration
local commandEnabled = false
local function handleCommand(msg)
    if not msg then return end
    local attNum = msg:match("^/e%s+attachments%s+(%d+)")
    if attNum then
        local n = tonumber(attNum)
        if n and n >= 1 then
            createAttachments(n)
            assignExistingCandidatePartsToAttachments()
            return
        end
    end
    if msg:match("^/e%s+deleteattachments") then
        deleteExtraAttachments()
        return
    end
    if msg:match("^/e%s+PAA") then
        enablePAA()
        -- wire hooks (already present above)
        Players.PlayerAdded:Connect(function(pl) onPlayerAddedForPAA(pl) end)
        Players.PlayerRemoving:Connect(function(pl) onPlayerRemovingForPAA(pl) end)
        local idx = 1
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= localPlayer then
                playerAttachIndex[p.UserId] = idx
                if attachments[idx] then
                    attachments[idx].mode = "player"
                    attachments[idx].targetPlayer = p
                end
                idx = idx + 1
            end
        end
        spawn(function() wait(0.05) rebalanceProcessedParts() end)
        return
    end
end

window:Toggle("Enable commands", false, function(Value)
    commandEnabled = Value
    if commandEnabled then
        if commandConnection then commandConnection:Disconnect() end
        commandConnection = localPlayer.Chatted:Connect(function(msg)
            if msg:sub(1,3) == "/e " then
                handleCommand(msg)
            end
        end)
    else
        if commandConnection then commandConnection:Disconnect() commandConnection = nil end
    end
end)

-- Keep a local CharacterAdded handler for the local player
local function onCharacterAddedLocal(char)
    onPlayerCharacterAdded(localPlayer, char)
end
localPlayer.CharacterAdded:Connect(onCharacterAddedLocal)

-- heartbeat update
RunService.Heartbeat:Connect(function()
    if blackHoleActive then
        updateAttachmentsPositions()
    end
end)
