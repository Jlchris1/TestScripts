-- Unified NPC GUI - Complete LocalScript
-- Place as a LocalScript in StarterPlayerScripts (replace previous script)
-- Features:
--  - Deterministic Anchor button + Anchor Loop (anchors only)
--  - Anchor loop anchors new NPCs
--  - "unget rid of npcs" button (teleport, unanchor, kill, teleport back)
--  - Removed Erase & Spasm UI entries (Spasm behavior removed)
--  - Main toggle fixed; tabs work reliably
--  - Keeps existing controls like Kill, Fling, PlatformStand, Sit, Cancel-Chase, Void v4, etc.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

-- Helper: get PlayerGui on demand (avoid stale caching)
local function getPlayerGui()
    return player:FindFirstChild("PlayerGui") or player:WaitForChild("PlayerGui")
end

-- CONFIG
local SCAN_INTERVAL = 0.45
local LOOP_DELAY = 0.12
local BTN_H = 26
local SMALL_FONT = 12

-- STATE
local NPCs = {}
setmetatable(NPCs, { __mode = "k" })

local trackedNPCs = {}
setmetatable(trackedNPCs, { __mode = "k" })

local loops = {}
local loopRunners = {}
local anchored = {}            -- models we anchored via our functions
local anchorState = false     -- deterministic global anchor ON/OFF state
local cancelChaseEnabled = false

-- EFFECTS list (removed "Spasm" and "Erase" from UI)
local EFFECTS = {
    "Kill","Fling","PlatformStand","Sit","Anchor","CancelChase","GetRid",
    "Jump","Speed","JumpPower","HipHeight","Tracker","VoidV4"
}

-- UTIL: detect NPC model
local function isNPC(model)
    if not model or not model:IsA("Model") then return false end
    if Players:GetPlayerFromCharacter(model) then return false end
    local hum = model:FindFirstChildOfClass("Humanoid")
    return hum ~= nil
end

-- UTIL: scan workspace for NPCs (humanoids in models)
local function scanAddNPCs()
    for _,desc in ipairs(Workspace:GetDescendants()) do
        if desc:IsA("Humanoid") and desc.Parent and desc.Parent:IsA("Model") then
            local model = desc.Parent
            if isNPC(model) then NPCs[model] = true end
        end
    end
end

local function cleanNPCs()
    for model,_ in pairs(NPCs) do
        if not model or not model.Parent or not isNPC(model) then NPCs[model] = nil end
    end
end

-- Keep NPC table updated
scanAddNPCs()
cleanNPCs()

-- Update NPC list when models/humanoids are added/removed
Workspace.DescendantAdded:Connect(function(obj)
    if obj:IsA("Humanoid") and obj.Parent and obj.Parent:IsA("Model") then
        local model = obj.Parent
        if isNPC(model) then
            NPCs[model] = true
            -- ensure anchor behavior for new NPCs follows anchorState or anchor loop
            pcall(function()
                if anchorState or loops.anchor then
                    -- if anchorState true OR anchor loop active, anchor newly spawned NPC
                    for _,p in ipairs(model:GetDescendants()) do
                        if p:IsA("BasePart") then
                            p.Anchored = true
                        end
                    end
                    anchored[model] = true
                else
                    -- ensure it is unanchored if we think anchorState is off
                    for _,p in ipairs(model:GetDescendants()) do
                        if p:IsA("BasePart") then
                            p.Anchored = false
                        end
                    end
                    anchored[model] = nil
                end
            end)
        end
    end
end)

Workspace.DescendantRemoving:Connect(function(obj)
    if obj:IsA("Humanoid") and obj.Parent and obj.Parent:IsA("Model") then
        NPCs[obj.Parent] = nil
        trackedNPCs[obj.Parent] = nil
    elseif obj:IsA("Model") then
        NPCs[obj] = nil
        trackedNPCs[obj] = nil
    end
end)

-- Helpers
local function iterateParts(model, fn)
    if not model then return end
    for _,p in ipairs(model:GetDescendants()) do
        if p:IsA("BasePart") then
            pcall(function() fn(p) end)
        end
    end
end

local function getNPCsArray()
    local arr = {}
    for model,_ in pairs(NPCs) do
        if model and model.Parent and isNPC(model) then table.insert(arr, model) end
    end
    return arr
end

local function getNPCsByName(name)
    local arr = {}
    for model,_ in pairs(NPCs) do
        if model and model.Parent and model.Name == name and isNPC(model) then table.insert(arr, model) end
    end
    return arr
end

local function getBestPartForModel(model)
    if not model then return nil end
    return model:FindFirstChild("HumanoidRootPart") or model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart", true)
end

-- ACTIONS

-- Kill helper (aggressive)
local function applyDamageSequence(hum)
    if not hum then return end
    pcall(function() hum.Health = 0 end)
    task.wait(0.01)
    pcall(function() hum.Health = 1 end)
    task.wait(0.01)
    pcall(function()
        local ok = pcall(function() hum:TakeDamage(math.huge) end)
        if not ok then pcall(function() hum.Health = -math.huge end) else pcall(function() hum.Health = 0 end) end
    end)
end

local function killAllSimultaneousForList(models)
    local humanoids = {}
    for _,model in ipairs(models) do
        local hum = model:FindFirstChildOfClass("Humanoid")
        if hum then table.insert(humanoids, hum) end
    end
    if #humanoids == 0 then return end
    for _,hum in ipairs(humanoids) do
        pcall(function()
            if hum.BreakJointsOnDeath ~= nil then hum.BreakJointsOnDeath = true end
            hum.Health = 100
        end)
    end
    task.wait(0.04)
    for _,hum in ipairs(humanoids) do
        pcall(function()
            local ok = pcall(function() hum:TakeDamage(math.huge) end)
            if not ok then pcall(function() hum.Health = -math.huge end) else pcall(function() hum.Health = 0 end) end
        end)
    end
end

local function flingModel(model, power)
    power = tonumber(power) or 200
    local localHRP = player.Character and (player.Character:FindFirstChild("HumanoidRootPart") or player.Character.PrimaryPart)
    if not localHRP then return end
    local targetPos
    local hrp = model:FindFirstChild("HumanoidRootPart")
    if hrp and hrp:IsA("BasePart") then targetPos = hrp.Position end
    if not targetPos and model.PrimaryPart and model.PrimaryPart:IsA("BasePart") then targetPos = model.PrimaryPart.Position end
    if not targetPos then
        local anyPart = model:FindFirstChildWhichIsA("BasePart", true)
        if anyPart then targetPos = anyPart.Position end
    end
    if not targetPos then return end
    local dir = targetPos - localHRP.Position
    local dirUnit = (dir.Magnitude <= 0.001) and Vector3.new(0,1,0) or dir.Unit
    local velocity = dirUnit * power + Vector3.new(0, power * 0.45, 0)
    iterateParts(model, function(p)
        if p and not p.Anchored then
            pcall(function()
                if p.AssemblyLinearVelocity ~= nil then p.AssemblyLinearVelocity = velocity else p.Velocity = velocity end
            end)
        end
    end)
end

-- Anchor/unanchor deterministic helpers
local function anchorModel(model)
    if not model then return end
    iterateParts(model, function(p) p.Anchored = true end)
    anchored[model] = true
end

local function unanchorModel(model)
    if not model then return end
    iterateParts(model, function(p) p.Anchored = false end)
    anchored[model] = nil
end

local function toggleAnchor(model)
    if not model then return end
    if anchored[model] then unanchorModel(model) else anchorModel(model) end
end

local function platformStand(model)
    local hum = model and model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.PlatformStand = true end) end
end

local function makeSit(model)
    local hum = model and model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.Sit = true end) end
end

local function jumpModel(model)
    local hum = model and model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.Jump = true end) end
end

local function setHipHeight(model, value)
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.HipHeight = value end) end
end

local function setSpeed(model,val)
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.WalkSpeed = val end) end
end

local function setJumpPower(model,val)
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() if hum.JumpPower ~= nil then hum.JumpPower = val else hum.JumpHeight = val end end) end
end

-- Void v4: drop them down
local function voidV4Model(model, yVel)
    yVel = tonumber(yVel) or -500
    local hum = model and model:FindFirstChildOfClass("Humanoid")
    if hum then pcall(function() hum.PlatformStand = true end) end
    iterateParts(model, function(p)
        pcall(function()
            p.CanCollide = false
            if p.AssemblyLinearVelocity ~= nil then
                p.AssemblyLinearVelocity = Vector3.new(0, yVel, 0)
            else
                p.Velocity = Vector3.new(0, yVel, 0)
            end
        end)
    end)
end

-- Cancel-chase pathfinding helper
local npcPathTasks = setmetatable({}, { __mode = "k" })
local function stopNPCPath(model)
    if not model then return end
    local info = npcPathTasks[model]
    if info and info.cancel then
        pcall(function() info.cancel() end)
    end
    npcPathTasks[model] = nil
end

local function cancelChaseForModel(model)
    if not model or not model.Parent then return end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    local hrp = getBestPartForModel(model)
    if not hrp then return end

    stopNPCPath(model)

    local okHrpPos, hrpPos = pcall(function() return hrp.Position end)
    if not okHrpPos or not hrpPos then return end

    local bestPlayer = nil
    local bestDist = math.huge
    for _,pl in ipairs(Players:GetPlayers()) do
        if pl ~= player then
            local char = pl.Character
            if char and char.PrimaryPart then
                local targetHum = char:FindFirstChildOfClass("Humanoid")
                if targetHum and (targetHum.Health and targetHum.Health > 0) then
                    local okTargetPos, targetPos = pcall(function() return char.PrimaryPart.Position end)
                    if okTargetPos and targetPos then
                        local d = (targetPos - hrpPos).Magnitude
                        if d < bestDist then
                            bestDist = d
                            bestPlayer = pl
                        end
                    end
                end
            end
        end
    end

    if not bestPlayer then return end

    local targetChar = bestPlayer.Character
    if not targetChar or not targetChar.PrimaryPart then return end
    local targetHum = targetChar:FindFirstChildOfClass("Humanoid")
    if not targetHum or (targetHum.Health and targetHum.Health <= 0) then return end

    local okTargetPos, targetPos = pcall(function() return targetChar.PrimaryPart.Position end)
    if not okTargetPos or not targetPos then return end

    local cancelToken = { cancelled = false }
    npcPathTasks[model] = { cancel = function() cancelToken.cancelled = true end }

    coroutine.wrap(function()
        if cancelToken.cancelled then return end
        if not hum or not hum.Parent then return end
        local success, pathOrErr = pcall(function()
            local p = PathfindingService:CreatePath({
                AgentRadius = 2,
                AgentHeight = 5,
                AgentCanJump = true,
                AgentMaxSlope = 45
            })
            p:ComputeAsync(hrp.Position, targetPos)
            return p
        end)
        if not success or not pathOrErr then
            if cancelToken.cancelled then return end
            pcall(function() hum:MoveTo(targetPos) end)
            return
        end
        local path = pathOrErr
        if path.Status ~= Enum.PathStatus.Success then
            if cancelToken.cancelled then return end
            pcall(function() hum:MoveTo(targetPos) end)
            return
        end
        local waypoints = path:GetWaypoints()
        for _,wp in ipairs(waypoints) do
            if cancelToken.cancelled then break end
            if not hum or not hum.Parent or not model or not model.Parent then break end
            if wp.Action == Enum.PathWaypointAction.Jump then pcall(function() hum.Jump = true end) end
            local wpPos = wp.Position
            pcall(function() hum:MoveTo(wpPos) end)
            local reached = false
            local startT = tick()
            while not reached and not cancelToken.cancelled and tick() - startT < 6 do
                if not hum or not hum.Parent or not model or not model.Parent then break end
                local part = getBestPartForModel(model)
                if part and part.Parent then
                    local dist = (part.Position - wpPos).Magnitude
                    if dist <= 4 then reached = true; break end
                end
                task.wait(0.12)
            end
            if cancelToken.cancelled then break end
        end
        npcPathTasks[model] = nil
    end)()
end

-- TRACKER UI (kept)
local function removeTrackerFromModel(model)
    if not model then return end
    local data = trackedNPCs[model]
    if data then
        if data.gui then pcall(function() data.gui:Destroy() end) end
        if data.highlight then pcall(function() data.highlight:Destroy() end) end
        if data._connections then
            for _,c in ipairs(data._connections) do pcall(function() c:Disconnect() end) end
        end
    end
    trackedNPCs[model] = nil
end

local function addTrackerToModel(model)
    if not model then return end
    removeTrackerFromModel(model)
    if not isNPC(model) then return end
    local part = getBestPartForModel(model)
    if not part then return end
    local pg = getPlayerGui()
    if not pg then return end

    local gui = Instance.new("BillboardGui")
    gui.Name = "NPCTracker"
    gui.Size = UDim2.new(0,140,0,32)
    gui.StudsOffset = Vector3.new(0,1.5,0)
    gui.AlwaysOnTop = true
    gui.Adornee = part
    gui.Parent = pg

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1,-4,1,-4)
    label.Position = UDim2.new(0,2,0,2)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.new(1,1,1)
    label.Font = Enum.Font.Code
    label.TextScaled = true
    label.Parent = gui

    local highlight = Instance.new("Highlight")
    highlight.Name = "NPCHighlight"
    highlight.Adornee = model
    highlight.Parent = pg
    highlight.FillTransparency = 1
    highlight.OutlineTransparency = 0
    highlight.OutlineColor = Color3.fromRGB(80,200,120)

    local conns = {}
    local hum = model:FindFirstChildOfClass("Humanoid")
    if hum and hum:IsA("Humanoid") then
        table.insert(conns, hum.Died:Connect(function() removeTrackerFromModel(model) end))
    end
    table.insert(conns, model.AncestryChanged:Connect(function() if not model.Parent or not isNPC(model) then removeTrackerFromModel(model) end end))
    if part and part:IsA("BasePart") then
        table.insert(conns, part:GetPropertyChangedSignal("Position"):Connect(function()
            local ok,pos = pcall(function() return part.Position end)
            if not ok or not pos then removeTrackerFromModel(model); return end
            if pos == Vector3.new(0,0,0) or pos.Y < -5000 then removeTrackerFromModel(model) end
        end))
    end

    trackedNPCs[model] = { gui = gui, label = label, highlight = highlight, _connections = conns }
end

local function updateAllTrackers()
    local playerPos = player.Character and player.Character.PrimaryPart and player.Character.PrimaryPart.Position
    for model,data in pairs(trackedNPCs) do
        local part = getBestPartForModel(model)
        if not model.Parent or not part then removeTrackerFromModel(model) end
        if data and data.label and model.Parent then
            local hum = model:FindFirstChildOfClass("Humanoid")
            local hrp = part
            local dist = 0
            if playerPos and hrp then dist = (hrp.Position - playerPos).Magnitude end
            if hum then
                local jp = hum.JumpPower or hum.JumpHeight or 0
                data.label.Text = string.format("%s | HP: %.1f | S: %.1f | JP: %.1f | D: %.1f",
                    model.Name, hum.Health or 0, hum.WalkSpeed or 0, jp, dist)
            end
        end
    end
end

-- LOOP helpers
local function startLoop(key, fn)
    if loopRunners[key] then return end
    loops[key] = true
    local co = coroutine.create(function()
        while loops[key] do
            pcall(fn)
            task.wait(LOOP_DELAY)
        end
        loopRunners[key] = nil
    end)
    loopRunners[key] = co
    coroutine.resume(co)
end
local function stopLoop(key)
    loops[key] = false
    loopRunners[key] = nil
end

-- UI CREATION (compact & functional) - Main ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "UnifiedNPCGUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
ScreenGui.Parent = getPlayerGui()
ScreenGui.DisplayOrder = 2147483647

-- Top center toggle button (fixes the "frame doesn't open" issue)
local SmallToggle = Instance.new("TextButton")
SmallToggle.Name = "SmallToggle"
SmallToggle.Size = UDim2.new(0, 44, 0, 22)
SmallToggle.AnchorPoint = Vector2.new(0.5, 0)
SmallToggle.Position = UDim2.new(0.5, 0, 0, 6)
SmallToggle.BackgroundColor3 = Color3.fromRGB(44,44,44)
SmallToggle.BorderSizePixel = 0
SmallToggle.Font = Enum.Font.GothamBold
SmallToggle.TextSize = 12
SmallToggle.TextColor3 = Color3.new(1,1,1)
SmallToggle.Text = "NPC"
SmallToggle.Parent = ScreenGui
SmallToggle.ZIndex = 100000

-- MainFrame (center)
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
MainFrame.Position = UDim2.new(0.5, 0, 0.45, 0)
MainFrame.Size = UDim2.new(0, 460, 0, 340)
MainFrame.BackgroundColor3 = Color3.fromRGB(25,25,25)
MainFrame.BorderSizePixel = 0
MainFrame.Visible = false
MainFrame.Parent = ScreenGui
MainFrame.ZIndex = 100000

-- Top bar and tabs
local TopBar = Instance.new("Frame"); TopBar.Size = UDim2.new(1,0,0,34); TopBar.BackgroundColor3 = Color3.fromRGB(36,36,36); TopBar.Parent = MainFrame; TopBar.ZIndex = 100000
local Title = Instance.new("TextLabel"); Title.Size = UDim2.new(0.6,0,1,0); Title.BackgroundTransparency = 1; Title.TextColor3 = Color3.new(1,1,1); Title.Font = Enum.Font.GothamBold; Title.TextSize = 16; Title.Text = "Unified NPC"; Title.Position = UDim2.new(0,12,0,0); Title.Parent = TopBar; Title.ZIndex = 100000

local TabsBar = Instance.new("Frame"); TabsBar.Size = UDim2.new(1,0,0,28); TabsBar.Position = UDim2.new(0,0,0,34); TabsBar.BackgroundTransparency = 1; TabsBar.Parent = MainFrame
local function tabButton(x, text)
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(0.25, -6, 1, 0)
    b.Position = UDim2.new(x, 4, 0, 0)
    b.BackgroundColor3 = Color3.fromRGB(58,58,58)
    b.BorderSizePixel = 0
    b.Font = Enum.Font.Gotham
    b.TextSize = 13
    b.TextColor3 = Color3.new(1,1,1)
    b.Text = text
    b.Parent = TabsBar
    b.ZIndex = 100000
    return b
end
local tabControlsBtn = tabButton(0, "Ctrl")
local tabUtilitiesBtn = tabButton(0.25, "Utils")
local tabAdvancedBtn = tabButton(0.5, "Adv")
local tabWhitelistBtn = tabButton(0.75, "WL")

-- Content area (left: controls, center: type list, right: features/exclusions)
local Content = Instance.new("Frame")
Content.Size = UDim2.new(1, -12, 1, -68)
Content.Position = UDim2.new(0,6,0,68)
Content.BackgroundTransparency = 1
Content.Parent = MainFrame

-- Left column: Controls panel
local controlsFrame = Instance.new("Frame")
controlsFrame.Size = UDim2.new(0, 200, 1, 0)
controlsFrame.Position = UDim2.new(0, 0, 0, 0)
controlsFrame.BackgroundTransparency = 1
controlsFrame.Parent = Content

local ctrlScroll = Instance.new("ScrollingFrame")
ctrlScroll.Size = UDim2.new(1, -8, 1, -8)
ctrlScroll.Position = UDim2.new(0,4,0,4)
ctrlScroll.BackgroundTransparency = 1
ctrlScroll.ScrollBarThickness = 6
ctrlScroll.Parent = controlsFrame
local ctrlLayout = Instance.new("UIListLayout"); ctrlLayout.Parent = ctrlScroll; ctrlLayout.SortOrder = Enum.SortOrder.LayoutOrder; ctrlLayout.Padding = UDim.new(0,6)
ctrlLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() ctrlScroll.CanvasSize = UDim2.new(0,0,0, ctrlLayout.AbsoluteContentSize.Y + 8) end)

local function makeRow(parent, text)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, BTN_H)
    frame.BackgroundTransparency = 1
    frame.Parent = parent
    frame.ZIndex = 100000
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.66, 0, 1, 0)
    btn.Position = UDim2.new(0, 0, 0, 0)
    btn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    btn.BorderSizePixel = 0
    btn.Font = Enum.Font.Gotham
    btn.TextSize = SMALL_FONT
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Text = text
    btn.Parent = frame
    btn.ZIndex = 100000
    local small = Instance.new("TextButton")
    small.Size = UDim2.new(0.32, 0, 1, 0)
    small.Position = UDim2.new(0.68, 6, 0, 0)
    small.BackgroundColor3 = Color3.fromRGB(40,40,40)
    small.BorderSizePixel = 0
    small.Font = Enum.Font.Gotham
    small.TextSize = 11
    small.TextColor3 = Color3.new(1,1,1)
    small.Text = "Loop: Off"
    small.Parent = frame
    small.ZIndex = 100000
    return btn, small
end

-- Controls
local killBtn, killLoopBtn = makeRow(ctrlScroll, "Kill All")
local flingBoxRow = Instance.new("Frame"); flingBoxRow.Size = UDim2.new(1,0,0,BTN_H); flingBoxRow.BackgroundTransparency = 1; flingBoxRow.Parent = ctrlScroll; flingBoxRow.ZIndex = 100000
local flingBox = Instance.new("TextBox"); flingBox.Size = UDim2.new(0.56,0,1,0); flingBox.Position = UDim2.new(0,0,0,0); flingBox.PlaceholderText = "Fling"; flingBox.Text = "200"; flingBox.BackgroundColor3 = Color3.fromRGB(50,50,50); flingBox.TextColor3 = Color3.new(1,1,1); flingBox.BorderSizePixel = 0; flingBox.Font = Enum.Font.Gotham; flingBox.TextSize = SMALL_FONT; flingBox.Parent = flingBoxRow; flingBox.ZIndex = 100000
local flingBtn = Instance.new("TextButton"); flingBtn.Size = UDim2.new(0.42, -6, 1, 0); flingBtn.Position = UDim2.new(0.56, 6, 0, 0); flingBtn.BackgroundColor3 = Color3.fromRGB(100,50,50); flingBtn.BorderSizePixel = 0; flingBtn.Font = Enum.Font.Gotham; flingBtn.TextSize = SMALL_FONT; flingBtn.TextColor3 = Color3.new(1,1,1); flingBtn.Text = "Fling"; flingBtn.Parent = flingBoxRow; flingBtn.ZIndex = 100000
local flingLoopBtn = Instance.new("TextButton"); flingLoopBtn.Size = UDim2.new(0.32,0,1,0); flingLoopBtn.Position = UDim2.new(0.68, 6, 0, 0); flingLoopBtn.BackgroundColor3 = Color3.fromRGB(40,40,40); flingLoopBtn.BorderSizePixel = 0; flingLoopBtn.Font = Enum.Font.Gotham; flingLoopBtn.TextSize = 11; flingLoopBtn.TextColor3 = Color3.new(1,1,1); flingLoopBtn.Text = "Loop: Off"; flingLoopBtn.Parent = flingBoxRow; flingLoopBtn.ZIndex = 100000

local killFlingFrame = Instance.new("Frame"); killFlingFrame.Size = UDim2.new(1,0,0,BTN_H); killFlingFrame.BackgroundTransparency = 1; killFlingFrame.Parent = ctrlScroll; killFlingFrame.ZIndex = 100000
local killFlingBtn = Instance.new("TextButton"); killFlingBtn.Size = UDim2.new(0.66,0,1,0); killFlingBtn.Position = UDim2.new(0,0,0,0); killFlingBtn.BackgroundColor3 = Color3.fromRGB(70,30,30); killFlingBtn.BorderSizePixel = 0; killFlingBtn.Font = Enum.Font.Gotham; killFlingBtn.TextSize = SMALL_FONT; killFlingBtn.TextColor3 = Color3.new(1,1,1); killFlingBtn.Text = "Kill+Fling"; killFlingBtn.Parent = killFlingFrame; killFlingBtn.ZIndex = 100000
local killFlingLoopBtn = Instance.new("TextButton"); killFlingLoopBtn.Size = UDim2.new(0.32,0,1,0); killFlingLoopBtn.Position = UDim2.new(0.68, 6, 0, 0); killFlingLoopBtn.BackgroundColor3 = Color3.fromRGB(40,40,40); killFlingLoopBtn.BorderSizePixel = 0; killFlingLoopBtn.Font = Enum.Font.Gotham; killFlingLoopBtn.TextSize = 11; killFlingLoopBtn.TextColor3 = Color3.new(1,1,1); killFlingLoopBtn.Text = "Loop: Off"; killFlingLoopBtn.Parent = killFlingFrame; killFlingLoopBtn.ZIndex = 100000

local psBtn, psLoopBtn = makeRow(ctrlScroll, "PlatformStand")
local sitBtn, sitLoopBtn = makeRow(ctrlScroll, "Sit")
local anchorBtn, anchorLoopBtn = makeRow(ctrlScroll, "Anchor")
local cancelChaseBtn, cancelChaseLoopBtn = makeRow(ctrlScroll, "Cancel-Chase")
local v4Btn, v4LoopBtn = makeRow(ctrlScroll, "Void v4 (global)")

-- Utilities column (center)
local utilsFrame = Instance.new("Frame")
utilsFrame.Size = UDim2.new(0, 120, 1, 0)
utilsFrame.Position = UDim2.new(0, 204, 0, 0)
utilsFrame.BackgroundTransparency = 1
utilsFrame.Parent = Content

local utilScroll = Instance.new("ScrollingFrame")
utilScroll.Size = UDim2.new(1, -8, 1, -8)
utilScroll.Position = UDim2.new(0,4,0,4)
utilScroll.BackgroundTransparency = 1
utilScroll.ScrollBarThickness = 6
utilScroll.Parent = utilsFrame
local utilLayout = Instance.new("UIListLayout"); utilLayout.Parent = utilScroll; utilLayout.SortOrder = Enum.SortOrder.LayoutOrder; utilLayout.Padding = UDim.new(0,6)
utilLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() utilScroll.CanvasSize = UDim2.new(0,0,0, utilLayout.AbsoluteContentSize.Y + 8) end)

-- Utilities: Get Rid, Unget Rid, Jump
local getRidBtn, getRidLoop = makeRow(utilScroll, "Get Rid")
local ungetRidBtn, ungetRidLoop = makeRow(utilScroll, "unget rid of npcs")
local jumpBtn, jumpLoopBtn = makeRow(utilScroll, "Jump")

-- Advanced column (right)
local advFrame = Instance.new("Frame")
advFrame.Size = UDim2.new(0, 120, 1, 0)
advFrame.Position = UDim2.new(0, 332, 0, 0)
advFrame.BackgroundTransparency = 1
advFrame.Parent = Content

local advScroll = Instance.new("ScrollingFrame")
advScroll.Size = UDim2.new(1, -8, 1, -8)
advScroll.Position = UDim2.new(0,4,0,4)
advScroll.BackgroundTransparency = 1
advScroll.ScrollBarThickness = 6
advScroll.Parent = advFrame
local advLayout = Instance.new("UIListLayout"); advLayout.Parent = advScroll; advLayout.SortOrder = Enum.SortOrder.LayoutOrder; advLayout.Padding = UDim.new(0,6)
advLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() advScroll.CanvasSize = UDim2.new(0,0,0, advLayout.AbsoluteContentSize.Y + 8) end)

-- Global speed/jump/hip
local speedGlobalFrame = Instance.new("Frame"); speedGlobalFrame.Size = UDim2.new(1,0,0,BTN_H); speedGlobalFrame.BackgroundTransparency = 1; speedGlobalFrame.Parent = advScroll; speedGlobalFrame.ZIndex = 100000
local speedGlobalBox = Instance.new("TextBox"); speedGlobalBox.Size = UDim2.new(0.62,0,1,0); speedGlobalBox.Position = UDim2.new(0,0,0,0); speedGlobalBox.Text = "16"; speedGlobalBox.PlaceholderText = "Global Speed"; speedGlobalBox.BackgroundColor3 = Color3.fromRGB(50,50,50); speedGlobalBox.TextColor3 = Color3.new(1,1,1); speedGlobalBox.BorderSizePixel = 0; speedGlobalBox.Font = Enum.Font.Gotham; speedGlobalBox.TextSize = SMALL_FONT; speedGlobalBox.Parent = speedGlobalFrame; speedGlobalBox.ZIndex = 100000
local speedGlobalLoop = Instance.new("TextButton"); speedGlobalLoop.Size = UDim2.new(0.34,0,1,0); speedGlobalLoop.Position = UDim2.new(0.63,6,0,0); speedGlobalLoop.BackgroundColor3 = Color3.fromRGB(40,40,40); speedGlobalLoop.BorderSizePixel = 0; speedGlobalLoop.Font = Enum.Font.Gotham; speedGlobalLoop.TextSize = 11; speedGlobalLoop.TextColor3 = Color3.new(1,1,1); speedGlobalLoop.Text = "Loop: Off"; speedGlobalLoop.Parent = speedGlobalFrame; speedGlobalLoop.ZIndex = 100000

local jumpGlobalFrame = Instance.new("Frame"); jumpGlobalFrame.Size = UDim2.new(1,0,0,BTN_H); jumpGlobalFrame.BackgroundTransparency = 1; jumpGlobalFrame.Parent = advScroll; jumpGlobalFrame.ZIndex = 100000
local jumpGlobalBox = Instance.new("TextBox"); jumpGlobalBox.Size = UDim2.new(0.62,0,1,0); jumpGlobalBox.Position = UDim2.new(0,0,0,0); jumpGlobalBox.Text = "50"; jumpGlobalBox.PlaceholderText = "Global Jump"; jumpGlobalBox.BackgroundColor3 = Color3.fromRGB(50,50,50); jumpGlobalBox.TextColor3 = Color3.new(1,1,1); jumpGlobalBox.BorderSizePixel = 0; jumpGlobalBox.Font = Enum.Font.Gotham; jumpGlobalBox.TextSize = SMALL_FONT; jumpGlobalBox.Parent = jumpGlobalFrame; jumpGlobalBox.ZIndex = 100000
local jumpGlobalLoop = Instance.new("TextButton"); jumpGlobalLoop.Size = UDim2.new(0.34,0,1,0); jumpGlobalLoop.Position = UDim2.new(0.63,6,0,0); jumpGlobalLoop.BackgroundColor3 = Color3.fromRGB(40,40,40); jumpGlobalLoop.BorderSizePixel = 0; jumpGlobalLoop.Font = Enum.Font.Gotham; jumpGlobalLoop.TextSize = 11; jumpGlobalLoop.TextColor3 = Color3.new(1,1,1); jumpGlobalLoop.Text = "Loop: Off"; jumpGlobalLoop.Parent = jumpGlobalFrame; jumpGlobalLoop.ZIndex = 100000

local hipFrame = Instance.new("Frame"); hipFrame.Size = UDim2.new(1,0,0,BTN_H); hipFrame.BackgroundTransparency = 1; hipFrame.Parent = advScroll; hipFrame.ZIndex = 100000
local hipBox = Instance.new("TextBox"); hipBox.Size = UDim2.new(0.62,0,1,0); hipBox.Position = UDim2.new(0,0,0,0); hipBox.Text = "2"; hipBox.PlaceholderText = "Hip"; hipBox.BackgroundColor3 = Color3.fromRGB(50,50,50); hipBox.TextColor3 = Color3.new(1,1,1); hipBox.BorderSizePixel = 0; hipBox.Font = Enum.Font.Gotham; hipBox.TextSize = SMALL_FONT; hipBox.Parent = hipFrame; hipBox.ZIndex = 100000
local hipLoop = Instance.new("TextButton"); hipLoop.Size = UDim2.new(0.34,0,1,0); hipLoop.Position = UDim2.new(0.63,6,0,0); hipLoop.BackgroundColor3 = Color3.fromRGB(40,40,40); hipLoop.BorderSizePixel = 0; hipLoop.Font = Enum.Font.Gotham; hipLoop.TextSize = 11; hipLoop.TextColor3 = Color3.new(1,1,1); hipLoop.Text = "Loop: Off"; hipLoop.Parent = hipFrame; hipLoop.ZIndex = 100000

-- Whitelist / Type list (far right column)
local wlFrame = Instance.new("Frame")
wlFrame.Size = UDim2.new(0, 120, 1, 0)
wlFrame.Position = UDim2.new(0, 460-120, 0, 0) -- anchored to right edge of content
wlFrame.BackgroundTransparency = 1
wlFrame.Parent = Content

local wlScroll = Instance.new("ScrollingFrame")
wlScroll.Size = UDim2.new(1, -8, 1, -8)
wlScroll.Position = UDim2.new(0,4,0,4)
wlScroll.BackgroundTransparency = 1
wlScroll.ScrollBarThickness = 6
wlScroll.Parent = wlFrame
local wlLayout = Instance.new("UIListLayout"); wlLayout.Parent = wlScroll; wlLayout.SortOrder = Enum.SortOrder.LayoutOrder; wlLayout.Padding = UDim.new(0,6)
wlLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() wlScroll.CanvasSize = UDim2.new(0,0,0, wlLayout.AbsoluteContentSize.Y + 8) end)

-- Left side "Type Details" panel (features & exclusions) - separate floating frames
local FeaturesPanel = Instance.new("Frame")
FeaturesPanel.Name = "FeaturesPanel"
FeaturesPanel.Size = UDim2.new(0, 240, 0, 300)
FeaturesPanel.Position = UDim2.new(1, -250, 0, 40) -- right of main
FeaturesPanel.BackgroundColor3 = Color3.fromRGB(30,30,30)
FeaturesPanel.BorderSizePixel = 0
FeaturesPanel.Visible = false
FeaturesPanel.Parent = MainFrame

local featTitle = Instance.new("TextLabel")
featTitle.Size = UDim2.new(1, -8, 0, 22)
featTitle.Position = UDim2.new(0,4,0,6)
featTitle.BackgroundTransparency = 1
featTitle.Font = Enum.Font.GothamBold
featTitle.TextSize = 13
featTitle.TextColor3 = Color3.new(1,1,1)
featTitle.Text = "Type Features"
featTitle.Parent = FeaturesPanel

local featScroll = Instance.new("ScrollingFrame")
featScroll.Size = UDim2.new(1, -12, 1, - 40)
featScroll.Position = UDim2.new(0,6,0,36)
featScroll.BackgroundTransparency = 1
featScroll.ScrollBarThickness = 6
featScroll.Parent = FeaturesPanel
local featList = Instance.new("UIListLayout"); featList.Parent = featScroll; featList.SortOrder = Enum.SortOrder.LayoutOrder; featList.Padding = UDim.new(0,4)
featList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() featScroll.CanvasSize = UDim2.new(0,0,0, featList.AbsoluteContentSize.Y + 8) end)

local ExclusionPanel = Instance.new("Frame")
ExclusionPanel.Name = "ExclusionPanel"
ExclusionPanel.Size = UDim2.new(0, 240, 0, 300)
ExclusionPanel.Position = UDim2.new(0, -250, 0, 40) -- left of main
ExclusionPanel.BackgroundColor3 = Color3.fromRGB(30,30,30)
ExclusionPanel.BorderSizePixel = 0
ExclusionPanel.Visible = false
ExclusionPanel.Parent = MainFrame

local exclTitle = Instance.new("TextLabel")
exclTitle.Size = UDim2.new(1, -8, 0, 22)
exclTitle.Position = UDim2.new(0,4,0,6)
exclTitle.BackgroundTransparency = 1
exclTitle.Font = Enum.Font.GothamBold
exclTitle.TextSize = 13
exclTitle.TextColor3 = Color3.new(1,1,1)
exclTitle.Text = "Exclusions (select a type)"
exclTitle.Parent = ExclusionPanel

local exclScroll = Instance.new("ScrollingFrame")
exclScroll.Size = UDim2.new(1, -12, 1, - 40)
exclScroll.Position = UDim2.new(0,6,0,36)
exclScroll.BackgroundTransparency = 1
exclScroll.ScrollBarThickness = 6
exclScroll.Parent = ExclusionPanel
local exclList = Instance.new("UIListLayout"); exclList.Parent = exclScroll; exclList.SortOrder = Enum.SortOrder.LayoutOrder; exclList.Padding = UDim.new(0,4)
exclList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() exclScroll.CanvasSize = UDim2.new(0,0,0, exclList.AbsoluteContentSize.Y + 8) end)

-- Buttons + behaviors: wire up tab clicks and main toggle
SmallToggle.MouseButton1Click:Connect(function()
    MainFrame.Visible = not MainFrame.Visible
    -- hide floating panels when closing
    if not MainFrame.Visible then
        FeaturesPanel.Visible = false
        ExclusionPanel.Visible = false
    end
end)

local function showControlsTab()
    controlsFrame.Visible = true
    utilsFrame.Visible = true
    advFrame.Visible = true
    wlFrame.Visible = true
    -- The tabs don't hide columns (they are separate columns). We keep them visible but highlight
    -- For simplicity, we can visually indicate active tab by background color
    tabControlsBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
    tabUtilitiesBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    tabAdvancedBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    tabWhitelistBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    -- Hide floating panels
    FeaturesPanel.Visible = false
    ExclusionPanel.Visible = false
end
local function showUtilsTab()
    tabControlsBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    tabUtilitiesBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
    tabAdvancedBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    tabWhitelistBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    FeaturesPanel.Visible = false
    ExclusionPanel.Visible = false
end
local function showAdvTab()
    tabControlsBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    tabUtilitiesBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    tabAdvancedBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
    tabWhitelistBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    FeaturesPanel.Visible = false
    ExclusionPanel.Visible = false
end
local function showWLTab()
    tabControlsBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    tabUtilitiesBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    tabAdvancedBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
    tabWhitelistBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
    -- Show type features & exclusion panels when WL tab active
    FeaturesPanel.Visible = true
    ExclusionPanel.Visible = true
end

tabControlsBtn.MouseButton1Click:Connect(showControlsTab)
tabUtilitiesBtn.MouseButton1Click:Connect(showUtilsTab)
tabAdvancedBtn.MouseButton1Click:Connect(showAdvTab)
tabWhitelistBtn.MouseButton1Click:Connect(showWLTab)

-- Initially highlight Controls tab
showControlsTab()

-- REBUILD grouped type list (WL column)
local function rebuildGroupedList()
    for _,child in ipairs(wlScroll:GetChildren()) do if child:IsA("Frame") then child:Destroy() end end
    local counts = {}
    for model,_ in pairs(NPCs) do
        if model and model.Parent and isNPC(model) then
            counts[model.Name] = (counts[model.Name] or 0) + 1
        end
    end
    for name,count in pairs(counts) do
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1,0,0,BTN_H)
        frame.BackgroundTransparency = 1
        frame.Parent = wlScroll
        frame.ZIndex = 100000
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(0.6,0,1,0)
        btn.Position = UDim2.new(0,0,0,0)
        btn.BackgroundColor3 = Color3.fromRGB(58,58,58)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.Gotham
        btn.TextSize = SMALL_FONT
        btn.TextColor3 = Color3.new(1,1,1)
        btn.Text = string.format("%s [%d]", name, count)
        btn.Parent = frame
        btn.ZIndex = 100000
        local info = Instance.new("TextLabel")
        info.Size = UDim2.new(0.38, 0, 1, 0)
        info.Position = UDim2.new(0.62, 6, 0, 0)
        info.BackgroundTransparency = 1
        info.Font = Enum.Font.Gotham
        info.TextSize = 11
        info.TextColor3 = Color3.new(1,1,1)
        info.Text = "Select"
        info.Parent = frame
        info.ZIndex = 100000

        btn.MouseButton1Click:Connect(function()
            -- show type features for this type
            showTypeUI(name, count)
        end)
    end
end

-- Ensure type-specific left page generator (compact)
local typeLeftPages = {}
local typeFeaturePages = {}
local typeExclPages = {}

local function ensureTypeLeftPage(typeName)
    if typeLeftPages[typeName] then return typeLeftPages[typeName] end
    local page = Instance.new("Frame")
    page.Size = UDim2.new(0, 200, 1, -12)
    page.BackgroundTransparency = 1
    page.Parent = ExclusionPanel
    page.Visible = false

    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1,-8,0,22)
    title.Position = UDim2.new(0,4,0,6)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 12
    title.TextColor3 = Color3.new(1,1,1)
    title.Text = "Type: " .. typeName
    title.Parent = page

    -- Add buttons for common type-level actions
    local y = 36
    local function makeBtn(text)
        local b = Instance.new("TextButton")
        b.Size = UDim2.new(1, -8, 0, BTN_H)
        b.Position = UDim2.new(0,4,0,y)
        b.BackgroundColor3 = Color3.fromRGB(58,58,58)
        b.BorderSizePixel = 0
        b.Font = Enum.Font.Gotham
        b.TextSize = SMALL_FONT
        b.TextColor3 = Color3.new(1,1,1)
        b.Text = text
        b.Parent = page
        y = y + BTN_H + 6
        return b
    end

    local anchorTypeBtn = makeBtn("Anchor All of Type")
    local unanchorTypeBtn = makeBtn("Unanchor All of Type")
    local flingTypeBtn = makeBtn("Fling All of Type")
    local voidTypeBtn = makeBtn("Void v4 Type")
    local killTypeBtn = makeBtn("Kill All of Type")
    local trackerTypeBtn = makeBtn("Toggle Tracker for Type")

    anchorTypeBtn.MouseButton1Click:Connect(function()
        for _,m in ipairs(getNPCsByName(typeName)) do pcall(function() anchorModel(m) end) end
    end)
    unanchorTypeBtn.MouseButton1Click:Connect(function()
        for _,m in ipairs(getNPCsByName(typeName)) do pcall(function() unanchorModel(m) end) end
    end)
    flingTypeBtn.MouseButton1Click:Connect(function()
        local power = tonumber(flingBox.Text) or 200
        for _,m in ipairs(getNPCsByName(typeName)) do pcall(function() flingModel(m, power) end) end
    end)
    voidTypeBtn.MouseButton1Click:Connect(function()
        for _,m in ipairs(getNPCsByName(typeName)) do pcall(function() voidV4Model(m) end) end
    end)
    killTypeBtn.MouseButton1Click:Connect(function()
        local list = getNPCsByName(typeName)
        for _,m in ipairs(list) do
            local hum = m:FindFirstChildOfClass("Humanoid")
            if hum then pcall(function() if hum.BreakJointsOnDeath ~= nil then hum.BreakJointsOnDeath = true end end) end
        end
        killAllSimultaneousForList(list)
    end)
    trackerTypeBtn.MouseButton1Click:Connect(function()
        for _,m in ipairs(getNPCsByName(typeName)) do
            if trackedNPCs[m] then removeTrackerFromModel(m) else addTrackerToModel(m) end
        end
    end)

    typeLeftPages[typeName] = page
    return page
end

local function ensureTypeFeaturePage(typeName)
    if typeFeaturePages[typeName] then return typeFeaturePages[typeName] end
    local page = Instance.new("Frame")
    page.Size = UDim2.new(1, -12, 0, 360)
    page.BackgroundTransparency = 1
    page.Parent = featScroll
    page.ZIndex = 100000
    page.Visible = false

    local y = 0
    local function makeBtnLocal(txt)
        local b = Instance.new("TextButton")
        b.Size = UDim2.new(1,0,0,BTN_H)
        b.Position = UDim2.new(0,0,0,y)
        b.BackgroundColor3 = Color3.fromRGB(58,58,58)
        b.Font = Enum.Font.Gotham
        b.TextSize = SMALL_FONT
        b.TextColor3 = Color3.new(1,1,1)
        b.Text = txt
        b.Parent = page
        y = y + BTN_H + 6
        return b
    end

    local btnFling = makeBtnLocal("Fling (type)")
    local btnV4 = makeBtnLocal("VoidV4 (type)")
    local btnAnchor = makeBtnLocal("Anchor Toggle (type)")
    local btnKill = makeBtnLocal("Kill (type)")

    btnFling.MouseButton1Click:Connect(function()
        local p = tonumber(flingBox.Text) or 200
        for _,m in ipairs(getNPCsByName(typeName)) do pcall(function() flingModel(m,p) end) end
    end)
    btnV4.MouseButton1Click:Connect(function()
        for _,m in ipairs(getNPCsByName(typeName)) do pcall(function() voidV4Model(m) end) end
    end)
    btnAnchor.MouseButton1Click:Connect(function()
        -- toggles anchor state for models of this type
        for _,m in ipairs(getNPCsByName(typeName)) do pcall(function() toggleAnchor(m) end) end
    end)
    btnKill.MouseButton1Click:Connect(function()
        local list = getNPCsByName(typeName)
        for _,m in ipairs(list) do
            local hum = m:FindFirstChildOfClass("Humanoid")
            if hum then pcall(function() if hum.BreakJointsOnDeath ~= nil then hum.BreakJointsOnDeath = true end end) end
        end
        killAllSimultaneousForList(list)
    end)

    typeFeaturePages[typeName] = page
    return page
end

local function ensureTypeExclPage(typeName)
    if typeExclPages[typeName] then return typeExclPages[typeName] end
    local page = Instance.new("Frame")
    page.Size = UDim2.new(0, 200, 1, -12)
    page.BackgroundTransparency = 1
    page.Parent = ExclusionPanel
    page.Visible = false

    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1,-8,0,22)
    title.Position = UDim2.new(0,4,0,6)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 12
    title.TextColor3 = Color3.new(1,1,1)
    title.Text = "Exclusions: " .. typeName
    title.Parent = page

    local y = 36
    local function makeExBtn(txt)
        local b = Instance.new("TextButton")
        b.Size = UDim2.new(1, -8, 0, BTN_H)
        b.Position = UDim2.new(0,4,0,y)
        b.BackgroundColor3 = Color3.fromRGB(58,58,58)
        b.BorderSizePixel = 0
        b.Font = Enum.Font.Gotham
        b.TextSize = SMALL_FONT
        b.TextColor3 = Color3.new(1,1,1)
        b.Text = txt
        b.Parent = page
        y = y + BTN_H + 6
        return b
    end

    local exAnchor = makeExBtn("Toggle Exclusion: Anchor")
    exAnchor.MouseButton1Click:Connect(function()
        -- store exclusion in a simple table under typeExclPages (we keep state local)
        local t = typeName
        if not _G._npcExclusions then _G._npcExclusions = {} end
        _G._npcExclusions[t] = _G._npcExclusions[t] or {}
        _G._npcExclusions[t]["Anchor"] = not _G._npcExclusions[t]["Anchor"]
        exAnchor.Text = "Toggle Exclusion: Anchor ["..tostring(_G._npcExclusions[t]["Anchor"]).."]"
    end)

    typeExclPages[typeName] = page
    return page
end

local prevSelectedType = nil
local function showTypeUI(typeName, count)
    if prevSelectedType and prevSelectedType ~= typeName then
        -- hide previous
        if typeLeftPages[prevSelectedType] then typeLeftPages[prevSelectedType].Visible = false end
        if typeFeaturePages[prevSelectedType] then typeFeaturePages[prevSelectedType].Visible = false end
        if typeExclPages[prevSelectedType] then typeExclPages[prevSelectedType].Visible = false end
    end
    prevSelectedType = typeName

    -- ensure pages exist and show them
    local leftP = ensureTypeLeftPage(typeName)
    local featP = ensureTypeFeaturePage(typeName)
    local exclP = ensureTypeExclPage(typeName)

    leftP.Visible = true
    featP.Visible = true
    exclP.Visible = true

    FeaturesPanel.Visible = true
    ExclusionPanel.Visible = true
    featTitle.Text = "Features: " .. typeName
    exclTitle.Text = "Exclusions: " .. typeName
end

-- Button behaviors (Controls)
killBtn.MouseButton1Click:Connect(function()
    for _,m in ipairs(getNPCsArray()) do
        local hum = m:FindFirstChildOfClass("Humanoid")
        if hum then pcall(function() if hum.BreakJointsOnDeath ~= nil then hum.BreakJointsOnDeath = true end end) end
    end
    killAllSimultaneousForList(getNPCsArray())
end)

killLoopBtn.MouseButton1Click:Connect(function()
    loops.killAll = not loops.killAll
    killLoopBtn.Text = "Loop: " .. (loops.killAll and "On" or "Off")
    if loops.killAll then
        startLoop("killAll", function()
            for _,m in ipairs(getNPCsArray()) do
                local hum = m:FindFirstChildOfClass("Humanoid")
                if hum then pcall(function() if hum.BreakJointsOnDeath ~= nil then hum.BreakJointsOnDeath = true end end) end
            end
            killAllSimultaneousForList(getNPCsArray())
        end)
    else
        stopLoop("killAll")
    end
end)

flingBtn.MouseButton1Click:Connect(function()
    local p = tonumber(flingBox.Text) or 200
    for _,m in ipairs(getNPCsArray()) do pcall(function() flingModel(m, p) end) end
end)
flingLoopBtn.MouseButton1Click:Connect(function()
    loops.flingAll = not loops.flingAll
    flingLoopBtn.Text = "Loop: "..(loops.flingAll and "On" or "Off")
    if loops.flingAll then
        startLoop("flingAll", function()
            local p = tonumber(flingBox.Text) or 200
            for _,m in ipairs(getNPCsArray()) do pcall(function() flingModel(m, p) end) end
        end)
    else
        stopLoop("flingAll")
    end
end)

killFlingBtn.MouseButton1Click:Connect(function()
    for _,m in ipairs(getNPCsArray()) do
        pcall(function()
            local hum = m:FindFirstChildOfClass("Humanoid")
            if hum then
                pcall(function() if hum.BreakJointsOnDeath ~= nil then hum.BreakJointsOnDeath = true end end)
                applyDamageSequence(hum)
            end
            iterateParts(m, function(pp) pcall(function() if pp.Massless ~= nil then pp.Massless = true end end) end)
            flingModel(m, tonumber(flingBox.Text) or 200)
        end)
        local humRef = m and m:FindFirstChildOfClass("Humanoid")
        local modelRef = m
        local delaySec = 1
        if humRef or modelRef then
            task.delay(delaySec, function()
                pcall(function()
                    if humRef and humRef.Parent and humRef.BreakJointsOnDeath ~= nil then humRef.BreakJointsOnDeath = true end
                end)
                if modelRef then iterateParts(modelRef, function(pp) pcall(function() if pp.Massless ~= nil then pp.Massless = false end end) end) end
            end)
        end
    end
end)

killFlingLoopBtn.MouseButton1Click:Connect(function()
    loops.killFlingAll = not loops.killFlingAll
    killFlingLoopBtn.Text = "Loop: " .. (loops.killFlingAll and "On" or "Off")
    if loops.killFlingAll then
        startLoop("killFlingAll", function()
            local p = tonumber(flingBox.Text) or 200
            for _,m in ipairs(getNPCsArray()) do
                pcall(function()
                    local hum = m:FindFirstChildOfClass("Humanoid")
                    if hum then
                        pcall(function() if hum.BreakJointsOnDeath ~= nil then hum.BreakJointsOnDeath = true end end)
                        applyDamageSequence(hum)
                    end
                    iterateParts(m, function(pp) pcall(function() if pp.Massless ~= nil then pp.Massless = true end end) end)
                    flingModel(m, p)
                end)
                local humRef = m and m:FindFirstChildOfClass("Humanoid")
                local modelRef = m
                local delaySec = 1
                if humRef or modelRef then
                    task.delay(delaySec, function()
                        pcall(function()
                            if humRef and humRef.Parent and humRef.BreakJointsOnDeath ~= nil then humRef.BreakJointsOnDeath = true end
                        end)
                        if modelRef then iterateParts(modelRef, function(pp) pcall(function() if pp.Massless ~= nil then pp.Massless = false end end) end) end
                    end)
                end
            end
        end)
    else
        stopLoop("killFlingAll")
    end
end)

psBtn.MouseButton1Click:Connect(function() for _,m in ipairs(getNPCsArray()) do platformStand(m) end end)
psLoopBtn.MouseButton1Click:Connect(function() loops.ps = not loops.ps; psLoopBtn.Text = "Loop: " .. (loops.ps and "On" or "Off"); if loops.ps then startLoop("ps", function() for _,m in ipairs(getNPCsArray()) do platformStand(m) end end) else stopLoop("ps") end end)

sitBtn.MouseButton1Click:Connect(function() for _,m in ipairs(getNPCsArray()) do makeSit(m) end end)
sitLoopBtn.MouseButton1Click:Connect(function() loops.sit = not loops.sit; sitLoopBtn.Text = "Loop: " .. (loops.sit and "On" or "Off"); if loops.sit then startLoop("sit", function() for _,m in ipairs(getNPCsArray()) do makeSit(m) end end) else stopLoop("sit") end end)

anchorBtn.MouseButton1Click:Connect(function()
    anchorState = not anchorState
    anchorBtn.Text = "Anchor: " .. (anchorState and "On" or "Off")
    if anchorState then
        for _,m in ipairs(getNPCsArray()) do pcall(function() anchorModel(m) end) end
    else
        for _,m in ipairs(getNPCsArray()) do pcall(function() unanchorModel(m) end) end
    end
end)

-- Anchor Loop: anchors only (doesn't unanchor)
anchorLoopBtn.MouseButton1Click:Connect(function()
    loops.anchor = not loops.anchor
    anchorLoopBtn.Text = "Loop: " .. (loops.anchor and "On" or "Off")
    if loops.anchor then
        -- reflect that loop is actively anchoring: set anchorState true (so new NPCs are anchored)
        anchorState = true
        anchorBtn.Text = "Anchor: On"
        startLoop("anchor", function()
            for _,m in ipairs(getNPCsArray()) do pcall(function() anchorModel(m) end) end
        end)
    else
        stopLoop("anchor")
        -- do NOT unanchor when stopping loop; user must click Anchor to unanchor.
    end
end)

cancelChaseBtn.MouseButton1Click:Connect(function()
    cancelChaseEnabled = not cancelChaseEnabled
    cancelChaseBtn.Text = "Cancel-Chase: " .. tostring(cancelChaseEnabled)
end)

v4Btn.MouseButton1Click:Connect(function() for _,m in ipairs(getNPCsArray()) do pcall(function() voidV4Model(m) end) end end)
v4LoopBtn.MouseButton1Click:Connect(function() loops.v4 = not loops.v4; v4LoopBtn.Text = "Loop: "..(loops.v4 and "On" or "Off"); if loops.v4 then startLoop("v4", function() for _,m in ipairs(getNPCsArray()) do pcall(function() voidV4Model(m, -5000) end) end end) else stopLoop("v4") end end)

-- Utilities: Get Rid & Unget Rid
getRidBtn.MouseButton1Click:Connect(function()
    for _,m in ipairs(getNPCsArray()) do
        local hrp = getBestPartForModel(m)
        if hrp and player.Character and player.Character.PrimaryPart then
            local playerPos = player.Character.PrimaryPart.Position
            local dist = (hrp.Position - playerPos).Magnitude
            local closer = true
            for _,plr in ipairs(Players:GetPlayers()) do
                if plr ~= player and plr.Character and plr.Character.PrimaryPart then
                    local d = (hrp.Position - plr.Character.PrimaryPart.Position).Magnitude
                    if d < dist then closer = false break end
                end
            end
            if closer then pcall(function() hrp.CFrame = CFrame.new(9e37,9e37,9e37) end) end
        end
    end
end)
getRidLoop.MouseButton1Click:Connect(function()
    loops.getRid = not loops.getRid
    getRidLoop.Text = "Loop: " .. (loops.getRid and "On" or "Off")
    if loops.getRid then
        startLoop("getRid", function()
            for _,m in ipairs(getNPCsArray()) do
                local hrp = getBestPartForModel(m)
                if hrp and player.Character and player.Character.PrimaryPart then
                    local playerPos = player.Character.PrimaryPart.Position
                    local dist = (hrp.Position - playerPos).Magnitude
                    local closer = true
                    for _,plr in ipairs(Players:GetPlayers()) do
                        if plr ~= player and plr.Character and plr.Character.PrimaryPart then
                            local d = (hrp.Position - plr.Character.PrimaryPart.Position).Magnitude
                            if d < dist then closer = false break end
                        end
                    end
                    if closer then pcall(function() hrp.CFrame = CFrame.new(9e37,9e37,9e39) end) end
                end
            end
        end)
    else
        stopLoop("getRid")
    end
end)

-- Unget Rid: find gotten-rid NPCs (extreme positions), teleport player safely, unanchor, kill, teleport back
ungetRidBtn.MouseButton1Click:Connect(function()
    local gotRids = {}
    for _,m in ipairs(getNPCsArray()) do
        local p = getBestPartForModel(m)
        if p and p:IsA("BasePart") then
            local ok,pos = pcall(function() return p.Position end)
            if ok and pos then
                if math.abs(pos.X) > 1e6 or math.abs(pos.Y) > 1e6 or math.abs(pos.Z) > 1e6 then
                    table.insert(gotRids, {model = m, part = p, pos = pos})
                end
            end
        end
    end
    if #gotRids == 0 then return end

    local startCFrame = nil
    if player.Character and player.Character.PrimaryPart then pcall(function() startCFrame = player.Character.PrimaryPart.CFrame end) end

    for _,entry in ipairs(gotRids) do
        local model = entry.model
        local part = entry.part
        local pos = entry.pos
        local targetCFrame = nil
        pcall(function()
            if math.abs(pos.X) > 1e8 or math.abs(pos.Y) > 1e8 or math.abs(pos.Z) > 1e8 then
                if part and part.Parent then
                    pcall(function() part.CFrame = CFrame.new(0, 150, 0) end)
                    targetCFrame = CFrame.new(0,150,0)
                end
            else
                targetCFrame = CFrame.new(pos + Vector3.new(0,5,0))
            end
        end)
        if targetCFrame and player.Character and player.Character.PrimaryPart then
            local ok = pcall(function() player.Character:SetPrimaryPartCFrame(targetCFrame) end)
            if not ok then
                -- fallback: attempt to move NPC to safe zone instead
                pcall(function() if part and part.Parent then part.CFrame = CFrame.new(0,150,0) end end)
            end
        end
        pcall(function() unanchorModel(model) end)
        local hum = model:FindFirstChildOfClass("Humanoid")
        if hum then
            pcall(function() if hum.BreakJointsOnDeath ~= nil then hum.BreakJointsOnDeath = true end end)
            applyDamageSequence(hum)
        end
        task.wait(0.12)
    end

    if startCFrame and player.Character and player.Character.PrimaryPart then pcall(function() player.Character:SetPrimaryPartCFrame(startCFrame) end) end
end)

-- Jump handlers
jumpBtn.MouseButton1Click:Connect(function() for _,m in ipairs(getNPCsArray()) do jumpModel(m) end end)
jumpLoopBtn.MouseButton1Click:Connect(function() loops.jump = not loops.jump; jumpLoopBtn.Text = "Loop: "..(loops.jump and "On" or "Off"); if loops.jump then startLoop("jump", function() for _,m in ipairs(getNPCsArray()) do jumpModel(m) end end) else stopLoop("jump") end end)

-- Advanced global loops
speedGlobalLoop.MouseButton1Click:Connect(function()
    loops["speed_global"] = not loops["speed_global"]
    speedGlobalLoop.Text = "Loop: "..(loops["speed_global"] and "On" or "Off")
    if loops["speed_global"] then
        startLoop("speed_global", function()
            local v = tonumber(speedGlobalBox.Text) or 16
            for _,m in ipairs(getNPCsArray()) do pcall(function() setSpeed(m, v) end) end
        end)
    else
        stopLoop("speed_global")
    end
end)
speedGlobalBox.FocusLost:Connect(function() local v = tonumber(speedGlobalBox.Text) if v then for _,m in ipairs(getNPCsArray()) do pcall(function() setSpeed(m, v) end) end end end)

jumpGlobalLoop.MouseButton1Click:Connect(function()
    loops["jump_global"] = not loops["jump_global"]
    jumpGlobalLoop.Text = "Loop: "..(loops["jump_global"] and "On" or "Off")
    if loops["jump_global"] then
        startLoop("jump_global", function()
            local v = tonumber(jumpGlobalBox.Text) or 50
            for _,m in ipairs(getNPCsArray()) do pcall(function() setJumpPower(m, v) end) end
        end)
    else
        stopLoop("jump_global")
    end
end)
jumpGlobalBox.FocusLost:Connect(function() local v = tonumber(jumpGlobalBox.Text) if v then for _,m in ipairs(getNPCsArray()) do pcall(function() setJumpPower(m, v) end) end end end)

hipLoop.MouseButton1Click:Connect(function()
    loops.hip = not loops.hip
    hipLoop.Text = "Loop: "..(loops.hip and "On" or "Off")
    if loops.hip then
        startLoop("hip", function()
            local v = tonumber(hipBox.Text) or 2
            for _,m in ipairs(getNPCsArray()) do pcall(function() setHipHeight(m, v) end) end
        end)
    else
        stopLoop("hip")
    end
end)

-- Tracker toggle (keeps minimal)
-- A button inside left type page toggles trackers per-type; we also provide a global toggle here
local trackerGlobalBtn = Instance.new("TextButton")
trackerGlobalBtn.Size = UDim2.new(1, -8, 0, BTN_H)
trackerGlobalBtn.Position = UDim2.new(0,4,0, 6)
trackerGlobalBtn.BackgroundColor3 = Color3.fromRGB(58,58,58)
trackerGlobalBtn.Font = Enum.Font.Gotham
trackerGlobalBtn.TextSize = SMALL_FONT
trackerGlobalBtn.TextColor3 = Color3.new(1,1,1)
trackerGlobalBtn.Text = "Toggle NPC Tracker (all)"
trackerGlobalBtn.Parent = ctrlScroll
trackerGlobalBtn.ZIndex = 100000

trackerGlobalBtn.MouseButton1Click:Connect(function()
    for _,m in ipairs(getNPCsArray()) do
        if trackedNPCs[m] then removeTrackerFromModel(m) else addTrackerToModel(m) end
    end
end)

-- Periodic housekeeping: update counters, trackers, rebuild grouped list
local CounterLabel = Instance.new("TextLabel")
CounterLabel.Size = UDim2.new(1, -8, 0, 20)
CounterLabel.Position = UDim2.new(0,4,0,0)
CounterLabel.BackgroundTransparency = 0.6
CounterLabel.BackgroundColor3 = Color3.fromRGB(26,26,26)
CounterLabel.BorderSizePixel = 0
CounterLabel.Font = Enum.Font.Gotham
CounterLabel.TextSize = 12
CounterLabel.TextColor3 = Color3.new(1,1,1)
CounterLabel.Text = "NPCs: 0"
CounterLabel.Parent = MainFrame
CounterLabel.ZIndex = 100000

task.spawn(function()
    while true do
        scanAddNPCs()
        cleanNPCs()
        local arr = getNPCsArray()
        CounterLabel.Text = "NPCs: " .. tostring(#arr)
        updateAllTrackers()
        rebuildGroupedList()
        task.wait(SCAN_INTERVAL)
    end
end)

-- When local player dies, retarget NPCs (avoid chasing corpses)
local function attachLocalDeathHandler(char)
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid", 2)
    if hum then
        hum.Died:Connect(function()
            for model,_ in pairs(NPCs) do
                if model and model.Parent and isNPC(model) then
                    pcall(function()
                        stopNPCPath(model)
                        cancelChaseForModel(model)
                    end)
                end
            end
        end)
    end
end
if player.Character then attachLocalDeathHandler(player.Character) end
player.CharacterAdded:Connect(function(c) task.delay(0.1, function() attachLocalDeathHandler(c) end) end)

-- Initial build
rebuildGroupedList()

-- End of script
