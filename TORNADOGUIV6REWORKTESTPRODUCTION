-- Tornado (Friendly / Nightmare) LocalScript â€” FULL (with funnel + satellites + noodle -> fling logic)
-- Features:
--  * Satellites spawn in Friendly mode (visual), attack only in Nightmare.
--  * 1/4 of satellite parts become "noodles" (vertical chains) that stretch toward target players.
--  * When a noodle reaches a player it triggers the noodle attack: only noodle parts fling that player until they leave windfield.
--  * Main funnel can spawn noodles based on number of main-funnel parts; main-noodles don't attack unless the player is inside the inner 1/3 radius.
--  * GUI tuning controls included.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local localPlayer = Players.LocalPlayer

-- ========== Configurable Settings ==========
local enabled = false
local tornadoSpinSpeed = 80
local tornadoUpwardSpeed = 50
local tornadoWindfield = 100 -- radius / width of tornado
local tornadoMoveSpeed = 10
local tornadoInwardPullSpeed = 50

local baseplateName = "Baseplate"

-- Satellite (sub-vortex) settings
local maxPartsPerSatellite = 6
local maxSubVortices = 3
local satelliteChaseSpeed = 20 -- studs/sec (only in NIGHTMARE)
local satelliteOrbitRadius = 10
local satelliteRotationSpeed = 3.5
local horizontalVortexAttachRadius = 30
local satelliteMainOrbitAttackCount = 3
local satelliteMainOrbitAttackRate = 1

-- Sub-vortex / noodle parameters
local subVortexSpinSpeed = 3.5      -- per-part multiplier
local subVortexHeight = 18          -- top height for sub-vortex parts (studs above tornado base)
local noodleFraction = 0.25         -- 1/4 of satellite parts become noodle chains
local verticalChainMinParts = 2
local verticalChainMaxParts = 6
local verticalChainSpeed = 0.7
local verticalChainAmplitude = 4
local verticalChainFrequency = 6
local verticalChainSegmentDelay = 0.12
local verticalAttachDistance = 2.0

-- Main-tornado noodle spawn
local mainNoodleEnabled = true
local mainNoodleSpawnCooldown = 2.0  -- seconds between main noodle spawn attempts
local mainNoodleMinParts = 4         -- min number of main-funnel parts required to spawn a main noodle

-- Noodle fling settings (velocity-based)
local noodleFlingInterval = 0.6  -- seconds between noodle flings at a targeted player
local noodleLaunchBaseSpeed = 300
local noodleLaunchRandomAdd = 200
local noodleLaunchAngular = 80

-- Orbit smoothing / cap
local orbitVelocityMinCap = 200
local orbitVelocityMultiplier = 2.5

-- Funnel-specific
local funnelReserveCount = 8
local funnelHeight = 60
local funnelTeleportYOffset = 5

-- How much of available parts reserved for main funnel by default
local mainFunnelShare = 0.7

-- ========== Runtime State ==========
local tornadoPosition = nil
local pickedUpByFunnel = {}      -- part -> true
local whitelistedParts = {}      -- part -> true
local assignedToSatellite = {}   -- part -> satelliteId or true
local debrisAttachedToPlayer = {}-- part -> player

local mainFunnelParts = {}       -- list of main funnel parts
local mainFunnelSet = {}         -- set for quick checks

local satelliteVortices = {}     -- id -> sat table
local satelliteAttackState = {}
local nextSatelliteId = 1

local playerAttachmentMap = {}   -- player -> Attachment on HRP
local playerTargetThreads = {}   -- player -> boolean

local nightmareMode = false

local noodlePools = {}           -- satId -> set of parts belonging to noodle chains
local noodlePartSet = {}         -- part -> true

-- For main funnel vertical chains (ownerSatellite = 0)
local mainVerticalChains = {}
local lastMainNoodleTick = 0

-- ========== UI (keeps your old GUI; added relevant inputs) ==========
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "TornadoBlastGUI"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 100
screenGui.IgnoreGuiInset = true
screenGui.Parent = localPlayer:WaitForChild("PlayerGui")

local hideToggle = Instance.new("TextButton")
hideToggle.Size = UDim2.new(0, 40, 0, 20)
hideToggle.Position = UDim2.new(0, 10, 0.5, -10)
hideToggle.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
hideToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
hideToggle.Font = Enum.Font.SourceSansBold
hideToggle.TextSize = 14
hideToggle.Text = "Hide"
hideToggle.Parent = screenGui

local function createLabeledTextbox(labelText, default, index)
    local perRow = 4
    local row = math.floor(index / perRow)
    local col = index % perRow
    local xOffset = 0.02 + 0.25 * col
    local yOffset = 60 + (row * 60)

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0, 160, 0, 16)
    label.Position = UDim2.new(xOffset, 0, 0, yOffset)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.SourceSans
    label.TextSize = 14
    label.ZIndex = 2
    label.Parent = screenGui

    local box = Instance.new("TextBox")
    box.Size = UDim2.new(0, 160, 0, 20)
    box.Position = UDim2.new(xOffset, 0, 0, yOffset + 18)
    box.BackgroundColor3 = Color3.fromRGB(240, 240, 240)
    box.TextColor3 = Color3.fromRGB(0, 0, 0)
    box.Font = Enum.Font.SourceSans
    box.TextSize = 14
    box.Text = tostring(default)
    box.ZIndex = 2
    box.Parent = screenGui

    return box
end

local inputBoxes = {
    {"Spin Speed", tornadoSpinSpeed},
    {"Upward Speed", tornadoUpwardSpeed},
    {"Windfield Radius", tornadoWindfield},
    {"Tornado Move Speed", tornadoMoveSpeed},
    {"Inward Pull Speed", tornadoInwardPullSpeed},
    {"Max Parts / Satellite", maxPartsPerSatellite},
    {"Max Sub-Vortices", maxSubVortices},
    {"Funnel Reserve Count", funnelReserveCount},
    {"Funnel Height", funnelHeight},
    {"Sub Vortex Spin Speed", subVortexSpinSpeed},
    {"Sub Vortex Height", subVortexHeight},
    {"Main Funnel Share (%)", mainFunnelShare * 100}
}

local references = {}
for i, data in ipairs(inputBoxes) do
    references[i] = createLabeledTextbox(data[1], data[2], i - 1)
end

local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0, 24, 0, 24)
toggleBtn.Position = UDim2.new(0.5, -130, 0, 10)
toggleBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.Font = Enum.Font.SourceSansBold
toggleBtn.TextSize = 16
toggleBtn.Text = "O"
toggleBtn.ZIndex = 2
toggleBtn.Parent = screenGui

local modeToggle = Instance.new("TextButton")
modeToggle.Size = UDim2.new(0, 120, 0, 24)
modeToggle.Position = UDim2.new(0.5, -100, 0, 40)
modeToggle.BackgroundColor3 = Color3.fromRGB(70, 30, 30)
modeToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
modeToggle.Font = Enum.Font.SourceSansBold
modeToggle.TextSize = 14
modeToggle.Text = "Mode: Friendly"
modeToggle.Parent = screenGui

modeToggle.MouseButton1Click:Connect(function()
    nightmareMode = not nightmareMode
    modeToggle.Text = nightmareMode and "Mode: Nightmare" or "Mode: Friendly"
end)

-- Bind UI values
references[1].FocusLost:Connect(function() local v = tonumber(references[1].Text); if v then tornadoSpinSpeed = v end end)
references[2].FocusLost:Connect(function() local v = tonumber(references[2].Text); if v then tornadoUpwardSpeed = v end end)
references[3].FocusLost:Connect(function() local v = tonumber(references[3].Text); if v then tornadoWindfield = v end end)
references[4].FocusLost:Connect(function() local v = tonumber(references[4].Text); if v then tornadoMoveSpeed = v end end)
references[5].FocusLost:Connect(function() local v = tonumber(references[5].Text); if v then tornadoInwardPullSpeed = v end end)
references[6].FocusLost:Connect(function() local v = tonumber(references[6].Text); if v then maxPartsPerSatellite = math.max(1, math.floor(v)) end end)
references[7].FocusLost:Connect(function() local v = tonumber(references[7].Text); if v then maxSubVortices = math.max(0, math.floor(v)); references[7].Text = tostring(maxSubVortices); if enabled then formSatellitesInstant() end end)
references[8].FocusLost:Connect(function() local v = tonumber(references[8].Text); if v then funnelReserveCount = math.max(0, math.floor(v)); references[8].Text = tostring(funnelReserveCount) end end)
references[9].FocusLost:Connect(function() local v = tonumber(references[9].Text); if v then funnelHeight = math.max(0, v); references[9].Text = tostring(funnelHeight) end end)
references[10].FocusLost:Connect(function() local v = tonumber(references[10].Text); if v then subVortexSpinSpeed = math.max(0, v); references[10].Text = tostring(subVortexSpinSpeed) end end)
references[11].FocusLost:Connect(function() local v = tonumber(references[11].Text); if v then subVortexHeight = math.max(0, v); references[11].Text = tostring(subVortexHeight) end end)
references[12].FocusLost:Connect(function() local v = tonumber(references[12].Text); if v then mainFunnelShare = math.clamp(v / 100, 0, 0.98); references[12].Text = tostring(mainFunnelShare * 100) end end)

-- ========== Helpers ==========
local function isPlayerPart(part)
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character and part:IsDescendantOf(plr.Character) then
            return true
        end
    end
    return false
end

local function processPartForFunnel(obj)
    if obj:IsA("BasePart") and not obj.Anchored and not isPlayerPart(obj) and obj.Name ~= baseplateName then
        if not whitelistedParts[obj] and not assignedToSatellite[obj] and not noodlePartSet[obj] and not mainFunnelSet[obj] then
            pickedUpByFunnel[obj] = true
            whitelistedParts[obj] = true
        end
    end
end

local function claimPartsForSatellite(n)
    local claimed = {}
    for part in pairs(whitelistedParts) do
        if #claimed >= n then break end
        if part and part.Parent and not part.Anchored and not debrisAttachedToPlayer[part] and not assignedToSatellite[part] and not mainFunnelSet[part] then
            table.insert(claimed, part)
            assignedToSatellite[part] = true
            whitelistedParts[part] = nil
            pickedUpByFunnel[part] = nil
        end
    end
    return claimed
end

-- Attach debris to a player's HRP using AlignPosition
local function getPlayerAttachment(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return nil end
    if playerAttachmentMap[targetPlayer] and playerAttachmentMap[targetPlayer].Parent then
        return playerAttachmentMap[targetPlayer]
    end
    local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local att = Instance.new("Attachment")
    att.Name = "Tornado_TargetAttachment"
    att.Parent = hrp
    playerAttachmentMap[targetPlayer] = att
    return att
end

local function attachDebrisToPlayer(debrisPart, targetPlayer)
    if not debrisPart or not debrisPart.Parent or not targetPlayer or not targetPlayer.Character then return end
    if debrisAttachedToPlayer[debrisPart] then return end
    if targetPlayer == localPlayer then return end

    local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    for _, x in next, debrisPart:GetChildren() do
        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition")
            or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
            x:Destroy()
        end
    end

    debrisPart.CanCollide = false

    local attachDeb = Instance.new("Attachment")
    attachDeb.Name = "Tornado_DebrisAttachment"
    attachDeb.Parent = debrisPart

    local align = Instance.new("AlignPosition")
    align.MaxForce = math.huge
    align.MaxVelocity = math.huge
    align.Responsiveness = 200
    align.Attachment0 = attachDeb
    align.Attachment1 = getPlayerAttachment(targetPlayer)
    align.Parent = debrisPart

    local torque = Instance.new("Torque")
    torque.Attachment0 = attachDeb
    torque.Parent = debrisPart

    debrisAttachedToPlayer[debrisPart] = targetPlayer
end

local function cleanupDebrisForPlayer(targetPlayer)
    for part, pl in pairs(debrisAttachedToPlayer) do
        if pl == targetPlayer then
            if part and part.Parent then
                for _, child in ipairs(part:GetChildren()) do
                    if child:IsA("AlignPosition") or child:IsA("Attachment") or child:IsA("Torque") then
                        child:Destroy()
                    end
                end
                part.CanCollide = true
            end
            debrisAttachedToPlayer[part] = nil
            assignedToSatellite[part] = nil
            whitelistedParts[part] = nil
            pickedUpByFunnel[part] = nil
            if noodlePartSet[part] then
                noodlePartSet[part] = nil
                for sid, pool in pairs(noodlePools) do pool[part] = nil end
            end
            if mainFunnelSet[part] then
                mainFunnelSet[part] = nil
                for idx, p in ipairs(mainFunnelParts) do
                    if p == part then table.remove(mainFunnelParts, idx); break end
                end
            end
        end
    end
    if playerAttachmentMap[targetPlayer] then
        if playerAttachmentMap[targetPlayer].Parent then playerAttachmentMap[targetPlayer]:Destroy() end
        playerAttachmentMap[targetPlayer] = nil
    end
end

-- ========== Main funnel reservation ==========
local function reserveMainFunnelParts()
    mainFunnelParts = {}
    mainFunnelSet = {}

    local candidates = {}
    for p in pairs(whitelistedParts) do
        if p and p.Parent and not p.Anchored and not assignedToSatellite[p] and not noodlePartSet[p] then
            local d = 0
            if tornadoPosition and p.Position then d = (p.Position - tornadoPosition).Magnitude end
            table.insert(candidates, {part = p, dist = d})
        end
    end

    if #candidates == 0 then return end

    table.sort(candidates, function(a,b) return a.dist < b.dist end)

    local available = #candidates
    local desiredByShare = math.floor(available * mainFunnelShare + 0.5)
    local take = math.min(available, math.max(funnelReserveCount, desiredByShare))

    for i = 1, take do
        local p = candidates[i].part
        if p then
            mainFunnelParts[#mainFunnelParts + 1] = p
            mainFunnelSet[p] = true
            whitelistedParts[p] = nil
            pickedUpByFunnel[p] = nil
            assignedToSatellite[p] = nil
        end
    end
end

local function teleportPartToPlayerLevel(part, currentDesiredVel)
    if not part or not part.Parent then return end
    if debrisAttachedToPlayer[part] then return end
    if not localPlayer or not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local targetY = localPlayer.Character.HumanoidRootPart.Position.Y + funnelTeleportYOffset
    part.CFrame = CFrame.new(part.Position.X, targetY, part.Position.Z)
    if currentDesiredVel then
        part.AssemblyLinearVelocity = Vector3.new(currentDesiredVel.X, math.max(math.abs(currentDesiredVel.Y), tornadoUpwardSpeed * 0.6), currentDesiredVel.Z)
    else
        part.AssemblyLinearVelocity = Vector3.new(0, tornadoUpwardSpeed * 0.8, 0)
    end
end

local function updateMainFunnel(delta)
    if not tornadoPosition then return end
    for i, p in ipairs(mainFunnelParts) do
        if not p or not p.Parent then
            mainFunnelParts[i] = nil
        else
            local offset = p.Position - tornadoPosition
            local horizontalOffset = Vector3.new(offset.X, 0, offset.Z)
            local distance = math.max(0.1, horizontalOffset.Magnitude)
            local dirToCenter = horizontalOffset.Unit
            local spinDir = Vector3.new(-dirToCenter.Z, 0, dirToCenter.X)
            local inwardPull = -dirToCenter * (tornadoInwardPullSpeed * 0.8)
            local upward = Vector3.new(0, tornadoUpwardSpeed, 0)
            local rotational = spinDir * (tornadoSpinSpeed * (1 + (distance / tornadoWindfield)))
            local finalVelocity = rotational + inwardPull + upward
            if not p.Anchored then
                p.AssemblyLinearVelocity = finalVelocity
                p.CanCollide = false
            end

            if p.Position.Y >= (tornadoPosition.Y + funnelHeight) then
                teleportPartToPlayerLevel(p, finalVelocity)
            end
        end
    end
    local newMain = {}
    for _, v in ipairs(mainFunnelParts) do if v then table.insert(newMain, v) end end
    mainFunnelParts = newMain
end

-- ========== Tornado physics (non-funnel parts) ==========
local function applyTornadoFriendly(position)
    local parts = Workspace:GetPartBoundsInRadius(position, tornadoWindfield)
    for _, obj in ipairs(parts) do
        if obj:IsA("BasePart") and not obj.Anchored and not isPlayerPart(obj) and obj.Name ~= baseplateName then
            processPartForFunnel(obj)
            if whitelistedParts[obj] and not assignedToSatellite[obj] and not noodlePartSet[obj] and not mainFunnelSet[obj] then
                local offset = obj.Position - position
                local horizontalOffset = Vector3.new(offset.X, 0, offset.Z)
                local distance = horizontalOffset.Magnitude
                local dirToCenter = distance > 0 and horizontalOffset.Unit or Vector3.zero
                local spinDir = Vector3.new(-dirToCenter.Z, 0, dirToCenter.X)
                local inwardPull = (distance > 0) and (-dirToCenter * tornadoInwardPullSpeed) or Vector3.zero
                local upward = Vector3.new(0, tornadoUpwardSpeed, 0)
                local rotational = spinDir * tornadoSpinSpeed
                obj.CanCollide = false
                obj.AssemblyLinearVelocity = rotational + inwardPull + upward
                if obj.Position.Y >= (tornadoPosition.Y + funnelHeight) and not debrisAttachedToPlayer[obj] then
                    teleportPartToPlayerLevel(obj, obj.AssemblyLinearVelocity)
                end
            end
        end
    end
end

local function applyTornadoNightmare(position)
    local parts = Workspace:GetPartBoundsInRadius(position, tornadoWindfield)
    for _, obj in ipairs(parts) do
        if obj:IsA("BasePart") and not obj.Anchored and not isPlayerPart(obj) and obj.Name ~= baseplateName then
            processPartForFunnel(obj)
            if whitelistedParts[obj] and not assignedToSatellite[obj] and not noodlePartSet[obj] and not mainFunnelSet[obj] then
                local offset = obj.Position - position
                local horizontalOffset = Vector3.new(offset.X, 0, offset.Z)
                local distance = horizontalOffset.Magnitude
                local dirToCenter = distance > 0 and horizontalOffset.Unit or Vector3.zero
                local spinDir = Vector3.new(-dirToCenter.Z, 0, dirToCenter.X)
                local inwardPull = (distance > 0) and (-dirToCenter * (tornadoInwardPullSpeed * 1.1)) or Vector3.zero
                local upward = Vector3.new(0, tornadoUpwardSpeed * 1.0, 0)
                local rotational = spinDir * (tornadoSpinSpeed * 1.2)
                obj.CanCollide = false
                obj.AssemblyLinearVelocity = rotational + inwardPull + upward
                if obj.Position.Y >= (tornadoPosition.Y + funnelHeight) and not debrisAttachedToPlayer[obj] then
                    teleportPartToPlayerLevel(obj, obj.AssemblyLinearVelocity)
                end
            end
        end
    end
end

local function tornadoLoop()
    while enabled do
        local root = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root then
            tornadoPosition = root.Position
            updateMainFunnel(0.1)
            if nightmareMode then
                applyTornadoNightmare(tornadoPosition)
            else
                applyTornadoFriendly(tornadoPosition)
            end
        end
        task.wait(0.1)
    end
end

-- ========== Player windfield targeting ==========
local function startFiringAtPlayer(targetPlayer)
    if playerTargetThreads[targetPlayer] then return end
    playerTargetThreads[targetPlayer] = true
    spawn(function()
        while playerTargetThreads[targetPlayer] and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") do
            if not nightmareMode then break end
            local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not hrp or not tornadoPosition then break end
            local dist = (hrp.Position - tornadoPosition).Magnitude
            if dist > tornadoWindfield then break end

            -- prefer noodle parts for attaching
            local candidate = nil
            for sid, pool in pairs(noodlePools) do
                for part, _ in pairs(pool) do
                    if part and part.Parent and not debrisAttachedToPlayer[part] and not part.Anchored and not mainFunnelSet[part] then
                        candidate = part
                        break
                    end
                end
                if candidate then break end
            end

            if not candidate then
                for part in pairs(whitelistedParts) do
                    if part and part.Parent and not debrisAttachedToPlayer[part] and not assignedToSatellite[part] and not mainFunnelSet[part] then
                        candidate = part
                        break
                    end
                end
            end

            if candidate then attachDebrisToPlayer(candidate, targetPlayer) end

            local waitFor = 3
            for i=1, waitFor*10 do
                if not playerTargetThreads[targetPlayer] then break end
                task.wait(0.1)
            end
        end
        cleanupDebrisForPlayer(targetPlayer)
        playerTargetThreads[targetPlayer] = nil
    end)
end

local function stopFiringAtPlayer(targetPlayer)
    playerTargetThreads[targetPlayer] = nil
    cleanupDebrisForPlayer(targetPlayer)
end

local function windfieldWatcher()
    while true do
        if tornadoPosition then
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = plr.Character.HumanoidRootPart
                    local dist = (hrp.Position - tornadoPosition).Magnitude
                    if dist <= tornadoWindfield then
                        if nightmareMode and not playerTargetThreads[plr] then startFiringAtPlayer(plr) end
                    else
                        if playerTargetThreads[plr] then stopFiringAtPlayer(plr) end
                    end
                end
            end
        end
        task.wait(1)
    end
end

-- ========== Nightmare launcher fling logic (velocity-based) ==========
local function findNearestOtherPlayer(pos)
    local best, bestDist = nil, math.huge
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local d = (plr.Character.HumanoidRootPart.Position - pos).Magnitude
            if d < bestDist then
                bestDist = d
                best = plr
            end
        end
    end
    return best, bestDist
end

local function doFlingVelocity(part, targetPos)
    if not part or not part.Parent then return end
    local dir = (targetPos - part.Position)
    local mag = dir.Magnitude
    if mag <= 0 then return end
    local unit = dir.Unit
    local launchSpeed = noodleLaunchBaseSpeed + math.random(0, noodleLaunchRandomAdd)
    part.AssemblyLinearVelocity = unit * launchSpeed + Vector3.new(0, 50, 0)
    local ang = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5)
    if ang.Magnitude > 0 then ang = ang.Unit * noodleLaunchAngular else ang = Vector3.new(0,1,0) * noodleLaunchAngular end
    pcall(function() part.AssemblyAngularVelocity = ang end)
end

-- Modified: only noodlePools[satId] parts attempt to fling; attackable flag controls main-noodles vs satellite-noodles
local function startNoodleFlingAtPlayer(targetPlayer, satId, attackable)
    if not targetPlayer or not targetPlayer.Character then return end
    spawn(function()
        -- continue while: tornado enabled AND target inside tornado windfield AND either (nightmareMode && sat is satellite) OR attackable is true
        while enabled and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and noodlePools[satId] do
            local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            local dist = (hrp.Position - (tornadoPosition or hrp.Position)).Magnitude
            -- condition whether this noodle pool may attack:
            local mayAttack = false
            if satId ~= 0 then
                -- satellite noodles: only attack in Nightmare
                mayAttack = nightmareMode
            else
                -- main funnel noodles: attack if attackable flag set OR player is in inner 1/3 radius OR nightmareMode (if you want main to attack in nightmare too)
                local innerRadius = tornadoWindfield / 3
                if attackable or dist <= innerRadius or nightmareMode then mayAttack = true end
            end

            if not mayAttack or dist > tornadoWindfield then
                -- stop attacking if the player is outside the windfield or not attackable now
                break
            end

            -- pick a noodle part from this pool and fling at player
            local pool = noodlePools[satId]
            local candidate = nil
            for part, _ in pairs(pool) do
                if part and part.Parent and not part.Anchored and not debrisAttachedToPlayer[part] then
                    candidate = part
                    break
                end
            end

            if candidate then
                doFlingVelocity(candidate, hrp.Position)
                -- remove from noodle sets so it won't be reused
                noodlePartSet[candidate] = nil
                pool[candidate] = nil
            end

            -- if no parts left in the pool, exit
            local anyLeft = false
            for _ in pairs(pool or {}) do anyLeft = true; break end
            if not anyLeft then break end

            -- wait between flings
            local waited = 0
            while waited < noodleFlingInterval and enabled and targetPlayer and targetPlayer.Character do
                task.wait(0.1)
                waited = waited + 0.1
            end
        end
    end)
end

local function nightmareLauncherLoop()
    while true do
        if enabled and nightmareMode and tornadoPosition then
            -- general fallback flings (if some noodle pools remain but weren't triggered)
            for sid, pset in pairs(noodlePools) do
                for part, _ in pairs(pset) do
                    if part and part.Parent and not debrisAttachedToPlayer[part] and not assignedToSatellite[part] and not part.Anchored and not mainFunnelSet[part] then
                        -- find nearest player to fling at
                        local targetPlr, d = findNearestOtherPlayer(part.Position)
                        if targetPlr and targetPlr.Character and targetPlr.Character:FindFirstChild("HumanoidRootPart") then
                            doFlingVelocity(part, targetPlr.Character.HumanoidRootPart.Position)
                            noodlePartSet[part] = nil
                            pset[part] = nil
                        end
                    end
                end
            end
        end
        task.wait(4 + math.random())
    end
end

-- ========== Satellite creation / lifecycle ==========
local function spawnSatelliteWithParts(pos, partsList, idOverride)
    local id = idOverride or nextSatelliteId
    if not idOverride then nextSatelliteId = nextSatelliteId + 1 end

    local partsMap = {}
    for _, p in ipairs(partsList) do
        if p and p.Parent then
            local radius = satelliteOrbitRadius + math.random(-3, 6)
            local speed = (subVortexSpinSpeed or satelliteRotationSpeed) * (1 + math.random()*0.6 - 0.3)
            partsMap[p] = {
                radius = radius,
                speed = speed,
                phase = math.random() * math.pi * 2,
                floorOffset = 2 + math.random()*2,
                topOffset = (subVortexHeight or 12) + math.random()*4,
                verticalTarget = nil,
                currentY = nil
            }
            assignedToSatellite[p] = id
            mainFunnelSet[p] = nil
        end
    end

    satelliteVortices[id] = {
        id = id,
        pos = pos,
        angleOffset = math.random() * math.pi * 2,
        parts = partsMap,
        target = nil,
        verticalChains = {},
        lastVortexSpawnTick = tick()
    }
    satelliteAttackState[id] = {attackingPlayers = {}, attackThreads = {}}
    noodlePools[id] = noodlePools[id] or {}
    return id
end

function despawnSatellite(id)
    local sat = satelliteVortices[id]
    if not sat then return end
    for part, _ in pairs(sat.parts) do
        if part and part.Parent then
            assignedToSatellite[part] = nil
            whitelistedParts[part] = true
            pickedUpByFunnel[part] = true
            for _, c in ipairs(part:GetChildren()) do
                if c:IsA("AlignPosition") or c:IsA("Attachment") or c:IsA("Torque") then c:Destroy() end
            end
            part.CanCollide = true
            if noodlePartSet[part] then
                noodlePartSet[part] = nil
            end
            if noodlePools[id] then
                noodlePools[id][part] = nil
            end
        end
    end
    satelliteVortices[id] = nil
    satelliteAttackState[id] = nil
    noodlePools[id] = nil
end

-- vertical chain (noodle) builder for satellites (1/4 parts)
local function spawnVerticalChain(sat, targetPlayer, attackable)
    if not sat or not targetPlayer or not targetPlayer.Character then return end

    local availableParts = {}
    for part, _ in pairs(sat.parts) do
        if part and part.Parent and not part.Anchored and not debrisAttachedToPlayer[part] and not mainFunnelSet[part] and not noodlePartSet[part] then
            table.insert(availableParts, part)
        end
    end
    local availableCount = #availableParts
    if availableCount == 0 then return end

    local needed = math.max(1, math.floor(availableCount * noodleFraction))
    needed = math.clamp(needed, verticalChainMinParts, math.max(verticalChainMaxParts, needed))
    needed = math.min(needed, availableCount)

    local chainParts = {}
    for i = 1, needed do
        if #availableParts == 0 then break end
        local idx = math.random(1, #availableParts)
        local p = table.remove(availableParts, idx)
        if p and p.Parent then
            table.insert(chainParts, p)
            assignedToSatellite[p] = sat.id
            sat.parts[p] = sat.parts[p] or {
                radius = satelliteOrbitRadius + math.random(-3, 6),
                speed = satelliteRotationSpeed + math.random() * 1.5,
                phase = math.random() * math.pi * 2,
                floorOffset = 2,
                topOffset = subVortexHeight,
                verticalTarget = nil,
                currentY = nil
            }
        end
    end

    if #chainParts == 0 then return end

    noodlePools[sat.id] = noodlePools[sat.id] or {}
    for _, p in ipairs(chainParts) do
        noodlePools[sat.id][p] = true
        noodlePartSet[p] = true
        whitelistedParts[p] = nil
        pickedUpByFunnel[p] = nil
    end

    local chain = {
        parts = chainParts,
        target = targetPlayer,
        progress = 0,
        speed = verticalChainSpeed * (0.8 + math.random()*0.8),
        amplitude = verticalChainAmplitude * (0.6 + math.random()*0.8),
        frequency = verticalChainFrequency * (0.8 + math.random()*0.8),
        segmentDelay = verticalChainSegmentDelay,
        ownerSatellite = sat.id,
        attackable = attackable or false,
        created = tick()
    }

    table.insert(sat.verticalChains, chain)
end

-- main-tornado noodle chain spawner (ownerSatellite = 0)
local function spawnMainNoodleChain(targetPlayer, numParts, attackable)
    if not targetPlayer or not targetPlayer.Character then return end
    if numParts <= 0 then return end
    -- gather candidate parts from mainFunnelParts
    local availableParts = {}
    for _, p in ipairs(mainFunnelParts) do
        if p and p.Parent and not p.Anchored and not noodlePartSet[p] then
            table.insert(availableParts, p)
        end
    end
    if #availableParts == 0 then return end

    local chainParts = {}
    for i = 1, math.min(numParts, #availableParts) do
        local idx = math.random(1, #availableParts)
        local p = table.remove(availableParts, idx)
        if p and p.Parent then
            table.insert(chainParts, p)
            -- mark as main-funnel assigned temporarily
            assignedToSatellite[p] = 0
        end
    end

    if #chainParts == 0 then return end

    noodlePools[0] = noodlePools[0] or {}
    for _, p in ipairs(chainParts) do
        noodlePools[0][p] = true
        noodlePartSet[p] = true
        whitelistedParts[p] = nil
        pickedUpByFunnel[p] = nil
        -- remove from mainFunnelParts list so main funnel doesn't fight for them
        for idx, q in ipairs(mainFunnelParts) do if q == p then table.remove(mainFunnelParts, idx); break end end
    end

    local chain = {
        parts = chainParts,
        target = targetPlayer,
        progress = 0,
        speed = verticalChainSpeed * (0.8 + math.random()*0.8),
        amplitude = verticalChainAmplitude * (0.6 + math.random()*0.8),
        frequency = verticalChainFrequency * (0.8 + math.random()*0.8),
        segmentDelay = verticalChainSegmentDelay,
        ownerSatellite = 0,
        attackable = attackable or false,
        created = tick()
    }

    table.insert(mainVerticalChains, chain)
end

-- ========== Satellites update (per-heartbeat) ==========
local function updateSatellites(delta)
    if not tornadoPosition then return end
    for id, sat in pairs(satelliteVortices) do
        -- determine target only in NIGHTMARE
        local best, bestDist = nil, math.huge
        if nightmareMode then
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local d = (plr.Character.HumanoidRootPart.Position - tornadoPosition).Magnitude
                    if d <= tornadoWindfield and d < bestDist then
                        bestDist = d
                        best = plr
                    end
                end
            end
        end
        sat.target = best

        -- movement: chase only in NIGHTMARE, otherwise orbit
        local pos = sat.pos
        if nightmareMode and sat.target and sat.target.Character and sat.target.Character:FindFirstChild("HumanoidRootPart") then
            local tgtPos = sat.target.Character.HumanoidRootPart.Position + Vector3.new(0, 8, 0)
            local dir = (tgtPos - pos)
            if dir.Magnitude > 0.2 then
                local move = dir.Unit * math.min(dir.Magnitude, satelliteChaseSpeed * delta)
                sat.pos = pos + Vector3.new(move.X, move.Y, move.Z)
            end
        else
            sat.angleOffset = sat.angleOffset + (0.5 * delta)
            local orbitRad = math.clamp(tornadoWindfield * 0.25, 6, tornadoWindfield * 0.7)
            local newPos = tornadoPosition + Vector3.new(math.cos(sat.angleOffset) * orbitRad, 10, math.sin(sat.angleOffset) * orbitRad)
            local dir = (newPos - pos)
            sat.pos = pos + dir * math.min(1, delta * 1.5)
        end

        -- update parts: orbital + per-part vertical between floor and top with target-based non-bob motion
        for part, meta in pairs(sat.parts) do
            if part and part.Parent then
                local center = sat.pos
                local angle = (tick() * (meta.speed)) + meta.phase
                local radiusPulse = meta.radius * (1 + 0.06 * math.sin(tick() * (0.5 + meta.speed * 0.05) + meta.phase))
                local horizTarget = center + Vector3.new(math.cos(angle) * radiusPulse, 0, math.sin(angle) * radiusPulse)

                local floorY = tornadoPosition.Y + (meta.floorOffset or 2)
                local topY = tornadoPosition.Y + (meta.topOffset or subVortexHeight)
                if not meta.currentY then meta.currentY = math.clamp(part.Position.Y, floorY, topY) end
                if not meta.verticalTarget then meta.verticalTarget = (floorY + topY) / 2 end
                if math.abs(meta.currentY - meta.verticalTarget) < 0.5 then
                    meta.verticalTarget = floorY + math.random() * (math.max(0, topY - floorY))
                end
                local interpSpeed = math.max(0.15, (meta.speed or 1) * 0.25)
                meta.currentY = meta.currentY + (meta.verticalTarget - meta.currentY) * math.clamp(delta * interpSpeed, 0, 1)

                local targetPos = Vector3.new(horizTarget.X, meta.currentY, horizTarget.Z)

                if not part.Anchored then
                    local desiredVel = (targetPos - part.Position) / math.max(delta, 0.016)
                    local maxVel = math.max(orbitVelocityMinCap, math.abs(radiusPulse * (meta.speed or 1) * orbitVelocityMultiplier))
                    if desiredVel.Magnitude > maxVel then desiredVel = desiredVel.Unit * maxVel end
                    part.AssemblyLinearVelocity = Vector3.new(desiredVel.X, math.clamp(desiredVel.Y, -140, 140), desiredVel.Z)
                    part.CanCollide = false
                end

                if part.Position.Y >= (tornadoPosition.Y + funnelHeight) and not debrisAttachedToPlayer[part] then
                    teleportPartToPlayerLevel(part, part.AssemblyLinearVelocity)
                end

                -- horizontal vortex attach in nightmare mode: ONLY noodle parts used
                if nightmareMode and noodlePartSet[part] and not debrisAttachedToPlayer[part] then
                    for _, plr in ipairs(Players:GetPlayers()) do
                        if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                            local dToPlayer = (plr.Character.HumanoidRootPart.Position - sat.pos).Magnitude
                            if dToPlayer <= horizontalVortexAttachRadius then
                                attachDebrisToPlayer(part, plr)
                                break
                            end
                        end
                    end
                end
            else
                sat.parts[part] = nil
            end
        end

        -- occasionally spawn vertical noodle chains toward target in NIGHTMARE (satellites only spawn noodles in Nightmare)
        if nightmareMode and sat.target and (tick() - sat.lastVortexSpawnTick) >= (1.5 + math.random()*2.0) then
            sat.lastVortexSpawnTick = tick()
            -- Satellite noodles should be attackable (satellites attack in Nightmare)
            spawnVerticalChain(sat, sat.target, true)
        end

        -- update vertical chains for this satellite
        for ci = #sat.verticalChains, 1, -1 do
            local chain = sat.verticalChains[ci]
            if not chain or not chain.target or not chain.target.Character then
                table.remove(sat.verticalChains, ci)
            else
                chain.progress = math.min(1.5, chain.progress + chain.speed * delta)
                local targetHRP = chain.target.Character:FindFirstChild("HumanoidRootPart")
                if targetHRP then
                    for idx, part in ipairs(chain.parts) do
                        if part and part.Parent and not part.Anchored then
                            local segT = math.clamp(chain.progress - ((idx - 1) * chain.segmentDelay), 0, 1)
                            local basePos = sat.pos
                            local goalPos = basePos:Lerp(targetHRP.Position + Vector3.new(0, 6, 0), segT)
                            local toTarget = (targetHRP.Position - basePos)
                            local horiz = Vector3.new(toTarget.X, 0, toTarget.Z)
                            local perp = (horiz.Magnitude > 0.1) and Vector3.new(-horiz.Z, 0, horiz.X).Unit or Vector3.new(1,0,0)
                            local wiggle = perp * math.sin((segT * chain.frequency) + idx) * (chain.amplitude * (1 - segT))
                            local finalPos = goalPos + wiggle + Vector3.new(0, segT * 6, 0)
                            local vel = (finalPos - part.Position) / math.max(delta, 0.016)
                            local maxVel = math.max(orbitVelocityMinCap, chain.speed * 100)
                            if vel.Magnitude > maxVel then vel = vel.Unit * maxVel end
                            part.AssemblyLinearVelocity = Vector3.new(vel.X, math.clamp(vel.Y, -140, 140), vel.Z)
                            part.CanCollide = false

                            -- when the noodle part reaches the player, remove it from chain and trigger noodle attack
                            local distToHRP = (part.Position - targetHRP.Position).Magnitude
                            if distToHRP <= verticalAttachDistance then
                                -- remove that part and start attack for the noodle pool
                                chain.parts[idx] = nil
                                -- Trigger attack for the noodle pool for this satellite (attackable true for satellite noodles)
                                startNoodleFlingAtPlayer(chain.target, chain.ownerSatellite, chain.attackable)
                            end
                        else
                            chain.parts[idx] = nil
                        end
                    end

                    local newParts = {}
                    for _, p in ipairs(chain.parts) do if p then table.insert(newParts, p) end end
                    chain.parts = newParts

                    if #chain.parts == 0 or chain.progress >= 1.4 then
                        table.remove(sat.verticalChains, ci)
                    end
                else
                    table.remove(sat.verticalChains, ci)
                end
            end
        end

        -- orbit attack (NIGHTMARE) - attaches only noodle parts
        if nightmareMode then
            local meanRadius = 0
            local countR = 0
            for _, m in pairs(sat.parts) do meanRadius = meanRadius + (m.radius or satelliteOrbitRadius); countR = countR + 1 end
            if countR > 0 then meanRadius = meanRadius / countR else meanRadius = satelliteOrbitRadius end

            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = plr.Character.HumanoidRootPart
                    local dToSat = (hrp.Position - sat.pos).Magnitude
                    local inOrbit = dToSat <= (meanRadius + 3)
                    local state = satelliteAttackState[id]
                    if inOrbit then
                        state.attackingPlayers[plr] = state.attackingPlayers[plr] or true
                        if not state.attackThreads[plr] then
                            state.attackThreads[plr] = true
                            spawn(function()
                                while state.attackingPlayers[plr] and nightmareMode do
                                    if not plr or not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then break end
                                    local curDist = (plr.Character.HumanoidRootPart.Position - sat.pos).Magnitude
                                    if curDist > (meanRadius + 6) then break end
                                    local fired = 0
                                    for part, _ in pairs(sat.parts) do
                                        if fired >= satelliteMainOrbitAttackCount then break end
                                        if part and part.Parent and not debrisAttachedToPlayer[part] and not part.Anchored and noodlePartSet[part] then
                                            attachDebrisToPlayer(part, plr)
                                            fired = fired + 1
                                        end
                                    end
                                    if fired == 0 then
                                        local extras = claimPartsForSatellite(satelliteMainOrbitAttackCount)
                                        for _, p in ipairs(extras) do
                                            if p and p.Parent then
                                                sat.parts[p] = {
                                                    radius = satelliteOrbitRadius + math.random(-3, 6),
                                                    speed = satelliteRotationSpeed + math.random() * 1.5,
                                                    phase = math.random() * math.pi * 2,
                                                    floorOffset = 2,
                                                    topOffset = subVortexHeight,
                                                    verticalTarget = nil,
                                                    currentY = nil
                                                }
                                                assignedToSatellite[p] = id
                                            end
                                        end
                                    end

                                    local waited = 0
                                    while waited < satelliteMainOrbitAttackRate do
                                        if not state.attackingPlayers[plr] then break end
                                        task.wait(0.1)
                                        waited = waited + 0.1
                                    end
                                end
                                state.attackThreads[plr] = nil
                                state.attackingPlayers[plr] = nil
                            end)
                        end
                    else
                        if state then
                            state.attackingPlayers[plr] = nil
                            state.attackThreads[plr] = nil
                        end
                    end
                end
            end
        end

        -- keep satellites visually even if empty (do not auto-despawn)
    end
end

-- ========== Satellite formation helpers (always spawn satellites) ==========
function formSatellitesInstant()
    for id, _ in pairs(satelliteVortices) do despawnSatellite(id) end

    local count = math.max(0, maxSubVortices)
    if count == 0 then return end
    if not tornadoPosition then
        local waited = 0
        while not tornadoPosition and waited < 1.0 do
            task.wait(0.05)
            waited = waited + 0.05
            local root = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
            if root then tornadoPosition = root.Position break end
        end
        if not tornadoPosition then return end
    end

    local candidateParts = {}
    local allParts = Workspace:GetPartBoundsInRadius(tornadoPosition, tornadoWindfield)
    for _, p in ipairs(allParts) do
        if p and p:IsA("BasePart") and not p.Anchored and not isPlayerPart(p) and p.Name ~= baseplateName and not assignedToSatellite[p] and not noodlePartSet[p] and not mainFunnelSet[p] then
            table.insert(candidateParts, p)
        end
    end

    table.sort(candidateParts, function(a,b)
        return (a.Position - tornadoPosition).Magnitude < (b.Position - tornadoPosition).Magnitude
    end)

    local total = #candidateParts
    local desiredByShare = math.floor(total * mainFunnelShare + 0.5)
    local mainReserve = math.clamp(desiredByShare, 0, total)
    local remainingCount = total - mainReserve

    while remainingCount < count and mainReserve > math.min(funnelReserveCount, total) do
        mainReserve = mainReserve - 1
        remainingCount = total - mainReserve
    end

    mainReserve = math.clamp(mainReserve, 0, total)
    remainingCount = total - mainReserve

    mainFunnelParts = {}
    mainFunnelSet = {}
    for i = 1, mainReserve do
        local p = candidateParts[i]
        if p then
            mainFunnelParts[#mainFunnelParts+1] = p
            mainFunnelSet[p] = true
            assignedToSatellite[p] = nil
            whitelistedParts[p] = nil
            pickedUpByFunnel[p] = nil
        end
    end

    local remainingParts = {}
    for i = mainReserve + 1, #candidateParts do remainingParts[#remainingParts+1] = candidateParts[i] end
    local totalRem = #remainingParts

    local partitions = {}
    for i = 1, count do partitions[i] = {} end

    if totalRem > 0 then
        local basePer = math.floor(totalRem / count)
        if basePer == 0 then basePer = 1 end
        local remainder = totalRem - (basePer * count)
        local idx = 1
        for i = 1, count do
            local take = math.min(basePer, maxPartsPerSatellite)
            if remainder > 0 and take < maxPartsPerSatellite then
                take = take + 1
                remainder = remainder - 1
            end
            for j = 1, take do
                if remainingParts[idx] then
                    local p = remainingParts[idx]
                    assignedToSatellite[p] = true
                    whitelistedParts[p] = nil
                    pickedUpByFunnel[p] = nil
                    table.insert(partitions[i], p)
                    idx = idx + 1
                end
            end
        end
        while idx <= #remainingParts do
            local p = remainingParts[idx]
            if p then
                mainFunnelParts[#mainFunnelParts+1] = p
                mainFunnelSet[p] = true
                assignedToSatellite[p] = nil
            end
            idx = idx + 1
        end
    end

    local orbitRad = math.clamp(tornadoWindfield * 0.3, 8, tornadoWindfield * 0.7)
    for i = 1, count do
        local angle = (2 * math.pi * (i - 1) / count) + (math.random() * 0.2 - 0.1)
        local pos = tornadoPosition + Vector3.new(math.cos(angle) * orbitRad, 10 + math.random()*6, math.sin(angle) * orbitRad)
        spawnSatelliteWithParts(pos, partitions[i] or {})
    end

    for _, p in ipairs(mainFunnelParts) do
        if p then mainFunnelSet[p] = true; whitelistedParts[p] = nil; assignedToSatellite[p] = nil; pickedUpByFunnel[p] = nil end
    end
end

-- ========== Workspace scanning & periodic tasks ==========
Workspace.DescendantAdded:Connect(function(desc)
    if desc and desc:IsA("BasePart") then
        task.defer(function()
            if enabled and tornadoPosition and (desc.Position - tornadoPosition).Magnitude <= tornadoWindfield then
                if not desc.Anchored then processPartForFunnel(desc) end
            end
        end)
    end
end)

-- periodic scan to keep funnel stocked and spawn main noodles
spawn(function()
    while true do
        if enabled and tornadoPosition then
            local parts = Workspace:GetPartBoundsInRadius(tornadoPosition, tornadoWindfield)
            for _, p in ipairs(parts) do
                if p and p:IsA("BasePart") and not p.Anchored then processPartForFunnel(p) end
            end

            reserveMainFunnelParts()

            -- spawn main noodles if conditions met
            if mainNoodleEnabled and (tick() - lastMainNoodleTick) >= mainNoodleSpawnCooldown then
                lastMainNoodleTick = tick()
                -- spawn a main noodle targeted at nearest player inside tornado (if any)
                local bestPlr, bestDist = nil, math.huge
                for _, pl in ipairs(Players:GetPlayers()) do
                    if pl ~= localPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
                        local d = (pl.Character.HumanoidRootPart.Position - tornadoPosition).Magnitude
                        if d <= tornadoWindfield and d < bestDist then
                            bestDist = d
                            bestPlr = pl
                        end
                    end
                end
                if bestPlr and #mainFunnelParts >= mainNoodleMinParts then
                    -- number of parts depends on count of mainFunnelParts
                    local num = math.max(verticalChainMinParts, math.floor(#mainFunnelParts * 0.2))
                    -- attackable only if player inside inner 1/3 radius
                    local attackable = (bestDist <= (tornadoWindfield / 3))
                    -- main noodles shouldn't attack if Friendly and not inner region
                    spawnMainNoodleChain(bestPlr, num, attackable)
                end
            end
        end
        task.wait(1)
    end
end)

-- ========== Main vertical chains update (same logic as satellites) ==========
local function updateMainVerticalChains(delta)
    if not tornadoPosition then return end
    for ci = #mainVerticalChains, 1, -1 do
        local chain = mainVerticalChains[ci]
        if not chain or not chain.target or not chain.target.Character then
            table.remove(mainVerticalChains, ci)
        else
            chain.progress = math.min(1.5, chain.progress + chain.speed * delta)
            local targetHRP = chain.target.Character:FindFirstChild("HumanoidRootPart")
            if targetHRP then
                for idx, part in ipairs(chain.parts) do
                    if part and part.Parent and not part.Anchored then
                        local segT = math.clamp(chain.progress - ((idx - 1) * chain.segmentDelay), 0, 1)
                        local basePos = tornadoPosition + Vector3.new(0, 10, 0)
                        local goalPos = basePos:Lerp(targetHRP.Position + Vector3.new(0, 6, 0), segT)
                        local toTarget = (targetHRP.Position - basePos)
                        local horiz = Vector3.new(toTarget.X, 0, toTarget.Z)
                        local perp = (horiz.Magnitude > 0.1) and Vector3.new(-horiz.Z, 0, horiz.X).Unit or Vector3.new(1,0,0)
                        local wiggle = perp * math.sin((segT * chain.frequency) + idx) * (chain.amplitude * (1 - segT))
                        local finalPos = goalPos + wiggle + Vector3.new(0, segT * 6, 0)
                        local vel = (finalPos - part.Position) / math.max(delta, 0.016)
                        local maxVel = math.max(orbitVelocityMinCap, chain.speed * 100)
                        if vel.Magnitude > maxVel then vel = vel.Unit * maxVel end
                        part.AssemblyLinearVelocity = Vector3.new(vel.X, math.clamp(vel.Y, -140, 140), vel.Z)
                        part.CanCollide = false

                        local distToHRP = (part.Position - targetHRP.Position).Magnitude
                        if distToHRP <= verticalAttachDistance then
                            chain.parts[idx] = nil
                            startNoodleFlingAtPlayer(chain.target, chain.ownerSatellite, chain.attackable)
                        end
                    else
                        chain.parts[idx] = nil
                    end
                end

                local newParts = {}
                for _, p in ipairs(chain.parts) do if p then table.insert(newParts, p) end end
                chain.parts = newParts

                if #chain.parts == 0 or chain.progress >= 1.4 then
                    table.remove(mainVerticalChains, ci)
                end
            else
                table.remove(mainVerticalChains, ci)
            end
        end
    end
end

-- ========== Heartbeat & loops ==========
RunService.Heartbeat:Connect(function(delta)
    if enabled then
        updateSatellites(delta)
        updateMainFunnel(delta)
        updateMainVerticalChains(delta)
    end
end)

spawn(windfieldWatcher)
spawn(nightmareLauncherLoop)

-- ========== Robust respawn handling ==========
local function onCharacterAdded(character)
    task.wait(0.1)
    local root = character:WaitForChild("HumanoidRootPart", 2)
    if root then tornadoPosition = root.Position end

    if enabled and tornadoPosition then
        local parts = Workspace:GetPartBoundsInRadius(tornadoPosition, tornadoWindfield)
        for _, p in ipairs(parts) do
            if p and p:IsA("BasePart") and not p.Anchored then processPartForFunnel(p) end
        end
        formSatellitesInstant()
    end
end

if localPlayer.Character then onCharacterAdded(localPlayer.Character) end
localPlayer.CharacterAdded:Connect(onCharacterAdded)

-- ========== Toggle button logic ==========
toggleBtn.MouseButton1Click:Connect(function()
    enabled = not enabled
    toggleBtn.Text = enabled and "X" or "O"
    if enabled then
        pickedUpByFunnel = {}
        whitelistedParts = {}
        assignedToSatellite = {}
        satelliteVortices = {}
        satelliteAttackState = {}
        nextSatelliteId = 1
        debrisAttachedToPlayer = {}
        noodlePools = {}
        noodlePartSet = {}
        mainFunnelParts = {}
        mainFunnelSet = {}
        mainVerticalChains = {}

        spawn(tornadoLoop)
        task.wait(0.05)
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            tornadoPosition = localPlayer.Character.HumanoidRootPart.Position
        end

        if tornadoPosition then
            local parts = Workspace:GetPartBoundsInRadius(tornadoPosition, tornadoWindfield)
            for _, p in ipairs(parts) do
                if p and p:IsA("BasePart") and not p.Anchored then processPartForFunnel(p) end
            end
        end

        reserveMainFunnelParts()
        formSatellitesInstant()
    else
        for part in pairs(whitelistedParts) do
            if part and part:IsA("BasePart") and part.Parent then
                pcall(function() part.AssemblyLinearVelocity = Vector3.zero end)
                part.CanCollide = true
                for _, child in ipairs(part:GetChildren()) do
                    if child:IsA("AlignPosition") or child:IsA("Attachment") or child:IsA("Torque") then child:Destroy() end
                end
            end
        end

        for id, _ in pairs(satelliteVortices) do despawnSatellite(id) end

        for pl, att in pairs(playerAttachmentMap) do
            if att and att.Parent then att:Destroy() end
            playerAttachmentMap[pl] = nil
        end

        for pl, _ in pairs(playerTargetThreads) do playerTargetThreads[pl] = nil end

        debrisAttachedToPlayer = {}
        whitelistedParts = {}
        pickedUpByFunnel = {}
        assignedToSatellite = {}
        satelliteVortices = {}
        satelliteAttackState = {}
        noodlePools = {}
        noodlePartSet = {}
        mainFunnelParts = {}
        mainFunnelSet = {}
        mainVerticalChains = {}
    end
end)

-- End of script
