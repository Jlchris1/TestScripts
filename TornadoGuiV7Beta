-- Tornado LocalScript â€” FULL (capacity textbox removed; new defaults applied)
-- Satellites always spawn; no per-satellite cap. Noodle -> BH -> fling preserved.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local localPlayer = Players.LocalPlayer

-- ========== Config (updated defaults) ==========
local enabled = false
local tornadoSpinSpeed = 250       -- updated default
local tornadoUpwardSpeed = 50
local tornadoWindfield = 500      -- updated default (studs)
local tornadoMoveSpeed = 10
local tornadoInwardPullSpeed = 50

local baseplateName = "Baseplate"

-- satellites (no per-satellite capacity)
local maxSubVortices = 3
local satelliteChaseSpeed = 20
local satelliteOrbitRadius = 10
local satelliteRotationSpeed = 3.5
local horizontalVortexAttachRadius = 30
local satelliteMainOrbitAttackCount = 3
local satelliteMainOrbitAttackRate = 1

-- sub-vortex adjustable params
local subVortexSpinSpeed = 3.5
local subVortexHeight = 120       -- updated default

-- main funnel share
local mainFunnelShare = 0.7 -- fraction reserved for main funnel

-- vertical vortex (noodle) settings
local verticalChainMinParts = 3
local verticalChainMaxParts = 6
local verticalChainSpeed = 0.7
local verticalChainAmplitude = 4
local verticalChainFrequency = 6
local verticalChainSegmentDelay = 0.12
local verticalAttachDistance = 2.0

-- Noodle fling settings (keep velocity behavior)
local noodleFlingInterval = 0.6
local noodleLaunchBaseSpeed = 300
local noodleLaunchRandomAdd = 200
local noodleLaunchAngular = 80

-- Orbit smoothing / cap
local orbitVelocityMinCap = 200
local orbitVelocityMultiplier = 2.5

-- Funnel-specific
local funnelReserveCount = 8
local funnelHeight = 500          -- updated default
local funnelTeleportYOffset = 5

-- ========== Runtime State ==========
local tornadoPosition = nil
local pickedUpByFunnel = {}      -- part -> true
local whitelistedParts = {}      -- part -> true
local assignedToSatellite = {}   -- part -> sat id or true
local debrisAttachedToPlayer = {}-- part -> player

local mainFunnelParts = {}       -- reserved main funnel parts list
local mainFunnelSet = {}         -- fast lookup

local satelliteVortices = {}     -- id -> sat table
local satelliteAttackState = {}  -- id -> attack state table
local nextSatelliteId = 1

local playerAttachmentMap = {}   -- player -> attachment
local playerTargetThreads = {}   -- player -> boolean

local nightmareMode = false

-- noodle pools: noodlePools[id] = { part -> true, ... } ; id is satellite id (number) or "main_<n>"
local noodlePools = {}
local noodlePartSet = {}         -- part -> true

-- tracking main noodle ids
local nextMainNoodleId = 1

-- ========== UI ==========
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "TornadoBlastGUI"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 100
screenGui.IgnoreGuiInset = true
screenGui.Parent = localPlayer:WaitForChild("PlayerGui")

local hideToggle = Instance.new("TextButton")
hideToggle.Size = UDim2.new(0, 40, 0, 20)
hideToggle.Position = UDim2.new(0, 10, 0.5, -10)
hideToggle.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
hideToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
hideToggle.Font = Enum.Font.SourceSansBold
hideToggle.TextSize = 14
hideToggle.Text = "Hide"
hideToggle.Parent = screenGui

local inputsVisible = true
local function toggleInputs()
    inputsVisible = not inputsVisible
    for _, child in ipairs(screenGui:GetChildren()) do
        if (child:IsA("TextBox") or child:IsA("TextLabel")) and not (child == hideToggle or child == toggleBtn or child == modeToggle) then
            child.Visible = inputsVisible
        end
    end
end

hideToggle.MouseButton1Click:Connect(function()
    toggleInputs()
    hideToggle.Text = inputsVisible and "Hide" or "Show"
end)

local function createLabeledTextbox(labelText, default, index)
    local perRow = 4
    local row = math.floor(index / perRow)
    local col = index % perRow
    local xOffset = 0.02 + 0.25 * col
    local yOffset = 60 + (row * 60)

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0, 160, 0, 16)
    label.Position = UDim2.new(xOffset, 0, 0, yOffset)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.SourceSans
    label.TextSize = 14
    label.ZIndex = 2
    label.Parent = screenGui

    local box = Instance.new("TextBox")
    box.Size = UDim2.new(0, 160, 0, 20)
    box.Position = UDim2.new(xOffset, 0, 0, yOffset + 18)
    box.BackgroundColor3 = Color3.fromRGB(240, 240, 240)
    box.TextColor3 = Color3.fromRGB(0, 0, 0)
    box.Font = Enum.Font.SourceSans
    box.TextSize = 14
    box.Text = tostring(default)
    box.ZIndex = 2
    box.Parent = screenGui

    return box
end

-- NOTE: removed the per-satellite capacity textbox. UI list adjusted accordingly.
local inputBoxes = {
    {"Spin Speed", tornadoSpinSpeed},
    {"Upward Speed", tornadoUpwardSpeed},
    {"Windfield Radius", tornadoWindfield},
    {"Tornado Movement Speed", tornadoMoveSpeed},
    {"Inward Pull Speed", tornadoInwardPullSpeed},
    {"Max Sub-Vortices", maxSubVortices},
    {"Funnel Reserve Count", funnelReserveCount},
    {"Funnel Height", funnelHeight},
    {"Sub Vortex Spin Speed", subVortexSpinSpeed},
    {"Sub Vortex Height", subVortexHeight},
    {"Main Funnel Share (%)", mainFunnelShare * 100}
}

local references = {}
for i, data in ipairs(inputBoxes) do
    references[i] = createLabeledTextbox(data[1], data[2], i - 1)
end

local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0, 24, 0, 24)
toggleBtn.Position = UDim2.new(0.5, -130, 0, 10)
toggleBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.Font = Enum.Font.SourceSansBold
toggleBtn.TextSize = 16
toggleBtn.Text = "O"
toggleBtn.ZIndex = 2
toggleBtn.Parent = screenGui

local modeToggle = Instance.new("TextButton")
modeToggle.Size = UDim2.new(0, 120, 0, 24)
modeToggle.Position = UDim2.new(0.5, -100, 0, 40)
modeToggle.BackgroundColor3 = Color3.fromRGB(70, 30, 30)
modeToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
modeToggle.Font = Enum.Font.SourceSansBold
modeToggle.TextSize = 14
modeToggle.Text = "Mode: Friendly"
modeToggle.Parent = screenGui

modeToggle.MouseButton1Click:Connect(function()
    nightmareMode = not nightmareMode
    modeToggle.Text = nightmareMode and "Mode: Nightmare" or "Mode: Friendly"
end)

-- Bind UI values (indices shifted after removal of capacity textbox)
references[1].FocusLost:Connect(function() local v = tonumber(references[1].Text); if v then tornadoSpinSpeed = v end end)
references[2].FocusLost:Connect(function() local v = tonumber(references[2].Text); if v then tornadoUpwardSpeed = v end end)
references[3].FocusLost:Connect(function() local v = tonumber(references[3].Text); if v then tornadoWindfield = v end end)
references[4].FocusLost:Connect(function() local v = tonumber(references[4].Text); if v then tornadoMoveSpeed = v end end)
references[5].FocusLost:Connect(function() local v = tonumber(references[5].Text); if v then tornadoInwardPullSpeed = v end end)
references[6].FocusLost:Connect(function()
    local v = tonumber(references[6].Text)
    if v then
        maxSubVortices = math.max(0, math.floor(v))
        references[6].Text = tostring(maxSubVortices)
        if enabled then formSatellitesInstant() end
    end
end)
references[7].FocusLost:Connect(function()
    local v = tonumber(references[7].Text)
    if v then
        funnelReserveCount = math.max(0, math.floor(v))
        references[7].Text = tostring(funnelReserveCount)
    end
end)
references[8].FocusLost:Connect(function()
    local v = tonumber(references[8].Text)
    if v then
        funnelHeight = math.max(0, v)
        references[8].Text = tostring(funnelHeight)
    end
end)
references[9].FocusLost:Connect(function()
    local v = tonumber(references[9].Text)
    if v then
        subVortexSpinSpeed = math.max(0, v)
        references[9].Text = tostring(subVortexSpinSpeed)
    end
end)
references[10].FocusLost:Connect(function()
    local v = tonumber(references[10].Text)
    if v then
        subVortexHeight = math.max(0, v)
        references[10].Text = tostring(subVortexHeight)
    end
end)
references[11].FocusLost:Connect(function()
    local v = tonumber(references[11].Text)
    if v then
        mainFunnelShare = math.clamp(v / 100, 0, 0.98)
        references[11].Text = tostring(mainFunnelShare * 100)
    end
end)

-- ========== Helper functions ==========
local function isPlayerPart(part)
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character and part:IsDescendantOf(plr.Character) then
            return true
        end
    end
    return false
end

local function processPartForFunnel(obj)
    if obj:IsA("BasePart") and not obj.Anchored and not isPlayerPart(obj) and obj.Name ~= baseplateName then
        if not whitelistedParts[obj] and not assignedToSatellite[obj] and not noodlePartSet[obj] and not mainFunnelSet[obj] then
            pickedUpByFunnel[obj] = true
            whitelistedParts[obj] = true
        end
    end
end

local function claimPartsForSatellite(n)
    local claimed = {}
    for part in pairs(whitelistedParts) do
        if #claimed >= n then break end
        if part and part.Parent and not part.Anchored and not debrisAttachedToPlayer[part] and not assignedToSatellite[part] and not mainFunnelSet[part] then
            table.insert(claimed, part)
            assignedToSatellite[part] = true
            whitelistedParts[part] = nil
            pickedUpByFunnel[part] = nil
        end
    end
    return claimed
end

local function makeMainNoodleId()
    local id = "main_" .. tostring(nextMainNoodleId)
    nextMainNoodleId = nextMainNoodleId + 1
    return id
end

-- Attach debris to a player's HRP using AlignPosition
local function getPlayerAttachment(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return nil end
    if playerAttachmentMap[targetPlayer] and playerAttachmentMap[targetPlayer].Parent then
        return playerAttachmentMap[targetPlayer]
    end
    local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local att = Instance.new("Attachment")
    att.Name = "Tornado_TargetAttachment"
    att.Parent = hrp
    playerAttachmentMap[targetPlayer] = att
    return att
end

local function attachDebrisToPlayer(debrisPart, targetPlayer)
    if not debrisPart or not debrisPart.Parent or not targetPlayer or not targetPlayer.Character then return end
    if debrisAttachedToPlayer[debrisPart] then return end
    if targetPlayer == localPlayer then return end

    local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    for _, x in next, debrisPart:GetChildren() do
        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition")
            or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
            x:Destroy()
        end
    end

    debrisPart.CanCollide = false

    local attachDeb = Instance.new("Attachment")
    attachDeb.Name = "Tornado_DebrisAttachment"
    attachDeb.Parent = debrisPart

    local align = Instance.new("AlignPosition")
    align.MaxForce = math.huge
    align.MaxVelocity = math.huge
    align.Responsiveness = 200
    align.Attachment0 = attachDeb
    align.Attachment1 = getPlayerAttachment(targetPlayer)
    align.Parent = debrisPart

    local torque = Instance.new("Torque")
    torque.Attachment0 = attachDeb
    torque.Parent = debrisPart

    debrisAttachedToPlayer[debrisPart] = targetPlayer
end

local function cleanupDebrisForPlayer(targetPlayer)
    for part, pl in pairs(debrisAttachedToPlayer) do
        if pl == targetPlayer then
            if part and part.Parent then
                for _, child in ipairs(part:GetChildren()) do
                    if child:IsA("AlignPosition") or child:IsA("Attachment") or child:IsA("Torque") then
                        child:Destroy()
                    end
                end
                part.CanCollide = true
            end
            debrisAttachedToPlayer[part] = nil
            assignedToSatellite[part] = nil
            whitelistedParts[part] = nil
            pickedUpByFunnel[part] = nil
            if noodlePartSet[part] then
                noodlePartSet[part] = nil
                for sid, pool in pairs(noodlePools) do pool[part] = nil end
            end
            if mainFunnelSet[part] then
                mainFunnelSet[part] = nil
                for idx, p in ipairs(mainFunnelParts) do
                    if p == part then table.remove(mainFunnelParts, idx); break end
                end
            end
        end
    end
    if playerAttachmentMap[targetPlayer] then
        if playerAttachmentMap[targetPlayer].Parent then playerAttachmentMap[targetPlayer]:Destroy() end
        playerAttachmentMap[targetPlayer] = nil
    end
end

-- ========== Tornado (main funnel) handling ==========
local function reserveMainFunnelParts()
    mainFunnelParts = {}
    mainFunnelSet = {}

    -- gather candidates from whitelistedParts
    local candidates = {}
    for p in pairs(whitelistedParts) do
        if p and p.Parent and not p.Anchored and not assignedToSatellite[p] and not noodlePartSet[p] then
            local d = 0
            if tornadoPosition and p.Position then d = (p.Position - tornadoPosition).Magnitude end
            table.insert(candidates, {part = p, dist = d})
        end
    end

    if #candidates == 0 then return end

    table.sort(candidates, function(a,b) return a.dist < b.dist end)

    -- dynamically decide how many to reserve for main funnel:
    local available = #candidates
    local desiredByShare = math.floor(available * mainFunnelShare + 0.5)
    local take = math.min(available, math.max(funnelReserveCount, desiredByShare))

    for i = 1, take do
        local p = candidates[i].part
        if p then
            mainFunnelParts[#mainFunnelParts + 1] = p
            mainFunnelSet[p] = true
            whitelistedParts[p] = nil
            pickedUpByFunnel[p] = nil
            assignedToSatellite[p] = nil
        end
    end
end

local function teleportPartToPlayerLevel(part, currentDesiredVel)
    if not part or not part.Parent then return end
    if debrisAttachedToPlayer[part] then return end
    if not localPlayer or not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local targetY = localPlayer.Character.HumanoidRootPart.Position.Y + funnelTeleportYOffset
    part.CFrame = CFrame.new(part.Position.X, targetY, part.Position.Z)
    if currentDesiredVel then
        part.AssemblyLinearVelocity = Vector3.new(currentDesiredVel.X, math.max(math.abs(currentDesiredVel.Y), tornadoUpwardSpeed * 0.6), currentDesiredVel.Z)
    else
        part.AssemblyLinearVelocity = Vector3.new(0, tornadoUpwardSpeed * 0.8, 0)
    end
end

local function updateMainFunnel(delta)
    if not tornadoPosition then return end
    for i, p in ipairs(mainFunnelParts) do
        if not p or not p.Parent then
            mainFunnelParts[i] = nil
        else
            local offset = p.Position - tornadoPosition
            local horizontalOffset = Vector3.new(offset.X, 0, offset.Z)
            local distance = math.max(0.1, horizontalOffset.Magnitude)
            local dirToCenter = horizontalOffset.Unit
            local spinDir = Vector3.new(-dirToCenter.Z, 0, dirToCenter.X)
            local inwardPull = -dirToCenter * (tornadoInwardPullSpeed * 0.8)
            local upward = Vector3.new(0, tornadoUpwardSpeed, 0)
            local rotational = spinDir * (tornadoSpinSpeed * (1 + (distance / tornadoWindfield)))
            local finalVelocity = rotational + inwardPull + upward
            if not p.Anchored then
                p.AssemblyLinearVelocity = finalVelocity
                p.CanCollide = false
            end

            if p.Position.Y >= (tornadoPosition.Y + funnelHeight) then
                teleportPartToPlayerLevel(p, finalVelocity)
            end
        end
    end
    local newMain = {}
    for _, v in ipairs(mainFunnelParts) do if v then table.insert(newMain, v) end end
    mainFunnelParts = newMain
end

-- ========== Tornado physics (non-funnel parts) ==========
local function applyTornadoFriendly(position)
    local parts = Workspace:GetPartBoundsInRadius(position, tornadoWindfield)
    for _, obj in ipairs(parts) do
        if obj:IsA("BasePart") and not obj.Anchored and not isPlayerPart(obj) and obj.Name ~= baseplateName then
            processPartForFunnel(obj)
            if whitelistedParts[obj] and not assignedToSatellite[obj] and not noodlePartSet[obj] and not mainFunnelSet[obj] then
                local offset = obj.Position - position
                local horizontalOffset = Vector3.new(offset.X, 0, offset.Z)
                local distance = horizontalOffset.Magnitude
                local dirToCenter = distance > 0 and horizontalOffset.Unit or Vector3.zero
                local spinDir = Vector3.new(-dirToCenter.Z, 0, dirToCenter.X)
                local inwardPull = (distance > 0) and (-dirToCenter * tornadoInwardPullSpeed) or Vector3.zero
                local upward = Vector3.new(0, tornadoUpwardSpeed, 0)
                local rotational = spinDir * tornadoSpinSpeed
                obj.CanCollide = false
                obj.AssemblyLinearVelocity = rotational + inwardPull + upward
                if obj.Position.Y >= (tornadoPosition.Y + funnelHeight) and not debrisAttachedToPlayer[obj] then
                    teleportPartToPlayerLevel(obj, obj.AssemblyLinearVelocity)
                end
            end
        end
    end
end

local function applyTornadoNightmare(position)
    local parts = Workspace:GetPartBoundsInRadius(position, tornadoWindfield)
    for _, obj in ipairs(parts) do
        if obj:IsA("BasePart") and not obj.Anchored and not isPlayerPart(obj) and obj.Name ~= baseplateName then
            processPartForFunnel(obj)
            if whitelistedParts[obj] and not assignedToSatellite[obj] and not noodlePartSet[obj] and not mainFunnelSet[obj] then
                local offset = obj.Position - position
                local horizontalOffset = Vector3.new(offset.X, 0, offset.Z)
                local distance = horizontalOffset.Magnitude
                local dirToCenter = distance > 0 and horizontalOffset.Unit or Vector3.zero
                local spinDir = Vector3.new(-dirToCenter.Z, 0, dirToCenter.X)
                local inwardPull = (distance > 0) and (-dirToCenter * (tornadoInwardPullSpeed * 1.1)) or Vector3.zero
                local upward = Vector3.new(0, tornadoUpwardSpeed * 1.0, 0)
                local rotational = spinDir * (tornadoSpinSpeed * 1.2)
                obj.CanCollide = false
                obj.AssemblyLinearVelocity = rotational + inwardPull + upward
                if obj.Position.Y >= (tornadoPosition.Y + funnelHeight) and not debrisAttachedToPlayer[obj] then
                    teleportPartToPlayerLevel(obj, obj.AssemblyLinearVelocity)
                end
            end
        end
    end
end

local function tornadoLoop()
    while enabled do
        local root = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root then
            tornadoPosition = root.Position
            updateMainFunnel(0.1)
            if nightmareMode then
                applyTornadoNightmare(tornadoPosition)
            else
                applyTornadoFriendly(tornadoPosition)
            end
        end
        task.wait(0.1)
    end
end

-- ========== Player windfield targeting ==========
local function startFiringAtPlayer(targetPlayer)
    if playerTargetThreads[targetPlayer] then return end
    playerTargetThreads[targetPlayer] = true
    spawn(function()
        while playerTargetThreads[targetPlayer] and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") do
            if not nightmareMode then break end
            local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not hrp or not tornadoPosition then break end
            local dist = (hrp.Position - tornadoPosition).Magnitude
            if dist > tornadoWindfield then break end

            -- prefer noodle parts (from any noodle pool)
            local candidate = nil
            for sid, pool in pairs(noodlePools) do
                for part, _ in pairs(pool) do
                    if part and part.Parent and not debrisAttachedToPlayer[part] and not part.Anchored and not mainFunnelSet[part] then
                        candidate = part
                        break
                    end
                end
                if candidate then break end
            end

            if not candidate then
                for part in pairs(whitelistedParts) do
                    if part and part.Parent and not debrisAttachedToPlayer[part] and not assignedToSatellite[part] and not mainFunnelSet[part] then
                        candidate = part
                        break
                    end
                end
            end

            if candidate then attachDebrisToPlayer(candidate, targetPlayer) end

            local waitFor = 3
            for i=1, waitFor*10 do
                if not playerTargetThreads[targetPlayer] then break end
                task.wait(0.1)
            end
        end
        cleanupDebrisForPlayer(targetPlayer)
        playerTargetThreads[targetPlayer] = nil
    end)
end

local function stopFiringAtPlayer(targetPlayer)
    playerTargetThreads[targetPlayer] = nil
    cleanupDebrisForPlayer(targetPlayer)
end

local function windfieldWatcher()
    while true do
        if tornadoPosition then
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = plr.Character.HumanoidRootPart
                    local dist = (hrp.Position - tornadoPosition).Magnitude
                    if dist <= tornadoWindfield then
                        if nightmareMode and not playerTargetThreads[plr] then startFiringAtPlayer(plr) end
                    else
                        if playerTargetThreads[plr] then stopFiringAtPlayer(plr) end
                    end
                end
            end
        end
        task.wait(1)
    end
end

-- ========== Fling helper (keeps velocity/fling behavior) ==========
local function findNearestOtherPlayer(pos)
    local best, bestDist = nil, math.huge
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local d = (plr.Character.HumanoidRootPart.Position - pos).Magnitude
            if d < bestDist then
                bestDist = d
                best = plr
            end
        end
    end
    return best, bestDist
end

local function doFlingVelocity(part, targetPos)
    if not part or not part.Parent then return end
    local dir = (targetPos - part.Position)
    local mag = dir.Magnitude
    if mag <= 0 then return end
    local unit = dir.Unit
    local launchSpeed = noodleLaunchBaseSpeed + math.random(0, noodleLaunchRandomAdd)
    -- Keep velocity fling mechanism (AssemblyLinearVelocity) for consistent, immediate flings
    part.AssemblyLinearVelocity = unit * launchSpeed + Vector3.new(0, 50, 0)
    -- angular velocity visual
    local ang = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5)
    if ang.Magnitude == 0 then ang = Vector3.new(0.1,0.1,0.1) end
    ang = ang.Unit * noodleLaunchAngular
    pcall(function() part.AssemblyAngularVelocity = ang end)
end

local function startNoodleFlingAtPlayer(targetPlayer, poolId)
    if not targetPlayer or not targetPlayer.Character or not noodlePools[poolId] then return end
    spawn(function()
        local pool = noodlePools[poolId]
        if not pool then return end
        local partsList = {}
        for part,_ in pairs(pool) do table.insert(partsList, part) end
        -- shuffle
        local function shuffle(t) for i = #t,2,-1 do local j = math.random(1,i); t[i],t[j] = t[j],t[i] end end
        shuffle(partsList)

        while #partsList > 0 and nightmareMode and enabled and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") do
            if not tornadoPosition then break end
            local hrp = targetPlayer.Character.HumanoidRootPart
            local distToTornado = (hrp.Position - tornadoPosition).Magnitude
            if distToTornado > tornadoWindfield then break end

            local p = table.remove(partsList, 1)
            if p and p.Parent and not p.Anchored and not debrisAttachedToPlayer[p] then
                doFlingVelocity(p, hrp.Position)
                -- remove from noodlePools and noodlePartSet
                if pool[p] then pool[p] = nil end
                noodlePartSet[p] = nil
            end

            local waited = 0
            while waited < noodleFlingInterval and nightmareMode and enabled and targetPlayer and targetPlayer.Character do
                task.wait(0.05)
                waited = waited + 0.05
            end
        end

        -- clear noodle pool entry if empty
        if noodlePools[poolId] then
            local anyLeft = false
            for k,_ in pairs(noodlePools[poolId]) do anyLeft = true; break end
            if not anyLeft then noodlePools[poolId] = nil end
        end
    end)
end

-- ========== Satellite creation / lifecycle ==========
local function createSatelliteMarker(sat)
    if sat.marker and sat.marker.Parent then return end
    local m = Instance.new("Part")
    m.Name = "SatelliteMarker"
    m.Size = Vector3.new(1,1,1)
    m.Anchored = true
    m.CanCollide = false
    m.Material = Enum.Material.Neon
    m.Transparency = 0
    m.TopSurface = Enum.SurfaceType.Smooth
    m.BottomSurface = Enum.SurfaceType.Smooth
    m.Parent = Workspace
    sat.marker = m
    return m
end

local function removeSatelliteMarker(sat)
    if sat and sat.marker and sat.marker.Parent then
        pcall(function() sat.marker:Destroy() end)
        sat.marker = nil
    end
end

local function spawnSatelliteWithParts(pos, partsList, idOverride)
    local id = idOverride or nextSatelliteId
    if not idOverride then nextSatelliteId = nextSatelliteId + 1 end

    local partsMap = {}
    for _, p in ipairs(partsList) do
        if p and p.Parent then
            local radius = satelliteOrbitRadius + math.random(-3, 6)
            local speed = (subVortexSpinSpeed or satelliteRotationSpeed) * (1 + (math.random()*0.6 - 0.3))
            partsMap[p] = {
                radius = radius,
                speed = speed,
                phase = math.random() * math.pi * 2,
                floorOffset = 2 + math.random()*2,
                topOffset = (subVortexHeight or 12) + math.random()*4,
                verticalTarget = nil,
                currentY = nil
            }
            assignedToSatellite[p] = id
            mainFunnelSet[p] = nil
        end
    end

    satelliteVortices[id] = {
        id = id,
        pos = pos,
        angleOffset = 0,
        parts = partsMap,
        target = nil,
        verticalChains = {},
        lastVortexSpawnTick = tick(),
        marker = nil
    }
    satelliteAttackState[id] = {attackingPlayers = {}, attackThreads = {}}

    -- If satellite empty, create a visible marker so user sees it
    local partCount = 0
    for p,_ in pairs(partsMap) do if p and p.Parent then partCount = partCount + 1 end end
    if partCount == 0 then
        createSatelliteMarker(satelliteVortices[id])
    end
    return id
end

local function despawnSatellite(id)
    local sat = satelliteVortices[id]
    if not sat then return end
    for part, _ in pairs(sat.parts) do
        if part and part.Parent then
            assignedToSatellite[part] = nil
            whitelistedParts[part] = true
            pickedUpByFunnel[part] = true
            for _, c in ipairs(part:GetChildren()) do
                if c:IsA("AlignPosition") or c:IsA("Attachment") or c:IsA("Torque") then c:Destroy() end
            end
            part.CanCollide = true
            if noodlePartSet[part] then
                noodlePartSet[part] = nil
            end
            if noodlePools[id] then
                noodlePools[id][part] = nil
            end
        end
    end
    removeSatelliteMarker(sat)
    satelliteVortices[id] = nil
    satelliteAttackState[id] = nil
    noodlePools[id] = nil
end

-- vertical chain (noodle) builder (uses only fraction of satellite parts)
local function spawnVerticalChain(sat, targetPlayer)
    if not sat or not targetPlayer or not targetPlayer.Character then return end
    if not nightmareMode then return end

    local availableParts = {}
    for part, _ in pairs(sat.parts) do
        if part and part.Parent and not part.Anchored and not debrisAttachedToPlayer[part] and not mainFunnelSet[part] and not noodlePartSet[part] then
            table.insert(availableParts, part)
        end
    end
    local availableCount = #availableParts
    if availableCount == 0 then return end

    local needed = math.max(1, math.floor(availableCount * 0.25))
    needed = math.clamp(needed, verticalChainMinParts, math.max(verticalChainMaxParts, needed))

    local chainParts = {}
    for i = 1, needed do
        if #availableParts == 0 then break end
        local idx = math.random(1, #availableParts)
        local p = table.remove(availableParts, idx)
        if p and p.Parent then
            table.insert(chainParts, p)
            assignedToSatellite[p] = sat.id
            sat.parts[p] = sat.parts[p] or {
                radius = satelliteOrbitRadius + math.random(-3, 6),
                speed = satelliteRotationSpeed + math.random() * 1.5,
                phase = math.random() * math.pi * 2,
                floorOffset = 2,
                topOffset = subVortexHeight,
                verticalTarget = nil,
                currentY = nil
            }
        end
    end

    if #chainParts == 0 then return end

    noodlePools[sat.id] = noodlePools[sat.id] or {}
    for _, p in ipairs(chainParts) do
        noodlePools[sat.id][p] = true
        noodlePartSet[p] = true
        whitelistedParts[p] = nil
        pickedUpByFunnel[p] = nil
    end

    local chain = {
        parts = chainParts,
        target = targetPlayer,
        progress = 0,
        speed = verticalChainSpeed * (0.8 + math.random()*0.8),
        amplitude = verticalChainAmplitude * (0.6 + math.random()*0.8),
        frequency = verticalChainFrequency * (0.8 + math.random()*0.8),
        segmentDelay = verticalChainSegmentDelay,
        ownerSatellite = sat.id,
        created = tick()
    }

    table.insert(sat.verticalChains, chain)
end

local function convertChainToActiveBH(sat, chain)
    if not chain or not chain.target then return end
    local target = chain.target
    local poolId = sat.id
    noodlePools[poolId] = noodlePools[poolId] or {}
    for _, p in ipairs(chain.parts) do
        if p and p.Parent then
            noodlePools[poolId][p] = true
            noodlePartSet[p] = true
            sat.parts[p] = sat.parts[p] or {}
        end
    end
    startNoodleFlingAtPlayer(target, poolId)
end

-- main noodles: create main noodle pools from main funnel parts (Nightmare only)
local function spawnMainNoodleIfNeeded()
    if not enabled or not nightmareMode then return end
    if not tornadoPosition then return end
    local count = #mainFunnelParts
    if count < 4 then return end
    local makeCount = math.max(1, math.floor(count * 0.20)) -- take 20% of main funnel parts
    local selected = {}
    for i=1, makeCount do
        local p = table.remove(mainFunnelParts, 1)
        if not p then break end
        mainFunnelSet[p] = nil
        assignedToSatellite[p] = nil
        whitelistedParts[p] = nil
        pickedUpByFunnel[p] = nil
        table.insert(selected, p)
    end
    if #selected == 0 then return end
    local poolId = makeMainNoodleId()
    noodlePools[poolId] = {}
    for _, p in ipairs(selected) do
        noodlePools[poolId][p] = true
        noodlePartSet[p] = true
    end

    -- decide whether these main noodles should attack immediately:
    local centerRadius = tornadoWindfield / 3
    local best, bestDist = nil, math.huge
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= localPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            local d = (pl.Character.HumanoidRootPart.Position - tornadoPosition).Magnitude
            if d <= centerRadius and d < bestDist then best = pl; bestDist = d end
        end
    end
    if best then
        startNoodleFlingAtPlayer(best, poolId)
    end
end

-- Monitor main funnel and periodically spawn main noodles (Nightmare only)
spawn(function()
    while true do
        if enabled and nightmareMode and tornadoPosition then
            spawnMainNoodleIfNeeded()
        end
        task.wait(4 + math.random()*2)
    end
end)

-- ========== Satellites update (per-heartbeat) ==========
local function updateSatellites(delta)
    if not tornadoPosition then return end
    for id, sat in pairs(satelliteVortices) do
        -- determine target only in NIGHTMARE
        local best, bestDist = nil, math.huge
        if nightmareMode then
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local d = (plr.Character.HumanoidRootPart.Position - tornadoPosition).Magnitude
                    if d <= tornadoWindfield and d < bestDist then
                        bestDist = d
                        best = plr
                    end
                end
            end
        end
        sat.target = best

        -- movement: chase only in NIGHTMARE, otherwise orbit (satellites spawn in both)
        local pos = sat.pos
        if nightmareMode and sat.target and sat.target.Character and sat.target.Character:FindFirstChild("HumanoidRootPart") then
            local tgtPos = sat.target.Character.HumanoidRootPart.Position + Vector3.new(0, 8, 0)
            local dir = (tgtPos - pos)
            if dir.Magnitude > 0.2 then
                local move = dir.Unit * math.min(dir.Magnitude, satelliteChaseSpeed * delta)
                sat.pos = pos + Vector3.new(move.X, move.Y, move.Z)
            end
        else
            sat.angleOffset = sat.angleOffset + (0.5 * delta)
            local orbitRad = math.clamp(tornadoWindfield * 0.25, 6, tornadoWindfield * 0.7)
            local newPos = tornadoPosition + Vector3.new(math.cos(sat.angleOffset) * orbitRad, 10, math.sin(sat.angleOffset) * orbitRad)
            local dir = (newPos - pos)
            sat.pos = pos + dir * math.min(1, delta * 1.5)
        end

        -- update marker if present
        if sat.marker then
            pcall(function() sat.marker.CFrame = CFrame.new(sat.pos + Vector3.new(0,2,0)) end)
        end

        -- update parts: orbital + per-part vertical between floor and top with target-based non-bob motion
        for part, meta in pairs(sat.parts) do
            if part and part.Parent then
                local center = sat.pos
                local angle = (tick() * (meta.speed)) + meta.phase
                local radiusPulse = meta.radius * (1 + 0.06 * math.sin(tick() * (0.5 + meta.speed * 0.05) + meta.phase))
                local horizTarget = center + Vector3.new(math.cos(angle) * radiusPulse, 0, math.sin(angle) * radiusPulse)

                local floorY = tornadoPosition.Y + (meta.floorOffset or 2)
                local topY = tornadoPosition.Y + (meta.topOffset or subVortexHeight)
                if not meta.currentY then meta.currentY = math.clamp(part.Position.Y, floorY, topY) end
                if not meta.verticalTarget then meta.verticalTarget = (floorY + topY) / 2 end
                if math.abs(meta.currentY - meta.verticalTarget) < 0.5 then
                    meta.verticalTarget = floorY + math.random() * (math.max(0, topY - floorY))
                end
                local interpSpeed = math.max(0.15, (meta.speed or 1) * 0.25)
                meta.currentY = meta.currentY + (meta.verticalTarget - meta.currentY) * math.clamp(delta * interpSpeed, 0, 1)

                local targetPos = Vector3.new(horizTarget.X, meta.currentY, horizTarget.Z)

                if not part.Anchored then
                    local desiredVel = (targetPos - part.Position) / math.max(delta, 0.016)
                    local maxVel = math.max(orbitVelocityMinCap, math.abs(radiusPulse * (meta.speed or 1) * orbitVelocityMultiplier))
                    if desiredVel.Magnitude > maxVel then desiredVel = desiredVel.Unit * maxVel end
                    part.AssemblyLinearVelocity = Vector3.new(desiredVel.X, math.clamp(desiredVel.Y, -140, 140), desiredVel.Z)
                    part.CanCollide = false
                end

                -- teleport satellite part if it reaches the funnelHeight threshold
                if part.Position.Y >= (tornadoPosition.Y + funnelHeight) and not debrisAttachedToPlayer[part] then
                    teleportPartToPlayerLevel(part, part.AssemblyLinearVelocity)
                end

                -- horizontal vortex attach in nightmare mode: ONLY noodle parts used
                if nightmareMode and noodlePartSet[part] and not debrisAttachedToPlayer[part] then
                    for _, plr in ipairs(Players:GetPlayers()) do
                        if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                            local dToPlayer = (plr.Character.HumanoidRootPart.Position - sat.pos).Magnitude
                            if dToPlayer <= horizontalVortexAttachRadius then
                                attachDebrisToPlayer(part, plr)
                                break
                            end
                        end
                    end
                end
            else
                sat.parts[part] = nil
            end
        end

        -- occasionally spawn vertical noodle chains toward target in NIGHTMARE
        if nightmareMode and sat.target and (tick() - sat.lastVortexSpawnTick) >= (1.5 + math.random()*2.0) then
            sat.lastVortexSpawnTick = tick()
            spawnVerticalChain(sat, sat.target)
        end

        -- update vertical chains (these move towards the target; when they touch the target we convert the whole chain into active noodle BH)
        for ci = #sat.verticalChains, 1, -1 do
            local chain = sat.verticalChains[ci]
            if not chain or not chain.target or not chain.target.Character then
                table.remove(sat.verticalChains, ci)
            else
                chain.progress = math.min(1.5, chain.progress + chain.speed * delta)
                local targetHRP = chain.target.Character:FindFirstChild("HumanoidRootPart")
                if targetHRP then
                    for idx, part in ipairs(chain.parts) do
                        if part and part.Parent and not part.Anchored then
                            local segT = math.clamp(chain.progress - ((idx - 1) * chain.segmentDelay), 0, 1)
                            local basePos = sat.pos
                            local goalPos = basePos:Lerp(targetHRP.Position + Vector3.new(0, 6, 0), segT)
                            local toTarget = (targetHRP.Position - basePos)
                            local horiz = Vector3.new(toTarget.X, 0, toTarget.Z)
                            local perp = (horiz.Magnitude > 0.1) and Vector3.new(-horiz.Z, 0, horiz.X).Unit or Vector3.new(1,0,0)
                            local wiggle = perp * math.sin((segT * chain.frequency) + idx) * (chain.amplitude * (1 - segT))
                            local finalPos = goalPos + wiggle + Vector3.new(0, segT * 6, 0)
                            local vel = (finalPos - part.Position) / math.max(delta, 0.016)
                            local maxVel = math.max(orbitVelocityMinCap, chain.speed * 100)
                            if vel.Magnitude > maxVel then vel = vel.Unit * maxVel end
                            part.AssemblyLinearVelocity = Vector3.new(vel.X, math.clamp(vel.Y, -140, 140), vel.Z)
                            part.CanCollide = false

                            -- if a part touches the player's HRP, convert the *entire chain* into an active noodle BH
                            local distToHRP = (part.Position - targetHRP.Position).Magnitude
                            if distToHRP <= verticalAttachDistance then
                                -- convert chain to active noodle BH and remove it from verticalChains
                                convertChainToActiveBH(sat, chain)
                                table.remove(sat.verticalChains, ci)
                                break -- break idx loop since chain removed
                            end
                        else
                            chain.parts[idx] = nil
                        end
                    end
                else
                    table.remove(sat.verticalChains, ci)
                end
            end
        end

        -- orbit attack (NIGHTMARE) - attaches only noodle parts
        if nightmareMode then
            local meanRadius = 0
            local countR = 0
            for _, m in pairs(sat.parts) do meanRadius = meanRadius + (m.radius or satelliteOrbitRadius); countR = countR + 1 end
            if countR > 0 then meanRadius = meanRadius / countR else meanRadius = satelliteOrbitRadius end

            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = plr.Character.HumanoidRootPart
                    local dToSat = (hrp.Position - sat.pos).Magnitude
                    local inOrbit = dToSat <= (meanRadius + 3)
                    local state = satelliteAttackState[id]
                    if inOrbit then
                        state.attackingPlayers[plr] = state.attackingPlayers[plr] or true
                        if not state.attackThreads[plr] then
                            state.attackThreads[plr] = true
                            spawn(function()
                                while state.attackingPlayers[plr] and nightmareMode do
                                    if not plr or not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then break end
                                    local curDist = (plr.Character.HumanoidRootPart.Position - sat.pos).Magnitude
                                    if curDist > (meanRadius + 6) then break end
                                    local fired = 0
                                    for part, _ in pairs(sat.parts) do
                                        if fired >= satelliteMainOrbitAttackCount then break end
                                        if part and part.Parent and not debrisAttachedToPlayer[part] and not part.Anchored and noodlePartSet[part] then
                                            attachDebrisToPlayer(part, plr)
                                            fired = fired + 1
                                        end
                                    end
                                    if fired == 0 then
                                        local extras = claimPartsForSatellite(satelliteMainOrbitAttackCount)
                                        for _, p in ipairs(extras) do
                                            if p and p.Parent then
                                                sat.parts[p] = {
                                                    radius = satelliteOrbitRadius + math.random(-3, 6),
                                                    speed = satelliteRotationSpeed + math.random() * 1.5,
                                                    phase = math.random() * math.pi * 2,
                                                    floorOffset = 2,
                                                    topOffset = subVortexHeight,
                                                    verticalTarget = nil,
                                                    currentY = nil
                                                }
                                                assignedToSatellite[p] = id
                                            end
                                        end
                                    end

                                    local waited = 0
                                    while waited < satelliteMainOrbitAttackRate do
                                        if not state.attackingPlayers[plr] then break end
                                        task.wait(0.1)
                                        waited = waited + 0.1
                                    end
                                end
                                state.attackThreads[plr] = nil
                                state.attackingPlayers[plr] = nil
                            end)
                        end
                    else
                        if state then
                            state.attackingPlayers[plr] = nil
                            state.attackThreads[plr] = nil
                        end
                    end
                end
            end
        end

        -- cleanup: keep satellites visually even if empty
    end
end

-- ========== Satellite formation helpers (always spawn satellites; perfect alignment; even distribution) ==========
function formSatellitesInstant()
    for id, _ in pairs(satelliteVortices) do despawnSatellite(id) end

    local count = math.max(0, maxSubVortices)
    if count == 0 then return end

    -- ensure we always have a tornadoPosition to place satellites (use player's HRP if needed)
    if not tornadoPosition and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        tornadoPosition = localPlayer.Character.HumanoidRootPart.Position
    end

    local spawnCenter = tornadoPosition or (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and localPlayer.Character.HumanoidRootPart.Position) or Vector3.new(0,10,0)
    local allParts = Workspace:GetPartBoundsInRadius(spawnCenter, tornadoWindfield)
    local candidateParts = {}
    for _, p in ipairs(allParts) do
        if p and p:IsA("BasePart") and not p.Anchored and not isPlayerPart(p) and p.Name ~= baseplateName and not assignedToSatellite[p] and not noodlePartSet[p] and not mainFunnelSet[p] then
            table.insert(candidateParts, p)
        end
    end

    local total = #candidateParts
    table.sort(candidateParts, function(a,b)
        return (a.Position - spawnCenter).Magnitude < (b.Position - spawnCenter).Magnitude
    end)

    local desiredByShare = math.floor(total * mainFunnelShare + 0.5)
    local mainReserve = math.clamp(desiredByShare, 0, total)
    local remainingCount = total - mainReserve

    while remainingCount < count and mainReserve > math.min(funnelReserveCount, total) do
        mainReserve = mainReserve - 1
        remainingCount = total - mainReserve
    end

    mainReserve = math.clamp(mainReserve, 0, total)
    remainingCount = total - mainReserve

    mainFunnelParts = {}
    mainFunnelSet = {}
    for i = 1, mainReserve do
        local p = candidateParts[i]
        if p then
            mainFunnelParts[#mainFunnelParts+1] = p
            mainFunnelSet[p] = true
            assignedToSatellite[p] = nil
            whitelistedParts[p] = nil
            pickedUpByFunnel[p] = nil
        end
    end

    local remainingParts = {}
    for i = mainReserve + 1, #candidateParts do remainingParts[#remainingParts+1] = candidateParts[i] end
    local totalRem = #remainingParts

    local partitions = {}
    for i = 1, count do partitions[i] = {} end

    if totalRem > 0 then
        local idx = 1
        for _, p in ipairs(remainingParts) do
            local slot = ((idx - 1) % count) + 1
            table.insert(partitions[slot], p)
            assignedToSatellite[p] = true
            whitelistedParts[p] = nil
            pickedUpByFunnel[p] = nil
            idx = idx + 1
        end
    end

    local orbitRad = math.clamp(tornadoWindfield * 0.3, 8, tornadoWindfield * 0.7)
    for i = 1, count do
        local angle = (2 * math.pi * (i - 1) / count) -- exact equal angle for perfect polygon
        local pos = spawnCenter + Vector3.new(math.cos(angle) * orbitRad, 10 + math.random()*6, math.sin(angle) * orbitRad)
        spawnSatelliteWithParts(pos, partitions[i] or {})
        local newId = nextSatelliteId - 1
        if satelliteVortices[newId] then satelliteVortices[newId].angleOffset = angle end
    end

    for _, p in ipairs(mainFunnelParts) do
        if p then mainFunnelSet[p] = true; whitelistedParts[p] = nil; assignedToSatellite[p] = nil; pickedUpByFunnel[p] = nil end
    end
end

-- ========== Workspace scanning & DescendantAdded ==========
Workspace.DescendantAdded:Connect(function(desc)
    if desc and desc:IsA("BasePart") then
        task.defer(function()
            if enabled and tornadoPosition and (desc.Position - tornadoPosition).Magnitude <= tornadoWindfield then
                if not desc.Anchored then processPartForFunnel(desc) end
            end
        end)
    end
end)

-- periodic scan to keep funnel stocked
spawn(function()
    while true do
        if enabled and tornadoPosition then
            local parts = Workspace:GetPartBoundsInRadius(tornadoPosition, tornadoWindfield)
            for _, p in ipairs(parts) do
                if p and p:IsA("BasePart") and not p.Anchored then processPartForFunnel(p) end
            end
            reserveMainFunnelParts()
        end
        task.wait(1)
    end
end)

-- ========== Heartbeat & loops ==========
RunService.Heartbeat:Connect(function(delta)
    if enabled then
        updateSatellites(delta)
        updateMainFunnel(delta)
    end
end)

spawn(windfieldWatcher)

-- ========== Robust respawn handling ==========
local function onCharacterAdded(character)
    task.wait(0.1)
    local root = character:WaitForChild("HumanoidRootPart", 2)
    if root then tornadoPosition = root.Position end

    if enabled and tornadoPosition then
        local parts = Workspace:GetPartBoundsInRadius(tornadoPosition, tornadoWindfield)
        for _, p in ipairs(parts) do
            if p and p:IsA("BasePart") and not p.Anchored then processPartForFunnel(p) end
        end
        formSatellitesInstant()
    end
end

if localPlayer.Character then onCharacterAdded(localPlayer.Character) end
localPlayer.CharacterAdded:Connect(onCharacterAdded)

-- ========== Toggle button logic ==========
toggleBtn.MouseButton1Click:Connect(function()
    enabled = not enabled
    toggleBtn.Text = enabled and "X" or "O"
    if enabled then
        pickedUpByFunnel = {}
        whitelistedParts = {}
        assignedToSatellite = {}
        satelliteVortices = {}
        satelliteAttackState = {}
        nextSatelliteId = 1
        debrisAttachedToPlayer = {}
        noodlePools = {}
        noodlePartSet = {}
        mainFunnelParts = {}
        mainFunnelSet = {}

        spawn(tornadoLoop)
        task.wait(0.05)
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            tornadoPosition = localPlayer.Character.HumanoidRootPart.Position
        end

        if tornadoPosition then
            local parts = Workspace:GetPartBoundsInRadius(tornadoPosition, tornadoWindfield)
            for _, p in ipairs(parts) do
                if p and p:IsA("BasePart") and not p.Anchored then processPartForFunnel(p) end
            end
        end

        reserveMainFunnelParts()
        formSatellitesInstant()
    else
        for part in pairs(whitelistedParts) do
            if part and part:IsA("BasePart") and part.Parent then
                pcall(function() part.AssemblyLinearVelocity = Vector3.zero end)
                part.CanCollide = true
                for _, child in ipairs(part:GetChildren()) do
                    if child:IsA("AlignPosition") or child:IsA("Attachment") or child:IsA("Torque") then child:Destroy() end
                end
            end
        end

        for id, _ in pairs(satelliteVortices) do despawnSatellite(id) end

        for pl, att in pairs(playerAttachmentMap) do
            if att and att.Parent then att:Destroy() end
            playerAttachmentMap[pl] = nil
        end

        for pl, _ in pairs(playerTargetThreads) do playerTargetThreads[pl] = nil end

        debrisAttachedToPlayer = {}
        whitelistedParts = {}
        pickedUpByFunnel = {}
        assignedToSatellite = {}
        satelliteVortices = {}
        satelliteAttackState = {}
        noodlePools = {}
        noodlePartSet = {}
        mainFunnelParts = {}
        mainFunnelSet = {}
    end
end)

-- End of script
