-- Full updated script (client) - v5
-- Changes in this version:
-- 1) Improved targeting and part-hold accuracy (AlignOrientation + tuned AlignPosition params).
-- 2) Fixed LifeCycle helpers (tryStartCycleIfNeeded, endCycleMode, resetCycleNow, etc.).
-- 3) Added Spawn Seeking toggle: creates persistent BH attachments on SpawnLocation parts (player spawn points) and World spawn points; they participate in distribution equally; deleted spawn parts are detected and cleaned up.
-- 4) Removed GUI buttons and chat commands for manual creation/deletion of command blackholes (those are no longer in the GUI or chat commands).
-- 5) Minor cleanup and defensive guards.

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer

local function clamp(val, a, b)
    if val < a then return a end
    if val > b then return b end
    return val
end

-- ====== CONFIG / STATE ======
local targetAllActive = false
local targetSelectedActive = false
local primaryLoopRunning = false

local switchDelay = 0.13
local processedParts = {}
local initiallyAnchoredParts = {}
local initiallyMasslessParts = {} -- store original Massless state to restore later
local anchoredOnce = false
local unanchorTimerRunning = false
local unanchorCoroutine

local Attachment1 = nil

local extraBlackHoles = {}

-- PAA state
local PAAEnabled = false
local PAA_isUsingSelected = false
local paaConnections = {}

-- Rebalancer
local rebalancerRunning = false
local rebalancerFreq = 0.10

-- Minimum parts that a PAA blackhole must hold before we consider reassigning it
local MIN_PARTS_PER_PAA_BH = 2

local alignResponsiveness_base = 1500

-- BH motion
local BH_SWAP_INTERVAL = 0.01
local BH_OSC_FREQUENCY = 1 / (BH_SWAP_INTERVAL * 2)
local BH_AMPLITUDE_FACTOR = 0.22
local BH_MIN_AMPLITUDE = 0.6
local BH_MAX_AMPLITUDE = 80
local TARGET_SMOOTHNESS = 6.0

local ROTATE_INTERVAL = 0.2

local LifeCycleMode = false
local cycleActive = false
local cyclePlayers = {}
local cycleDead = {}
local cycleConns = {}
local cycleRestartPending = false

-- Spawn seeking
local spawnSeekingEnabled = false
local spawnConnections = {}

-- When true, blackholes will aim at the HEAD of a target player instead of the HumanoidRootPart
local targetHeadEnabled = false

-- USER-REQUESTED VALUES (extreme)
local fallenpartsdestroyheight = 0/0 -- NaN

local BASE_FLING_AXIS = 1e6
local BASE_PULL_FORCE = 1e8
local BASE_PULL_RESP  = 1e6

local FLING_MULTIPLIER = 10000000000      -- 1e10 (added two zeros)      -- 1e8
local PULL_MULTIPLIER  = 100000000000000  -- 1e14 (added two zeros)  -- 1e12

local FLING_TORQUE = Vector3.new(BASE_FLING_AXIS * FLING_MULTIPLIER,
                                 BASE_FLING_AXIS * FLING_MULTIPLIER,
                                 BASE_FLING_AXIS * FLING_MULTIPLIER) -- 1e14
local PULL_MAX_FORCE = BASE_PULL_FORCE * PULL_MULTIPLIER -- 1e20
local PULL_RESPONSIVENESS = BASE_PULL_RESP * PULL_MULTIPLIER -- 1e18

local MASSLESS_TORQUE_SCALE = 1.0
local MASSLESS_PULL_SCALE  = 1.0
local MASSLESS_RESP_SCALE  = 1.2

-- AGGRESSIVE SKID SETTINGS
local SKID_SMOOTHNESS = 40.0

-- Prediction helpers (velocity history)
local playerLastVel = {}
local playerLastVelTime = {}

-- Setup folder & primary attachment
local function setupPlayer()
    local Folder = Workspace:FindFirstChild("ÆS_BlackHole_Folder")
    if not Folder then
        Folder = Instance.new("Folder", Workspace)
        Folder.Name = "ÆS_BlackHole_Folder"
    end
    local existing = Folder:FindFirstChild("BH_Center_Part")
    if existing and existing:IsA("BasePart") then
        local att = existing:FindFirstChildOfClass("Attachment")
        if att then return att end
        local newAtt = Instance.new("Attachment", existing)
        return newAtt
    end
    local Part = Instance.new("Part", Folder)
    Part.Name = "BH_Center_Part"
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1
    Part.Size = Vector3.new(1,1,1)
    local Attachment = Instance.new("Attachment", Part)
    return Attachment
end

Attachment1 = setupPlayer()

-- helpers
local function isNPC(character)
    if not character or not character:IsA("Model") then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and not Players:GetPlayerFromCharacter(character) then return true end
    return false
end

local function isPartPlayerCharacter(part)
    if not part then return false end
    for _, pl in ipairs(Players:GetPlayers()) do
        local char = pl.Character
        if char and part:IsDescendantOf(char) then
            return true
        end
    end
    return false
end

local function stripBodyForces(part)
    for _, x in next, part:GetChildren() do
        if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro")
        or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity")
        or x:IsA("RocketPropulsion") then
            x:Destroy()
        end
    end
    if part:FindFirstChild("Attachment") then part:FindFirstChild("Attachment"):Destroy() end
    if part:FindFirstChild("AlignPosition") then part:FindFirstChild("AlignPosition"):Destroy() end
    if part:FindFirstChild("Torque") then part:FindFirstChild("Torque"):Destroy() end
    if part:FindFirstChild("AlignOrientation") then part:FindFirstChild("AlignOrientation"):Destroy() end
end

local function shuffle(t)
    for i = #t, 2, -1 do
        local j = math.random(1, i)
        t[i], t[j] = t[j], t[i]
    end
end

local function smoothLerpCFrame(curCF, targetCF, dt)
    local alpha = 1 - math.exp(-TARGET_SMOOTHNESS * dt)
    if alpha < 0.001 then alpha = 0.001 end
    if alpha > 1 then alpha = 1 end
    return curCF:Lerp(targetCF, alpha)
end

local function isWhitelisted(player)
    if not player then return false end
    local v = player:FindFirstChild("Whitelisted")
    if v and typeof(v.Value) == "boolean" then
        return v.Value
    end
    return false
end

local function isPlayerAlive(player)
    if not player then return false end
    local char = player.Character
    if not char then return false end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    if humanoid.Health and humanoid.Health > 0 then return true end
    return false
end

local function getAllNonLocalPlayers()
    local res = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p and p ~= localPlayer and p.Parent and not isWhitelisted(p) then
            table.insert(res, p)
        end
    end
    return res
end

local function getSelectedPlayers(allowWhitelisted)
    local res = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player and player ~= localPlayer and player.Parent then
            local sel = player:FindFirstChild("Selected")
            if sel and typeof(sel.Value) == "boolean" and sel.Value == true then
                if allowWhitelisted then
                    table.insert(res, player)
                else
                    if not isWhitelisted(player) then table.insert(res, player) end
                end
            end
        end
    end
    return res
end

local function getBHsBySource(source)
    local out = {}
    for _, bh in ipairs(extraBlackHoles) do
        if bh.source == source then table.insert(out, bh) end
    end
    return out
end

local function getLeastLoadedBlackHole()
    if #extraBlackHoles == 0 then return nil end
    table.sort(extraBlackHoles, function(a,b) return (#a.AssignedParts) < (#b.AssignedParts) end)
    return extraBlackHoles[1]
end

-- Predict using velocity + acceleration estimate (deterministic)
local function predictTargetPosition(pl, pos, vel, now)
    local lastV = playerLastVel[pl]
    local lastT = playerLastVelTime[pl]
    local accel = Vector3.new(0,0,0)
    if lastV and lastT and now and now > lastT then
        accel = (vel - lastV) / (now - lastT)
    end
    playerLastVel[pl] = vel
    playerLastVelTime[pl] = now

    local speed = vel.Magnitude
    local leadFactor = clamp(0.25 + (speed * 0.06), 0.25, 1.8)
    local tlead = leadFactor
    local predicted = pos + vel * tlead + 0.5 * accel * (tlead * tlead)
    return predicted, leadFactor, accel
end

-- ForcePart (also massless handling)
local function ForcePart(v)
    if not v or not v:IsA("BasePart") then return end
    if isPartPlayerCharacter(v) then return end
    if localPlayer.Character and v:IsDescendantOf(localPlayer.Character) then return end

    if v:IsA("BasePart")
        and not v.Anchored
        and v.Name ~= "Handle"
        and (
            (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
            or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
        ) then

        if processedParts[v] then return end
        processedParts[v] = true

        if initiallyMasslessParts[v] == nil then
            pcall(function() initiallyMasslessParts[v] = v.Massless end)
        end

        pcall(function() v.Massless = true end)

        stripBodyForces(v)
        v.CanCollide = false

        local torqueVal = FLING_TORQUE
        local ok, isMass = pcall(function() return v.Massless end)
        if ok and isMass == true then
            torqueVal = torqueVal * MASSLESS_TORQUE_SCALE
        end
        local Torque = Instance.new("Torque", v)
        Torque.Torque = torqueVal

        local AlignPosition = Instance.new("AlignPosition", v)
        local Attachment2 = Instance.new("Attachment", v)
        pcall(function() Attachment2.WorldCFrame = v.CFrame end)
        Torque.Attachment0 = Attachment2

        -- Add AlignOrientation for better hold accuracy (improves part orientation stability)
        local AlignOrientation = Instance.new("AlignOrientation", v)
        local AttachOri = Instance.new("Attachment", v)
        pcall(function() AttachOri.WorldCFrame = v.CFrame end)
        AlignOrientation.Attachment0 = AttachOri

        local maxF = PULL_MAX_FORCE
        local resp  = PULL_RESPONSIVENESS
        if ok and isMass == true then
            maxF = maxF * MASSLESS_PULL_SCALE
            resp  = resp * MASSLESS_RESP_SCALE
        end

        AlignPosition.MaxForce = maxF
        AlignPosition.MaxVelocity = math.huge
        AlignPosition.Responsiveness = resp
        AlignPosition.Attachment0 = Attachment2

        -- Tune AlignOrientation
        AlignOrientation.MaxTorque = maxF * 0.5
        AlignOrientation.Responsiveness = resp * 0.8
        AlignOrientation.Attachment1 = nil -- will be assigned by rebalancer

        local bh = getLeastLoadedBlackHole()
        if bh and bh.Attachment and bh._active then
            AlignPosition.Attachment1 = bh.Attachment
            AlignOrientation.Attachment1 = bh.Attachment
            table.insert(bh.AssignedParts, v)
        else
            AlignPosition.Attachment1 = Attachment1
            AlignOrientation.Attachment1 = Attachment1
        end
    end
end

-- FLING FUNCTION: temporarily applies strong forces/torques to a player's character parts
local function flingPlayer(targetPlayer, intensity, duration)
    intensity = intensity or 1.0
    duration = duration or 0.6
    if not targetPlayer or not targetPlayer.Parent then return end
    local char = targetPlayer.Character
    if not char then return end

    local created = {}
    local function safeMake(parent, ctor)
        local ok, inst = pcall(function()
            local i = ctor()
            i.Parent = parent
            return i
        end)
        return ok and inst or nil
    end

    -- Compute a fling direction away from our central attachment (if available) or upwards
    local awayPoint = nil
    pcall(function() if Attachment1 and Attachment1.Parent then awayPoint = Attachment1.WorldPosition end end)
    if not awayPoint then awayPoint = (char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position) or Vector3.new(0,0,0) end

    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            -- skip heavy/welded tooling like HumanoidRootPart? include HRP for impact
            pcall(function()
                -- BodyVelocity to push part away
                local bv = safeMake(part, function()
                    local o = Instance.new("BodyVelocity")
                    o.MaxForce = Vector3.new(1e9,1e9,1e9) * intensity
                    local dir = (part.Position - awayPoint)
                    if dir.Magnitude < 1 then dir = Vector3.new(math.random()-0.5, 1, math.random()-0.5) end
                    o.Velocity = dir.Unit * (200 * intensity) + Vector3.new(0, 150 * intensity, 0)
                    o.P = 3000
                    return o
                end)
                if bv then table.insert(created, bv) end

                -- BodyAngularVelocity to spin
                local bav = safeMake(part, function()
                    local o = Instance.new("BodyAngularVelocity")
                    o.MaxTorque = Vector3.new(1e9,1e9,1e9) * intensity
                    o.AngularVelocity = Vector3.new(math.random(-50,50), math.random(-50,50), math.random(-50,50)) * intensity
                    return o
                end)
                if bav then table.insert(created, bav) end

                -- Torque for extra force (matches the script's FLING_TORQUE constant)
                local ok, torque = pcall(function()
                    local t = Instance.new("Torque")
                    t.Torque = FLING_TORQUE * intensity
                    t.Parent = part
                    return t
                end)
                if ok and torque then table.insert(created, torque) end
            end)
        end
    end

    -- Cleanup after duration
    spawn(function()
        wait(duration)
        for _, inst in ipairs(created) do
            pcall(function() if inst and inst.Parent then inst:Destroy() end end)
        end
    end)
end

-- Spin parts very fast on a player's character (pure angular velocity + torque)
local function spinPartsFastOnCharacter(targetPlayer, intensity, duration)
    intensity = intensity or 1.0
    duration = duration or 0.6
    if not targetPlayer or not targetPlayer.Parent then return end
    local char = targetPlayer.Character
    if not char then return end

    local created = {}
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            pcall(function()
                local bav = Instance.new("BodyAngularVelocity")
                bav.MaxTorque = Vector3.new(1e9,1e9,1e9) * intensity
                bav.AngularVelocity = Vector3.new(200 * intensity, 200 * intensity, 200 * intensity)
                bav.Parent = part
                table.insert(created, bav)

                local tq = Instance.new("Torque")
                tq.Torque = FLING_TORQUE * (0.25 * intensity)
                tq.Parent = part
                table.insert(created, tq)
            end)
        end
    end

    spawn(function()
        wait(duration)
        for _, inst in ipairs(created) do
            pcall(function() if inst and inst.Parent then inst:Destroy() end end)
        end
    end)
end

local function clearProcessedParts()
    for part, _ in pairs(processedParts) do
        if part and part.Parent then
            stripBodyForces(part)
            part.CanCollide = true
            if initiallyAnchoredParts[part] == false then
                part.Anchored = false
            elseif initiallyAnchoredParts[part] == true then
                part.Anchored = true
            end

            if initiallyMasslessParts[part] ~= nil then
                local original = initiallyMasslessParts[part]
                pcall(function() part.Massless = original end)
            else
                pcall(function() part.Massless = false end)
            end
        end
    end
    processedParts = {}
    initiallyAnchoredParts = {}
    initiallyMasslessParts = {}
    anchoredOnce = false
end

local function anchorAndDelayedUnanchorParts()
    unanchorTimerRunning = true

    local candidateParts = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart")
            and not v.Anchored
            and v.Name ~= "Handle"
            and not isPartPlayerCharacter(v)
            and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character))
            and (
                (v.Parent:FindFirstChildOfClass("Humanoid") and isNPC(v.Parent))
                or (not v.Parent:FindFirstChildOfClass("Humanoid") and not v.Parent:FindFirstChild("Head"))
            ) then
            table.insert(candidateParts, v)
        end
    end

    initiallyAnchoredParts = {}
    for _, part in ipairs(candidateParts) do
        initiallyAnchoredParts[part] = false
        if initiallyMasslessParts[part] == nil then
            pcall(function() initiallyMasslessParts[part] = part.Massless end)
        end
        pcall(function() part.Massless = true end)

        part.Anchored = true
        part.CanCollide = false
    end

    for _, npcCandidate in ipairs(Workspace:GetChildren()) do
        if isNPC(npcCandidate) then
            for _, p in ipairs(npcCandidate:GetDescendants()) do
                if p:IsA("BasePart") then p.CanCollide = true end
            end
        end
    end

    local startTime = tick()
    while (targetAllActive or targetSelectedActive) and tick() - startTime < 1 do
        wait(0.05)
    end

    for _, part in ipairs(candidateParts) do
        if part and part.Parent and initiallyAnchoredParts[part] == false then
            part.Anchored = false
            pcall(function()
                if not isPartPlayerCharacter(part) and not (localPlayer.Character and part:IsDescendantOf(localPlayer.Character)) then
                    initiallyMasslessParts[part] = initiallyMasslessParts[part] or part.Massless
                    part.Massless = true
                end
            end)
            ForcePart(part)
        end
    end

    unanchorTimerRunning = false
    anchoredOnce = true
end

local descendantAddedConn
local function processWorkspaceParts()
    if descendantAddedConn then
        descendantAddedConn:Disconnect()
        descendantAddedConn = nil
    end

    if (targetAllActive or targetSelectedActive) then
        if not unanchorTimerRunning and not anchoredOnce then
            unanchorCoroutine = coroutine.create(anchorAndDelayedUnanchorParts)
            coroutine.resume(unanchorCoroutine)
        end

        descendantAddedConn = Workspace.DescendantAdded:Connect(function(v)
            if (targetAllActive or targetSelectedActive) then
                if v:IsA("BasePart")
                    and not v.Anchored
                    and not processedParts[v]
                    and not isPartPlayerCharacter(v)
                    and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
                    if initiallyMasslessParts[v] == nil then
                        pcall(function() initiallyMasslessParts[v] = v.Massless end)
                    end
                    pcall(function() v.Massless = true end)
                    ForcePart(v)
                end
            end
        end)
    end
end

local function getRandomPlayer()
    local players = getAllNonLocalPlayers()
    if #players == 0 then return nil end
    return players[math.random(1, #players)]
end

-- set BH active/inactive
local function setBlackHoleActiveState(bh, active)
    if not bh then return end
    if bh._active == active then return end
    bh._active = active
    if not active then
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                p.CanCollide = true
                local ap = p:FindFirstChildOfClass("AlignPosition")
                local ao = p:FindFirstChildOfClass("AlignOrientation")
                if ap then
                    ap.Attachment1 = Attachment1
                    pcall(function()
                        local isMass = (pcall(function() return p.Massless end) and p.Massless)
                        ap.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                        ap.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                    end)
                end
                if ao then ao.Attachment1 = Attachment1 end
            end
        end
    else
        for _, p in ipairs(bh.AssignedParts) do
            if p and p.Parent then
                local ap = p:FindFirstChildOfClass("AlignPosition")
                local ao = p:FindFirstChildOfClass("AlignOrientation")
                if ap then ap.Attachment1 = bh.Attachment; p.CanCollide = false end
                if ao then ao.Attachment1 = bh.Attachment end
            end
        end
    end
end

-- create extra BH helper
local function createExtraBlackHole(initialTarget, source, spawnRef)
    if initialTarget == localPlayer then initialTarget = nil end
    if initialTarget and isWhitelisted(initialTarget) and source ~= "CMD_ALLOW_WHITELISTED" then
        initialTarget = nil
    end

    local folder = Workspace:FindFirstChild("ÆS_BlackHole_Folder") or Instance.new("Folder", Workspace)
    folder.Name = "ÆS_BlackHole_Folder"
    local part = Instance.new("Part", folder)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1,1,1)
    part.Name = "ExtraBH_Center"

    local att = Instance.new("Attachment", part)

    local bh = {
        Part = part,
        Attachment = att,
        AssignedParts = {},
        TargetPlayer = initialTarget,
        LastTarget = nil,
        _running = true,
        _active = true,
        source = source or "CMD",
        rotating = false,
        smoothedCF = part.CFrame,
        spawnRef = spawnRef or nil
    }

    local function isPlayerDisabled(pl)
        if not pl then return false end
        if pl:FindFirstChild("Disabled") and typeof(pl.Disabled.Value) == "boolean" then
            return pl.Disabled.Value
        end
        return false
    end

    -- If created for a spawnRef, position it there initially and listen for spawn removal
    if spawnRef and spawnRef:IsA("BasePart") then
        pcall(function() part.CFrame = spawnRef.CFrame end)
        -- cleanup if spawn is removed
        if spawnRef.Parent then
            local acon = spawnRef.AncestryChanged:Connect(function()
                if not spawnRef.Parent then
                    -- spawn removed; destroy BH
                    bh._running = false
                    destroyExtraBlackHole(bh)
                    -- remove from list
                    for i = #extraBlackHoles, 1, -1 do if extraBlackHoles[i] == bh then table.remove(extraBlackHoles, i); break end end
                end
            end)
            spawnConnections[#spawnConnections+1] = acon
        end
    end

    -- BH behavior thread (AGGRESSIVE straight-line skidding)
    bh._thread = spawn(function()
        local t = 0
        while bh._running do
            local dt = RunService.Heartbeat:Wait()
            t = t + dt

            if bh.TargetPlayer and bh.TargetPlayer ~= localPlayer and not isWhitelisted(bh.TargetPlayer) and isPlayerAlive(bh.TargetPlayer) then
                if isPlayerDisabled(bh.TargetPlayer) then
                    setBlackHoleActiveState(bh, false)
                else
                    setBlackHoleActiveState(bh, true)

                    local char = bh.TargetPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        local targetPart = nil
                        if targetHeadEnabled and char:FindFirstChild("Head") then
                            targetPart = char.Head
                        else
                            targetPart = char:FindFirstChild("HumanoidRootPart")
                        end
                        local hrp = targetPart
                        local pos = hrp.Position
                        local vel = hrp.Velocity or Vector3.new(0,0,0)
                        local now = tick()

                        -- precise deterministic prediction
                        local predictedPos, leadFactor, accel = predictTargetPosition(bh.TargetPlayer, pos, vel, now)
                        local speed = vel.Magnitude

                        -- Compute straight-line skid endpoints:
                        -- total skid length = 2 * speed (user requirement)
                        local dir
                        if speed > 0.001 then
                            dir = vel.Unit
                        else
                            dir = hrp.CFrame.LookVector
                        end

                        local halfLen = speed
                        if halfLen < 0.5 then halfLen = 0.5 end

                        local baseFreq = 8.0
                        local freq = baseFreq + (speed * 3.0)
                        if freq < 6 then freq = 6 end

                        local phase = t * (2 * math.pi * freq)
                        local s = math.sin(phase)

                        local offset = dir * (s * halfLen)
                        local desiredPos = predictedPos + offset

                        local lookAt = predictedPos + dir
                        local targetCF = CFrame.new(desiredPos, lookAt)

                        local effectiveSmooth = SKID_SMOOTHNESS * (1 + speed * 0.8)
                        if effectiveSmooth < 1.0 then effectiveSmooth = 1.0 end

                        local skidAlpha = 1 - math.exp(-effectiveSmooth * dt)
                        if skidAlpha < 0.01 then skidAlpha = 0.01 end
                        if skidAlpha > 0.999 then skidAlpha = 0.999 end

                        local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                        local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame

                        bh.smoothedCF = curCF:Lerp(targetCF, skidAlpha)

                        if att then
                            att.WorldCFrame = bh.smoothedCF
                        end
                    end
                end
            else
                -- No valid targets: idle behavior
                local hasValidTargets = false
                for _, pl in ipairs(Players:GetPlayers()) do
                    if pl ~= localPlayer and pl.Parent and not isWhitelisted(pl) and isPlayerAlive(pl) then
                        hasValidTargets = true
                        break
                    end
                end

                if not hasValidTargets then
                    setBlackHoleActiveState(bh, false)
                    if Attachment1 and Attachment1.Parent and att then
                        local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                        local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame
                        local centerCF
                        pcall(function() centerCF = Attachment1.WorldCFrame end)
                        if centerCF then
                            local targetCF = centerCF
                            local idleAlpha = 1 - math.exp(- (SKID_SMOOTHNESS * 1.2) * dt)
                            if idleAlpha < 0.01 then idleAlpha = 0.01 end
                            if idleAlpha > 0.99 then idleAlpha = 0.99 end
                            bh.smoothedCF = curCF:Lerp(targetCF, idleAlpha)
                            att.WorldCFrame = bh.smoothedCF
                        end
                    end
                    wait(0.06)
                else
                    if att then
                        local success, cur = pcall(function() return bh.Attachment.WorldCFrame end)
                        local curCF = success and cur or bh.smoothedCF or bh.Part.CFrame
                        local idleAlpha = 1 - math.exp(- (SKID_SMOOTHNESS * 0.6) * dt)
                        if idleAlpha < 0.01 then idleAlpha = 0.01 end
                        if idleAlpha > 0.85 then idleAlpha = 0.85 end
                        bh.smoothedCF = curCF:Lerp(curCF, idleAlpha)
                        att.WorldCFrame = bh.smoothedCF
                    end
                end
            end
        end
    end)

    table.insert(extraBlackHoles, bh)
    return bh
end

local function destroyExtraBlackHole(bh)
    if not bh then return end
    bh._running = false
    if bh.Part and bh.Part.Parent then bh.Part:Destroy() end
    for i = #bh.AssignedParts, 1, -1 do
        local p = bh.AssignedParts[i]
        if p and p.Parent then
            local ap = p:FindFirstChildOfClass("AlignPosition")
            local ao = p:FindFirstChildOfClass("AlignOrientation")
            if ap then ap.Attachment1 = Attachment1 end
            if ao then ao.Attachment1 = Attachment1 end
            p.CanCollide = false
            if initiallyMasslessParts[p] ~= nil then
                pcall(function() p.Massless = initiallyMasslessParts[p] end)
            else
                pcall(function() p.Massless = false end)
            end
        end
    end
end

local function deleteBHsBySource(source)
    for i = #extraBlackHoles, 1, -1 do
        local bh = extraBlackHoles[i]
        if bh and bh.source == source then
            destroyExtraBlackHole(bh)
            table.remove(extraBlackHoles, i)
        end
    end
end

local function deleteAllExtraBlackHoles()
    for _, bh in ipairs(extraBlackHoles) do destroyExtraBlackHole(bh) end
    extraBlackHoles = {}
    if not Attachment1 or not Attachment1.Parent then Attachment1 = setupPlayer() end
    stopRebalancer()
end

-- rotating/distribution code (unchanged except defensive guards)
local rotatingCoroutine = nil
local rotatingActive = false
local function stopRotatingCoroutine()
    rotatingActive = false
    rotatingCoroutine = nil
end

local function distributeBHListEvenly(bhList, players)
    for _, bh in ipairs(bhList) do
        bh.rotating = false
        bh.TargetPlayer = nil
        bh.AssignedParts = {}
    end

    if #players == 0 then
        for _, bh in ipairs(bhList) do
            bh.TargetPlayer = nil
            setBlackHoleActiveState(bh, false)
        end
        stopRotatingCoroutine()
        return
    end

    local totalBH = #bhList
    local playerCount = #players
    local base = math.floor(totalBH / playerCount)
    local remainder = totalBH - (base * playerCount)

    local idx = 1
    for pi = 1, playerCount do
        local pl = players[pi]
        for k = 1, base do
            if bhList[idx] then
                bhList[idx].TargetPlayer = pl
                bhList[idx].rotating = false
                setBlackHoleActiveState(bhList[idx], true)
                if pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
                    pcall(function() bhList[idx].Attachment.WorldCFrame = pl.Character.HumanoidRootPart.CFrame end)
                end
                idx = idx + 1
            end
        end
    end

    local rotatingBHs = {}
    for r = 1, remainder do
        if bhList[idx] then
            bhList[idx].rotating = true
            bhList[idx].TargetPlayer = nil
            setBlackHoleActiveState(bhList[idx], true)
            table.insert(rotatingBHs, bhList[idx])
            idx = idx + 1
        end
    end

    stopRotatingCoroutine()
    if #rotatingBHs == 0 then return end

    rotatingActive = true
    rotatingCoroutine = spawn(function()
        local posIndex = 1
        while rotatingActive do
            local curPlayers = {}
            for _, pl in ipairs(players) do
                if pl and pl.Parent and isPlayerAlive(pl) and not isWhitelisted(pl) and pl ~= localPlayer then
                    table.insert(curPlayers, pl)
                end
            end
            if #curPlayers == 0 then
                for _, rb in ipairs(rotatingBHs) do
                    rb.TargetPlayer = nil
                    setBlackHoleActiveState(rb, false)
                end
                break
            end

            for _, rb in ipairs(rotatingBHs) do
                local pick = curPlayers[((posIndex - 1) % #curPlayers) + 1]
                if pick and not isWhitelisted(pick) and pick ~= localPlayer and isPlayerAlive(pick) then
                    rb.TargetPlayer = pick
                    setBlackHoleActiveState(rb, true)
                    if pick.Character and pick.Character:FindFirstChild("HumanoidRootPart") and rb.Attachment then
                        pcall(function() rb.Attachment.WorldCFrame = pick.Character.HumanoidRootPart.CFrame end)
                    end
                else
                    rb.TargetPlayer = nil
                    setBlackHoleActiveState(rb, false)
                end
                posIndex = posIndex + 1
            end

            wait(ROTATE_INTERVAL)
        end
    end)
end

-- PAA/CMD assignment wrappers unchanged except lifecycle integration
local function assignTargetsForPAA()
    local paaBHs = getBHsBySource("PAA")
    if #paaBHs == 0 then return end

    local players = {}
    if LifeCycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(players, pl)
            end
        end
    else
        if PAA_isUsingSelected then
            players = getSelectedPlayers(true)
        else
            players = getAllNonLocalPlayers()
        end
    end

    -- Build a quick lookup of current valid players
    local playerSet = {}
    for _, pl in ipairs(players) do playerSet[pl] = true end

    -- Keep BHs pinned to their current TargetPlayer unless the BH has too few parts.
    -- Free up BHs that don't have a valid player or which have too few parts so they can be redistributed.
    local freeBHs = {}
    for _, bh in ipairs(paaBHs) do
        if bh.TargetPlayer and playerSet[bh.TargetPlayer] and isPlayerAlive(bh.TargetPlayer) and not isWhitelisted(bh.TargetPlayer) then
            -- current assignment is valid; ensure BH is active and leave it alone
            setBlackHoleActiveState(bh, true)
        else
            -- if BH currently holds fewer than MIN_PARTS_PER_PAA_BH parts, mark it for reassignment
            if #bh.AssignedParts < MIN_PARTS_PER_PAA_BH then
                bh.TargetPlayer = nil
                table.insert(freeBHs, bh)
            else
                -- otherwise keep it idle but don't switch the player -- this preserves stability
                bh.TargetPlayer = nil
                setBlackHoleActiveState(bh, false)
            end
        end
    end

    -- If there are no players to assign to, just ensure free BHs are deactivated
    if #players == 0 then
        for _, bh in ipairs(freeBHs) do
            bh.TargetPlayer = nil
            setBlackHoleActiveState(bh, false)
        end
        return
    end

    -- Shuffle and distribute only the free BHs among players
    shuffle(freeBHs)
    distributeBHListEvenly(freeBHs, players)
end

local function assignTargetsForCMD()
    local cmdBHs = getBHsBySource("CMD")
    if #cmdBHs == 0 then return end

    local players = {}
    if LifeCycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(players, pl)
            end
        end
    else
        players = getAllNonLocalPlayers()
    end

    shuffle(cmdBHs)
    distributeBHListEvenly(cmdBHs, players)
end

local function createNCommandBlackHoles(n)
    if n <= 0 then return end
    for i = 1, n do createExtraBlackHole(nil, "CMD") end
    assignTargetsForCMD()
    if PAAEnabled then assignTargetsForPAA() end
    if #extraBlackHoles > 0 then startRebalancer() end
end

local function deleteCommandBlackHoles()
    deleteBHsBySource("CMD")
    stopRotatingCoroutine()
end

local function refreshPAA()
    -- Refresh PAA without forcefully deleting existing PAA BHs.
    -- Rule: do NOT switch BH->player assignments unless a BH has fewer than MIN_PARTS_PER_PAA_BH parts.
    local paaBHs = getBHsBySource("PAA")
    local targets = {}
    if LifeCycleMode and cycleActive then
        for _, pl in ipairs(cyclePlayers) do
            if pl and pl.Parent and not cycleDead[pl] and isPlayerAlive(pl) then
                table.insert(targets, pl)
            end
        end
    else
        if PAA_isUsingSelected then
            targets = getSelectedPlayers(true)
        else
            targets = getAllNonLocalPlayers()
        end
    end

    -- Quick lookup for desired targets
    local desiredSet = {}
    for _, t in ipairs(targets) do desiredSet[t] = true end

    local freeBHs = {}
    local playerHasBH = {}

    -- Preserve current assignments when valid. Only mark BHs as free if they have too few parts or their target is invalid.
    for _, bh in ipairs(paaBHs) do
        if bh.TargetPlayer and desiredSet[bh.TargetPlayer] and isPlayerAlive(bh.TargetPlayer) and not isWhitelisted(bh.TargetPlayer) then
            -- Keep this assignment intact
            playerHasBH[bh.TargetPlayer] = true
            setBlackHoleActiveState(bh, true)
        else
            -- If BH has too few parts, free it for reassignment; otherwise keep it inactive to preserve stability
            if #bh.AssignedParts < MIN_PARTS_PER_PAA_BH then
                bh.TargetPlayer = nil
                table.insert(freeBHs, bh)
            else
                bh.TargetPlayer = nil
                setBlackHoleActiveState(bh, false)
            end
        end
    end

    -- Assign free BHs (or create new BHs) to targets that don't already have one
    for _, tgt in ipairs(targets) do
        if not playerHasBH[tgt] then
            local assigned = false
            for i, fb in ipairs(freeBHs) do
                fb.TargetPlayer = tgt
                setBlackHoleActiveState(fb, true)
                if tgt.Character and tgt.Character:FindFirstChild("HumanoidRootPart") and fb.Attachment then
                    pcall(function() fb.Attachment.WorldCFrame = tgt.Character.HumanoidRootPart.CFrame end)
                end
                table.remove(freeBHs, i)
                assigned = true
                break
            end
            if not assigned then
                local bh = createExtraBlackHole(tgt, "PAA")
                bh.TargetPlayer = tgt
                bh.LastTarget = nil
                setBlackHoleActiveState(bh, true)
                if tgt.Character and tgt.Character:FindFirstChild("HumanoidRootPart") and bh.Attachment then
                    pcall(function() bh.Attachment.WorldCFrame = tgt.Character.HumanoidRootPart.CFrame end)
                end
            end
        end
    end

    -- Any remaining free BHs should be deactivated (they won't steal players)
    for _, fb in ipairs(freeBHs) do
        fb.TargetPlayer = nil
        setBlackHoleActiveState(fb, false)
    end

    if #extraBlackHoles > 0 then startRebalancer() end
end

local function onPlayerAddedForPAA(pl)
    if PAAEnabled and not PAA_isUsingSelected and pl ~= localPlayer and not isWhitelisted(pl) then
        if LifeCycleMode and cycleActive then
            return
        end
        local bh = createExtraBlackHole(pl, "PAA")
        bh.TargetPlayer = pl
        bh.LastTarget = nil
        assignTargetsForPAA()
    end
end

local function onPlayerRemovingForPAA(pl)
    if PAAEnabled then
        for i = #extraBlackHoles, 1, -1 do
            local bh = extraBlackHoles[i]
            if bh and bh.source == "PAA" and bh.TargetPlayer == pl then
                destroyExtraBlackHole(bh)
                table.remove(extraBlackHoles, i)
                break
            end
        end
        assignTargetsForPAA()
    end
end

-- LifeCycle / rebalancer and other management functions
local function clearCycleConnections()
    for _, conn in ipairs(cycleConns) do
        if conn and conn.Disconnect then
            pcall(function() conn:Disconnect() end)
        end
    end
    cycleConns = {}
end

local function stopCycle()
    cycleActive = false
    cyclePlayers = {}
    cycleDead = {}
    clearCycleConnections()
    cycleRestartPending = false
end

local function checkCycleCompletionAndMaybeRestart()
    if not cycleActive then return end
    if #cyclePlayers == 0 then
        cycleRestartPending = true
        return
    end
    for _, pl in ipairs(cyclePlayers) do
        if not cycleDead[pl] then
            return
        end
    end
    cycleRestartPending = true
end

local function scheduleCycleRestart()
    if cycleRestartPending then
        cycleRestartPending = false
        spawn(function()
            wait(0.12)
            local newSnapshot = {}
            if targetSelectedActive then
                newSnapshot = getSelectedPlayers(false)
            else
                newSnapshot = getAllNonLocalPlayers()
            end
            cyclePlayers = {}
            cycleDead = {}
            for _, pl in ipairs(newSnapshot) do
                if pl and pl.Parent and pl ~= localPlayer then
                    cyclePlayers[#cyclePlayers+1] = pl
                    cycleDead[pl] = false
                end
            end
            clearCycleConnections()
            for _, pl in ipairs(cyclePlayers) do
                if pl and pl.Parent then
                    local function onHumanoidAdded(char)
                        local hum = char:FindFirstChildOfClass("Humanoid")
                        if hum then
                            local dconn = hum.Died:Connect(function()
                                cycleDead[pl] = true
                                assignTargetsForPAA()
                                assignTargetsForCMD()
                                checkCycleCompletionAndMaybeRestart()
                            end)
                            table.insert(cycleConns, dconn)
                        end
                    end
                    if pl.Character then
                        onHumanoidAdded(pl.Character)
                    end
                    local cconn = pl.CharacterAdded:Connect(onHumanoidAdded)
                    table.insert(cycleConns, cconn)
                    local rconn = pl.AncestryChanged:Connect(function()
                        if not pl.Parent then
                            for i = #cyclePlayers, 1, -1 do
                                if cyclePlayers[i] == pl then table.remove(cyclePlayers, i) end
                            end
                            cycleDead[pl] = true
                            assignTargetsForPAA()
                            assignTargetsForCMD()
                            checkCycleCompletionAndMaybeRestart()
                        end
                    end)
                    table.insert(cycleConns, rconn)
                end
            end
            assignTargetsForPAA()
            assignTargetsForCMD()
        end)
    end
end

local function startCycleSnapshot()
    stopCycle()
    cycleActive = true
    cyclePlayers = {}
    cycleDead = {}

    local snapshot = {}
    if targetSelectedActive then
        snapshot = getSelectedPlayers(false)
    else
        snapshot = getAllNonLocalPlayers()
    end

    for _, pl in ipairs(snapshot) do
        if pl and pl.Parent and pl ~= localPlayer then
            cyclePlayers[#cyclePlayers+1] = pl
            cycleDead[pl] = false
        end
    end

    clearCycleConnections()
    for _, pl in ipairs(cyclePlayers) do
        if pl and pl.Parent then
            local function attachHumanoidWatcher(char)
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    local dconn = hum.Died:Connect(function()
                        cycleDead[pl] = true
                        assignTargetsForPAA()
                        assignTargetsForCMD()
                        checkCycleCompletionAndMaybeRestart()
                        scheduleCycleRestart()
                    end)
                    table.insert(cycleConns, dconn)
                end
            end
            if pl.Character then attachHumanoidWatcher(pl.Character) end
            local cconn = pl.CharacterAdded:Connect(attachHumanoidWatcher)
            table.insert(cycleConns, cconn)
            local rconn = pl.AncestryChanged:Connect(function()
                if not pl.Parent then
                    for i = #cyclePlayers, 1, -1 do
                        if cyclePlayers[i] == pl then table.remove(cyclePlayers, i) end
                    end
                    cycleDead[pl] = true
                    assignTargetsForPAA()
                    assignTargetsForCMD()
                    checkCycleCompletionAndMaybeRestart()
                    scheduleCycleRestart()
                end
            end)
            table.insert(cycleConns, rconn)
        end
    end

    assignTargetsForPAA()
    assignTargetsForCMD()
end

-- New lifecycle helpers referenced by GUI
local function tryStartCycleIfNeeded()
    if LifeCycleMode and not cycleActive and (targetAllActive or targetSelectedActive) then
        startCycleSnapshot()
    end
end

local function endCycleMode()
    stopCycle()
    deleteBHsBySource("PAA")
end

local function resetCycleNow()
    stopCycle()
    startCycleSnapshot()
end

function startRebalancer()
    if rebalancerRunning then return end
    rebalancerRunning = true
    spawn(function()
        while rebalancerRunning do
            -- clear previous assigned lists so we can recompute fresh each tick
            for _, bh in ipairs(extraBlackHoles) do bh.AssignedParts = {} end
            local bhCount = #extraBlackHoles
            local parts = {}
            for p, _ in pairs(processedParts) do
                if p and p.Parent then
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    if ap then
                        pcall(function()
                            local isMass = (pcall(function() return p.Massless end) and p.Massless)
                            ap.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                            ap.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                        end)
                        table.insert(parts, p)
                    else
                        ForcePart(p)
                        local ap2 = p:FindFirstChildOfClass("AlignPosition")
                        if ap2 then
                            pcall(function()
                                local isMass = (pcall(function() return p.Massless end) and p.Massless)
                                ap2.MaxForce = PULL_MAX_FORCE * (isMass and MASSLESS_PULL_SCALE or 1)
                                ap2.Responsiveness = PULL_RESPONSIVENESS * (isMass and MASSLESS_RESP_SCALE or 1)
                            end)
                            table.insert(parts, p)
                        end
                    end
                end
            end

            if bhCount > 0 and #parts > 0 then
                local total = #parts
                local base = math.floor(total / bhCount)
                local rem = total - (base * bhCount)
                local counts = {}
                for i = 1, bhCount do counts[i] = base + (i <= rem and 1 or 0) end

                local partIndex = 1
                for i = 1, bhCount do
                    local bh = extraBlackHoles[i]
                    local need = counts[i]
                    for c = 1, need do
                        local p = parts[partIndex]
                        if not p then break end
                        local ap = p:FindFirstChildOfClass("AlignPosition")
                        local ao = p:FindFirstChildOfClass("AlignOrientation")
                        if ap then
                            if bh and bh.Attachment and bh._active then
                                ap.Attachment1 = bh.Attachment
                                if ao then ao.Attachment1 = bh.Attachment end
                                p.CanCollide = false
                                table.insert(bh.AssignedParts, p)
                            else
                                ap.Attachment1 = Attachment1
                                if ao then ao.Attachment1 = Attachment1 end
                                p.CanCollide = false
                            end
                        end
                        partIndex = partIndex + 1
                    end
                end
            else
                for _, p in ipairs(parts) do
                    local ap = p:FindFirstChildOfClass("AlignPosition")
                    local ao = p:FindFirstChildOfClass("AlignOrientation")
                    if ap then ap.Attachment1 = Attachment1; p.CanCollide = false end
                    if ao then ao.Attachment1 = Attachment1 end
                end
            end

            if PAAEnabled then assignTargetsForPAA() end
            assignTargetsForCMD()

            if cycleRestartPending then
                scheduleCycleRestart()
            end

            wait(rebalancerFreq)
        end
    end)
end

function stopRebalancer() rebalancerRunning = false end

-- Commands (chat) - removed blackhole create/delete chat commands per request
local enableCommands = true
local function onLocalPlayerChatted(msg)
    if not enableCommands then return end
    if not msg then return end
    local raw = msg
    msg = msg:lower()

    if string.match(msg, "^/e%s+paa") then
        PAAEnabled = true
        PAA_isUsingSelected = false
        refreshPAA()
        paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
        paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
        return
    end

    if string.match(msg, "^/e%s+unpaa") then
        PAAEnabled = false
        for _, c in ipairs(paaConnections) do pcall(function() c:Disconnect() end) end
        paaConnections = {}
        deleteBHsBySource("PAA")
        return
    end

    if string.match(msg, "^/e%s+psel") then
        PAAEnabled = true
        PAA_isUsingSelected = true
        refreshPAA()
        return
    end
end

localPlayer.Chatted:Connect(onLocalPlayerChatted)

-- Spawn-seeking implementation
local function findAllSpawnPoints()
    local spawns = {}
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("SpawnLocation") then
            table.insert(spawns, obj)
        end
    end
    -- Also check for a named 'SpawnLocation' object or 'WorldSpawn' parts if creators used other naming
    for _, obj in ipairs(Workspace:GetChildren()) do
        if obj:IsA("BasePart") and (obj.Name:lower():find("spawn") or obj.Name:lower():find("worldspawn")) then
            table.insert(spawns, obj)
        end
    end
    return spawns
end

local function refreshSpawnBHs()
    -- Remove existing spawn BHs
    deleteBHsBySource("SPAWN")
    -- Create BHs for current spawn points
    local spawns = findAllSpawnPoints()
    for _, s in ipairs(spawns) do
        if s and s:IsA("BasePart") then
            local bh = createExtraBlackHole(nil, "SPAWN", s)
            -- spawn BHs should not target players directly; they are static attachments
            bh._createdForSpawn = s
            bh._static = true
            if s:IsA("BasePart") then
                pcall(function() bh.Attachment.WorldCFrame = s.CFrame end)
            end
        end
    end
    if #extraBlackHoles > 0 then startRebalancer() end
end

local function onSpawnDescendantAdded(desc)
    if not spawnSeekingEnabled then return end
    if desc:IsA("SpawnLocation") or (desc:IsA("BasePart") and (desc.Name:lower():find("spawn") or desc.Name:lower():find("worldspawn"))) then
        refreshSpawnBHs()
    end
end

local function onSpawnDescendantRemoving(desc)
    if not spawnSeekingEnabled then return end
    if desc:IsA("SpawnLocation") or (desc:IsA("BasePart") and (desc.Name:lower():find("spawn") or desc.Name:lower():find("worldspawn"))) then
        refreshSpawnBHs()
    end
end

local spawnAddedConn, spawnRemovingConn
local function enableSpawnSeeking(enable)
    spawnSeekingEnabled = enable
    if spawnSeekingEnabled then
        refreshSpawnBHs()
        spawnAddedConn = Workspace.DescendantAdded:Connect(function(d) onSpawnDescendantAdded(d) end)
        spawnRemovingConn = Workspace.DescendantRemoving and Workspace.DescendantRemoving:Connect(function(d) onSpawnDescendantRemoving(d) end) or nil
        -- fallback: listen to AncestryChanged on Workspace children to catch removal
        if not spawnRemovingConn then
            spawnRemovingConn = Workspace.ChildRemoved:Connect(function(c) onSpawnDescendantRemoving(c) end)
        end
    else
        -- remove spawn BHs
        deleteBHsBySource("SPAWN")
        if spawnAddedConn then pcall(function() spawnAddedConn:Disconnect() end) end
        if spawnRemovingConn then pcall(function() spawnRemovingConn:Disconnect() end) end
    end
end

-- Primary loop
local function startPrimaryLoop()
    if primaryLoopRunning then return end
    primaryLoopRunning = true
    if not Attachment1 or not Attachment1.Parent then Attachment1 = setupPlayer() end
    anchoredOnce = false
    processWorkspaceParts()

    spawn(function()
        local phaseT = 0
        local lastHeartbeat = tick()
        while targetAllActive or targetSelectedActive do
            local now = tick()
            local dt = now - lastHeartbeat
            lastHeartbeat = now
            phaseT = phaseT + dt

            if targetSelectedActive then
                local selectedPlayers = getSelectedPlayers(true)
                if #selectedPlayers > 0 then
                    targetPlayer = selectedPlayers[math.random(1, #selectedPlayers)]
                else
                    targetPlayer = nil
                end
            elseif targetAllActive then
                targetPlayer = getRandomPlayer()
            else
                targetPlayer = nil
            end

            if targetPlayer and targetPlayer.Character and isPlayerAlive(targetPlayer) then
                -- pick head or HRP depending on toggle
                local targetPart = nil
                if targetHeadEnabled and targetPlayer.Character:FindFirstChild("Head") then
                    targetPart = targetPlayer.Character.Head
                else
                    targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                end

                if targetPart then
                    local vel = targetPart.Velocity or Vector3.new(0,0,0)
                    local speed = vel.Magnitude
                    local dir = (speed > 0.5) and vel.Unit or targetPart.CFrame.LookVector
                    local amplitude = clamp(speed * BH_AMPLITUDE_FACTOR, BH_MIN_AMPLITUDE, BH_MAX_AMPLITUDE)
                    local phase = phaseT * (2 * math.pi * BH_OSC_FREQUENCY)
                    local primaryOffset = dir * (math.sin(phase) * amplitude)
                    local lateral = targetPart.CFrame.RightVector * (math.sin(phase * 1.27) * amplitude * 0.35)
                    local vertical = targetPart.CFrame.UpVector * (math.sin(phase * 1.0) * amplitude * 0.5)
                    local targetCFrame = targetPart.CFrame * CFrame.new(primaryOffset + lateral + vertical)
                    if Attachment1 then
                        local success, cur = pcall(function() return Attachment1.WorldCFrame end)
                        local curCF = success and cur or Attachment1.WorldCFrame or targetPart.CFrame
                        Attachment1.WorldCFrame = smoothLerpCFrame(curCF, targetCFrame, dt)
                    end
                end
            end

            wait(switchDelay)
        end

        primaryLoopRunning = false
        if unanchorTimerRunning and unanchorCoroutine then
            unanchorTimerRunning = false
            for part, anchored in pairs(initiallyAnchoredParts) do
                if part and part.Parent and anchored == false then
                    part.Anchored = false
                    ForcePart(part)
                end
            end
        end
        clearProcessedParts()

        if PAAEnabled then deleteBHsBySource("PAA") end
    end)
end

local function setTargetAll(value)
    targetAllActive = value
    if (targetAllActive or targetSelectedActive) then startPrimaryLoop() end

    if LifeCycleMode then
        if targetAllActive then
            tryStartCycleIfNeeded()
        else
            stopCycle()
        end
    end

    if PAAEnabled then
        if targetAllActive then
            PAA_isUsingSelected = false
            refreshPAA()
            if #paaConnections == 0 then
                paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
                paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
            end
        else
            deleteBHsBySource("PAA")
        end
    end
end

local function setTargetSelected(value)
    targetSelectedActive = value
    if (targetAllActive or targetSelectedActive) then startPrimaryLoop() end

    if LifeCycleMode then
        if targetSelectedActive then
            tryStartCycleIfNeeded()
        else
            stopCycle()
        end
    end

    if PAAEnabled then
        if targetSelectedActive then
            PAA_isUsingSelected = true
            refreshPAA()
            if #paaConnections == 0 then
                paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
                paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
            end
        else
            deleteBHsBySource("PAA")
        end
    end
end

local function onCharacterAdded(character)
    if (targetAllActive or targetSelectedActive) then
        processedParts = {}
        processWorkspaceParts()
    end
end

Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

-- GUI (TurtleLib) - removed manual create/delete BH buttons
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/miroeramaa/TurtleLib/main/TurtleUiLib.lua"))()
local window = library:Window("Fix it you panis negor🗣🔥")

window:Toggle("Unanchored Target All", false, function(Value) setTargetAll(Value) end)
window:Toggle("Target Selected Players", false, function(Value) setTargetSelected(Value) end)

-- Life Cycle Mode toggle (replaced to trigger start/stop immediately)
window:Toggle("Life Cycle Mode", false, function(Value)
    LifeCycleMode = Value
    if LifeCycleMode then
        -- If either target mode is currently active, start lifecycle immediately
        if targetAllActive or targetSelectedActive then
            startCycleSnapshot()
        end
    else
        -- Turning lifecycle mode off; stop any active cycle
        if cycleActive then
            stopCycle()
        end
    end
end)

window:Button("Load Player List Script", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Jlchris1/Udklol/refs/heads/main/Playerlistv6"))()
end)
window:Button("telekinesis/fix target", function()
    loadstring(game:HttpGet(('https://raw.githubusercontent.com/SAZXHUB/Control-update/main/README.md'), true))()
end)

local loopCheckActive = false
window:Toggle("Continuous Loop Check", false, function(Value)
    loopCheckActive = Value
    if loopCheckActive then
        spawn(function()
            while loopCheckActive do
                if targetAllActive or targetSelectedActive then
                    for _, v in ipairs(Workspace:GetDescendants()) do
                        if v:IsA("BasePart") and not v.Anchored and not processedParts[v] and not isPartPlayerCharacter(v) and not (localPlayer.Character and v:IsDescendantOf(localPlayer.Character)) then
                            if initiallyMasslessParts[v] == nil then pcall(function() initiallyMasslessParts[v] = v.Massless end) end
                            pcall(function() v.Massless = true end)
                            ForcePart(v)
                        end
                    end
                end
                wait(0.5)
            end
        end)
    end
end)

window:Toggle("PAA/unPAA (player amount BHs)", false, function(Value)
    PAAEnabled = Value
    if PAAEnabled then
        PAA_isUsingSelected = false
        refreshPAA()
        paaConnections[#paaConnections+1] = Players.PlayerAdded:Connect(onPlayerAddedForPAA)
        paaConnections[#paaConnections+1] = Players.PlayerRemoving:Connect(onPlayerRemovingForPAA)
    else
        for _, c in ipairs(paaConnections) do pcall(function() c:Disconnect() end) end
        paaConnections = {}
        deleteBHsBySource("PAA")
    end
end)

-- NEW: Spawn Seeking toggle
window:Toggle("Spawn Seeking (spawnpoint BHs)", false, function(Value)
    enableSpawnSeeking(Value)
end)

-- Removed manual create/delete BH buttons per request

-- NEW: Target Head toggle (blackholes will target the Head instead of HRP)
window:Toggle("Target Head", false, function(Value)
    targetHeadEnabled = Value
end)

-- spawn loops that maintain PAA and rebalancer state
spawn(function()
    while true do
        if PAAEnabled then
            if PAA_isUsingSelected then
                if targetSelectedActive then refreshPAA() end
            else
                if targetAllActive then refreshPAA() end
            end
        end
        wait(2)
    end
end)

spawn(function()
    while true do
        if #extraBlackHoles > 0 and not rebalancerRunning then startRebalancer()
        elseif #extraBlackHoles == 0 and rebalancerRunning then stopRebalancer() end
        if cycleRestartPending then scheduleCycleRestart() end
        wait(0.5)
    end
end)

-- KEEP static spawn BH attachments locked to their spawn parts
spawn(function()
    while true do
        for _, bh in ipairs(extraBlackHoles) do
            if bh and bh._static and bh.spawnRef and bh.spawnRef.Parent and bh.Attachment then
                pcall(function() bh.Attachment.WorldCFrame = bh.spawnRef.CFrame end)
            end
        end
        wait(0.08)
    end
end)

-- HUD
do
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ÆS_BHCountGui"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = localPlayer:WaitForChild("PlayerGui")

    local txt = Instance.new("TextLabel")
    txt.Name = "BlackHoleCount"
    txt.AnchorPoint = Vector2.new(0.5, 0)
    txt.Position = UDim2.new(0.5, 0, 0, 6)
    txt.Size = UDim2.new(0, 220, 0, 24)
    txt.BackgroundTransparency = 1
    txt.TextTransparency = 0
    txt.Text = "BlackHoles: 0"
    txt.TextScaled = false
    txt.TextSize = 18
    txt.Font = Enum.Font.SourceSansSemibold
    txt.TextColor3 = Color3.new(1,1,1)
    txt.Parent = screenGui

    local function countBlackHolePartsInFolders()
        local count = 0
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if obj:IsA("Folder") then
                local lname = obj.Name:lower()
                if string.find(lname, "blackhole") or string.find(lname, "bh") or string.find(lname, "aes_blackhole") or string.find(lname, "æs_blackhole") then
                    for _, child in ipairs(obj:GetDescendants()) do
                        if child:IsA("BasePart") then
                            local cname = child.Name:lower()
                            if string.find(cname, "extrabh_center") or string.find(cname, "bh_center") or string.find(cname, "bh_center_part") or string.find(cname, "extra") then
                                count = count + 1
                            end
                        end
                    end
                end
            end
        end
        return count
    end

    spawn(function()
        while true do
            local count = 0
            pcall(function() count = countBlackHolePartsInFolders() end)
            txt.Text = "BlackHoles: "..tostring(count)
            wait(0.5)
        end
    end)
end

-- End of script
